<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pointwise CLT for ECDF - Interactive Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.6/jstat.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e2e8f0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2.5em;
            font-weight: 700;
            background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #94a3b8;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .controls-panel {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(148, 163, 184, 0.1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        label {
            font-size: 0.9em;
            color: #cbd5e1;
            font-weight: 500;
        }

        select, input[type="number"], input[type="text"] {
            background: #1e293b;
            color: #e2e8f0;
            border: 1px solid #475569;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            transition: all 0.2s;
        }

        select:hover, input:hover {
            border-color: #60a5fa;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #60a5fa;
            box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.1);
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: #475569;
        }

        button.secondary:hover {
            background: #64748b;
            box-shadow: 0 4px 12px rgba(71, 85, 105, 0.4);
        }

        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin: 15px 0;
            padding: 12px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            align-items: center;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .swatch {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .canvas-container {
            background: rgba(15, 23, 42, 0.9);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(148, 163, 184, 0.1);
            position: relative;
        }

        canvas {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 8px;
        }

        .stats-panel {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .stat-item {
            background: rgba(15, 23, 42, 0.6);
            padding: 10px;
            border-radius: 6px;
            border-left: 3px solid #60a5fa;
        }

        .stat-label {
            font-size: 0.85em;
            color: #94a3b8;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: 600;
            color: #60a5fa;
        }

        .info-box {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            border: 1px solid rgba(96, 165, 250, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }

        .info-box h3 {
            color: #60a5fa;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .info-box p {
            line-height: 1.6;
            color: #cbd5e1;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            z-index: 10;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(96, 165, 250, 0.3);
            border-top-color: #60a5fa;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .tooltip {
            position: absolute;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid #475569;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.85em;
            pointer-events: none;
            display: none;
            z-index: 20;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        @media (max-width: 768px) {
            h1 { font-size: 1.8em; }
            .controls-grid { grid-template-columns: 1fr; }
            .legend { gap: 10px; }
            .button-group { flex-direction: column; }
            button { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Pointwise CLT for the Empirical CDF</h1>
        <p class="subtitle">Visualizing convergence to N(0,1) at multiple quantiles</p>

        <div class="info-box">
            <h3>ðŸ“Š Interactive Visualization Guide</h3>
            <p>
                This visualization demonstrates Donsker's theorem: For each fixed x, the standardized empirical CDF 
                <strong>Z<sub>n</sub>(x) = âˆšnÂ·(FÌ‚<sub>n</sub>(x) - F(x))/âˆš[F(x)Â·(1-F(x))]</strong> converges to N(0,1).
                Hover over panels to see detailed statistics. Larger sample sizes should show better alignment with the white normal curve.
            </p>
        </div>

        <div class="controls-panel">
            <div class="controls-grid">
                <div class="control-group">
                    <label for="dist">Distribution</label>
                    <select id="dist">
                        <option value="normal">Normal(0, 1)</option>
                        <option value="uniform">Uniform(0, 1)</option>
                        <option value="exponential">Exponential(Î»=1)</option>
                        <option value="beta">Beta(Î±=2, Î²=5)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="ns">Sample Sizes (comma-separated)</label>
                    <input type="text" id="ns" value="20, 50, 100, 500" />
                </div>
                <div class="control-group">
                    <label for="B">Simulations per n</label>
                    <input type="number" id="B" min="500" max="20000" step="500" value="5000" />
                </div>
                <div class="control-group">
                    <label for="kpts">Number of x-points</label>
                    <input type="number" id="kpts" min="4" max="16" step="1" value="12" />
                </div>
                <div class="control-group">
                    <label for="bins">Histogram Bins</label>
                    <input type="number" id="bins" min="20" max="100" step="5" value="50" />
                </div>
            </div>
            <div class="button-group">
                <button id="run">ðŸŽ² Run Simulation</button>
                <button id="compare" class="secondary">ðŸ”„ Compare Distributions</button>
                <button id="save" class="secondary">ðŸ’¾ Download Image</button>
                <button id="exportData" class="secondary">ðŸ“Š Export Data (CSV)</button>
            </div>
        </div>

        <div class="legend" id="legend"></div>

        <div class="canvas-container">
            <div class="loading-overlay" id="loading">
                <div class="loading-spinner"></div>
            </div>
            <canvas id="cv" width="1400" height="900"></canvas>
            <div class="tooltip" id="tooltip"></div>
        </div>

        <div class="stats-panel" id="statsPanel">
            <h3 style="color: #60a5fa; margin-bottom: 10px;">Convergence Statistics</h3>
            <div class="stats-grid" id="statsGrid"></div>
        </div>
    </div>

    <script>
        const cv = document.getElementById('cv');
        const ctx = cv.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const loading = document.getElementById('loading');
        const statsPanel = document.getElementById('statsPanel');
        const statsGrid = document.getElementById('statsGrid');

        // Modern color palette with good contrast
        const palette = [
            '#ef4444', // red
            '#f59e0b', // amber
            '#22c55e', // green
            '#3b82f6', // blue
            '#8b5cf6', // violet
            '#ec4899', // pink
            '#14b8a6'  // teal
        ];

        const zMin = -3.5, zMax = 3.5;
        let currentData = null;
        let comparisonMode = false;

        function normalPDF(z) {
            return Math.exp(-0.5 * z * z) / Math.sqrt(2 * Math.PI);
        }

        function quantiles(dist, k) {
            const qs = Array.from({length: k}, (_, i) => (i + 1) / (k + 1));
            if (dist === 'normal') return qs.map(q => jStat.normal.inv(q, 0, 1));
            if (dist === 'uniform') return qs;
            if (dist === 'exponential') return qs.map(q => -Math.log(1 - q));
            if (dist === 'beta') return qs.map(q => jStat.beta.inv(q, 2, 5));
        }

        function trueCDF(dist, x) {
            if (dist === 'normal') return jStat.normal.cdf(x, 0, 1);
            if (dist === 'uniform') return x < 0 ? 0 : (x > 1 ? 1 : x);
            if (dist === 'exponential') return x < 0 ? 0 : (1 - Math.exp(-x));
            if (dist === 'beta') return x <= 0 ? 0 : (x >= 1 ? 1 : jStat.beta.cdf(x, 2, 5));
        }

        function sample(dist, n) {
            const a = new Array(n);
            if (dist === 'normal') {
                for (let i = 0; i < n; i++) a[i] = jStat.normal.sample(0, 1);
            } else if (dist === 'uniform') {
                for (let i = 0; i < n; i++) a[i] = Math.random();
            } else if (dist === 'exponential') {
                for (let i = 0; i < n; i++) a[i] = -Math.log(Math.random());
            } else {
                for (let i = 0; i < n; i++) a[i] = jStat.beta.sample(2, 5);
            }
            a.sort((u, v) => u - v);
            return a;
        }

        function ecdf(sorted, x) {
            let lo = 0, hi = sorted.length;
            while (lo < hi) {
                const mid = (lo + hi) >>> 1;
                if (sorted[mid] <= x) lo = mid + 1; else hi = mid;
            }
            return lo / sorted.length;
        }

        function drawPanel(gx, gy, w, h, panelData, title, subtitle) {
            ctx.save();
            ctx.translate(gx, gy);

            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, h);
            gradient.addColorStop(0, 'rgba(15, 23, 42, 0.95)');
            gradient.addColorStop(1, 'rgba(30, 41, 59, 0.95)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, w, h);

            // Border
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, w, h);

            const left = 50, right = w - 15, top = 35, bottom = h - 45;

            // Grid lines
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.05)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= 4; i++) {
                const y = top + i * (bottom - top) / 4;
                ctx.beginPath();
                ctx.moveTo(left, y);
                ctx.lineTo(right, y);
                ctx.stroke();
            }

            // Axes
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(left, bottom);
            ctx.lineTo(right, bottom);
            ctx.moveTo(left, top);
            ctx.lineTo(left, bottom);
            ctx.stroke();

            // X-axis labels
            ctx.fillStyle = '#94a3b8';
            ctx.font = '11px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for (let k = -3; k <= 3; k++) {
                const x = left + (k - zMin) * (right - left) / (zMax - zMin);
                ctx.beginPath();
                ctx.moveTo(x, bottom);
                ctx.lineTo(x, bottom + 4);
                ctx.stroke();
                if (k % 1 === 0) {
                    ctx.fillText(k === 0 ? '0' : String(k), x, bottom + 8);
                }
            }

            // Y-axis
            const dMax = panelData.dMax;
            function yOf(d) { return bottom - (d / dMax) * (bottom - top); }
            function xOf(z) { return left + (z - zMin) * (right - left) / (zMax - zMin); }

            // Y-axis labels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let i = 0; i <= 4; i++) {
                const d = (i / 4) * dMax;
                const y = yOf(d);
                ctx.fillText(d.toFixed(2), left - 8, y);
            }

            // Draw histograms with transparency
            panelData.series.forEach((ser, idx) => {
                const col = palette[idx % palette.length];
                const bins = ser.bins;
                const bw = (right - left) / bins.length * 0.85;
                
                ctx.fillStyle = col + '99'; // Semi-transparent
                for (let b = 0; b < bins.length; b++) {
                    const zc = ser.zCenters[b];
                    const x = xOf(zc) - bw / 2;
                    const d = bins[b];
                    const y = yOf(d);
                    if (bottom - y > 1) {
                        ctx.fillRect(x, y, bw, bottom - y);
                    }
                }
            });

            // Draw standard normal curve
            ctx.beginPath();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 4;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            for (let z = zMin; z <= zMax; z += 0.01) {
                const x = xOf(z);
                const y = yOf(normalPDF(z));
                if (z === zMin) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Title and subtitle
            ctx.fillStyle = '#e2e8f0';
            ctx.font = 'bold 13px Inter, sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
            ctx.fillText(title, left, 18);
            
            ctx.fillStyle = '#60a5fa';
            ctx.font = '11px Inter, sans-serif';
            ctx.fillText(subtitle, left, 30);

            // Store panel bounds for hover detection
            if (!panelData.bounds) panelData.bounds = [];
            panelData.bounds.push({
                x: gx, y: gy, w, h,
                title, subtitle, data: panelData
            });

            ctx.restore();
        }

        function updateLegend(ns) {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';
            
            ns.forEach((n, i) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="swatch" style="background: ${palette[i % palette.length]}"></div>
                    <span>n = ${n}</span>
                `;
                legend.appendChild(item);
            });
            
            // Add normal distribution
            const normalItem = document.createElement('div');
            normalItem.className = 'legend-item';
            normalItem.innerHTML = `
                <div class="swatch" style="background: white; border: 1px solid #475569"></div>
                <span>N(0,1) Theory</span>
            `;
            legend.appendChild(normalItem);
        }

        function calculateStats(panelData) {
            const stats = [];
            panelData.series.forEach(ser => {
                const mean = ser.zValues.reduce((a, b) => a + b, 0) / ser.zValues.length;
                const variance = ser.zValues.reduce((a, b) => a + (b - mean) ** 2, 0) / ser.zValues.length;
                const ks = calculateKSStatistic(ser.zValues);
                stats.push({
                    n: ser.n,
                    mean: mean.toFixed(4),
                    variance: variance.toFixed(4),
                    ks: ks.toFixed(4)
                });
            });
            return stats;
        }

        function calculateKSStatistic(zValues) {
            const sorted = [...zValues].sort((a, b) => a - b);
            let maxDiff = 0;
            for (let i = 0; i < sorted.length; i++) {
                const empirical = (i + 1) / sorted.length;
                const theoretical = jStat.normal.cdf(sorted[i], 0, 1);
                maxDiff = Math.max(maxDiff, Math.abs(empirical - theoretical));
            }
            return maxDiff;
        }

        async function run() {
            loading.style.display = 'flex';
            
            const dist = document.getElementById('dist').value;
            const B = parseInt(document.getElementById('B').value);
            const binsN = parseInt(document.getElementById('bins').value);
            const kpts = parseInt(document.getElementById('kpts').value);
            const ns = document.getElementById('ns').value
                .split(',')
                .map(s => parseInt(s.trim()))
                .filter(x => x > 0)
                .slice(0, 7);

            updateLegend(ns);

            // Layout
            const cols = Math.min(kpts, 4);
            const rows = Math.ceil(kpts / cols);
            const pad = 15;
            const panelW = Math.floor((cv.width - pad * (cols + 1)) / cols);
            const panelH = Math.floor((cv.height - pad * (rows + 1)) / rows);

            // Clear canvas
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, cv.width, cv.height);

            const xs = quantiles(dist, kpts);
            const zCenters = Array.from({length: binsN}, (_, i) => 
                zMin + (i + 0.5) * (zMax - zMin) / binsN
            );

            // Pre-generate samples
            const samplesByN = new Map();
            for (const n of ns) {
                await new Promise(resolve => setTimeout(resolve, 0)); // Keep UI responsive
                samplesByN.set(n, Array.from({length: B}, () => sample(dist, n)));
            }

            const allPanelData = [];

            for (let idx = 0; idx < xs.length; idx++) {
                const x = xs[idx];
                const Fx = trueCDF(dist, x);
                const varx = Fx * (1 - Fx);
                
                if (varx < 1e-3) continue;

                const series = [];
                let panelMax = 0;

                for (let nIdx = 0; nIdx < ns.length; nIdx++) {
                    const n = ns[nIdx];
                    const arr = samplesByN.get(n);
                    const zs = new Array(B);
                    
                    for (let b = 0; b < B; b++) {
                        const Fn = ecdf(arr[b], x);
                        const z = Math.sqrt(n) * (Fn - Fx) / Math.sqrt(varx);
                        zs[b] = isFinite(z) ? z : 0;
                    }

                    // Create histogram
                    const hist = new Array(binsN).fill(0);
                    const bw = (zMax - zMin) / binsN;
                    let count = 0;
                    
                    for (const z of zs) {
                        if (z >= zMin && z < zMax) {
                            const k = Math.floor((z - zMin) / bw);
                            hist[k]++;
                            count++;
                        }
                    }
                    
                    const dens = hist.map(c => c / (count * bw));
                    const dMax = Math.max(...dens, 1e-6);
                    panelMax = Math.max(panelMax, dMax, 0.42);
                    
                    series.push({ n, bins: dens, zCenters, zValues: zs });
                }

                const gx = pad + (idx % cols) * (panelW + pad);
                const gy = pad + Math.floor(idx / cols) * (panelH + pad);
                
                const panelData = { series, dMax: panelMax };
                allPanelData.push(panelData);
                
                drawPanel(
                    gx, gy, panelW, panelH, 
                    panelData,
                    `x = ${x.toFixed(2)}`,
                    `F(x) = ${Fx.toFixed(3)}, Var = ${varx.toFixed(3)}`
                );
            }

            currentData = { allPanelData, ns };
            loading.style.display = 'none';
        }

        // Compare distributions
        async function compareDistributions() {
            comparisonMode = true;
            loading.style.display = 'flex';
            
            const distributions = ['normal', 'uniform', 'exponential', 'beta'];
            const B = parseInt(document.getElementById('B').value);
            const binsN = parseInt(document.getElementById('bins').value);
            const ns = document.getElementById('ns').value
                .split(',')
                .map(s => parseInt(s.trim()))
                .filter(x => x > 0)
                .slice(0, 7);

            updateLegend(ns);

            // Use 4 panels for 4 distributions
            const cols = 2;
            const rows = 2;
            const pad = 15;
            const panelW = Math.floor((cv.width - pad * (cols + 1)) / cols);
            const panelH = Math.floor((cv.height - pad * (rows + 1)) / rows);

            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, cv.width, cv.height);

            const zCenters = Array.from({length: binsN}, (_, i) => 
                zMin + (i + 0.5) * (zMax - zMin) / binsN
            );

            for (let distIdx = 0; distIdx < distributions.length; distIdx++) {
                const dist = distributions[distIdx];
                // Use median (quantile 0.5) for comparison
                const x = dist === 'normal' ? 0 :
                         dist === 'uniform' ? 0.5 :
                         dist === 'exponential' ? -Math.log(0.5) :
                         jStat.beta.inv(0.5, 2, 5);
                
                const Fx = trueCDF(dist, x);
                const varx = Fx * (1 - Fx);

                const series = [];
                let panelMax = 0;

                // Generate samples for this distribution
                const samplesByN = new Map();
                for (const n of ns) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                    samplesByN.set(n, Array.from({length: B}, () => sample(dist, n)));
                }

                for (let nIdx = 0; nIdx < ns.length; nIdx++) {
                    const n = ns[nIdx];
                    const arr = samplesByN.get(n);
                    const zs = new Array(B);
                    
                    for (let b = 0; b < B; b++) {
                        const Fn = ecdf(arr[b], x);
                        const z = Math.sqrt(n) * (Fn - Fx) / Math.sqrt(varx);
                        zs[b] = isFinite(z) ? z : 0;
                    }

                    const hist = new Array(binsN).fill(0);
                    const bw = (zMax - zMin) / binsN;
                    let count = 0;
                    
                    for (const z of zs) {
                        if (z >= zMin && z < zMax) {
                            const k = Math.floor((z - zMin) / bw);
                            hist[k]++;
                            count++;
                        }
                    }
                    
                    const dens = hist.map(c => c / (count * bw));
                    const dMax = Math.max(...dens, 1e-6);
                    panelMax = Math.max(panelMax, dMax, 0.42);
                    
                    series.push({ n, bins: dens, zCenters, zValues: zs });
                }

                const gx = pad + (distIdx % cols) * (panelW + pad);
                const gy = pad + Math.floor(distIdx / cols) * (panelH + pad);
                
                const panelData = { series, dMax: panelMax };
                const distName = dist.charAt(0).toUpperCase() + dist.slice(1);
                
                drawPanel(
                    gx, gy, panelW, panelH, 
                    panelData,
                    `${distName} Distribution`,
                    `Median: x=${x.toFixed(2)}, F(x)=${Fx.toFixed(3)}`
                );
            }

            loading.style.display = 'none';
        }

        // Export data to CSV
        function exportData() {
            if (!currentData) {
                alert('Please run a simulation first');
                return;
            }

            let csv = 'Panel,x,F(x),n,Mean,Variance,KS_Statistic\n';
            
            currentData.allPanelData.forEach((panelData, panelIdx) => {
                if (!panelData.bounds || panelData.bounds.length === 0) return;
                
                const bound = panelData.bounds[0];
                const xMatch = bound.title.match(/x = ([\d.-]+)/);
                const fxMatch = bound.subtitle.match(/F\(x\) = ([\d.]+)/);
                const x = xMatch ? xMatch[1] : '';
                const fx = fxMatch ? fxMatch[1] : '';
                
                const stats = calculateStats(panelData);
                stats.forEach(stat => {
                    csv += `${panelIdx + 1},${x},${fx},${stat.n},${stat.mean},${stat.variance},${stat.ks}\n`;
                });
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `ecdf_clt_data_${new Date().toISOString().slice(0, 10)}.csv`;
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Event listeners
        document.getElementById('run').addEventListener('click', () => {
            comparisonMode = false;
            run();
        });
        
        document.getElementById('compare').addEventListener('click', compareDistributions);
        
        document.getElementById('save').addEventListener('click', () => {
            const link = document.createElement('a');
            const mode = comparisonMode ? 'comparison' : 'simulation';
            link.download = `ecdf_clt_${mode}_${new Date().toISOString().slice(0, 10)}.png`;
            link.href = cv.toDataURL('image/png');
            link.click();
        });

        document.getElementById('exportData').addEventListener('click', exportData);

        // Mouse hover tooltip
        cv.addEventListener('mousemove', (e) => {
            if (!currentData) return;
            
            const rect = cv.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const scaleX = cv.width / rect.width;
            const scaleY = cv.height / rect.height;
            const canvasX = x * scaleX;
            const canvasY = y * scaleY;
            
            let found = false;
            currentData.allPanelData.forEach(panelData => {
                if (!panelData.bounds) return;
                panelData.bounds.forEach(bound => {
                    if (canvasX >= bound.x && canvasX <= bound.x + bound.w &&
                        canvasY >= bound.y && canvasY <= bound.y + bound.h) {
                        tooltip.style.left = `${e.clientX + 10}px`;
                        tooltip.style.top = `${e.clientY + 10}px`;
                        tooltip.style.display = 'block';
                        
                        const stats = calculateStats(bound.data);
                        tooltip.innerHTML = `
                            <div style="font-weight: bold; margin-bottom: 5px;">${bound.title}</div>
                            <div style="color: #60a5fa; margin-bottom: 5px;">${bound.subtitle}</div>
                            ${stats.map(s => `
                                <div style="margin: 2px 0;">
                                    n=${s.n}: Î¼=${s.mean}, ÏƒÂ²=${s.variance}
                                </div>
                            `).join('')}
                        `;
                        found = true;
                    }
                });
            });
            
            if (!found) {
                tooltip.style.display = 'none';
            }
        });

        cv.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
        });

        // Initial run
        run();
    </script>
</body>
</html>