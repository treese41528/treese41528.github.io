<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Distribution Sampler & ECDF Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.6/jstat.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 25px;
            padding: 40px;
            backdrop-filter: blur(10px);
            box-shadow: 0 25px 45px rgba(0, 0, 0, 0.2);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.8em;
            background: linear-gradient(45deg, #fff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .description {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.1em;
            opacity: 0.9;
            line-height: 1.6;
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 150px;
        }

        label {
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.9;
        }

        select, input[type="number"] {
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
        }

        select:hover, input[type="number"]:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.5);
        }

        select option {
            background: #764ba2;
            color: white;
        }

        select optgroup {
            background: #5a3a7e;
            color: white;
            font-weight: bold;
        }

        .button-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }

        button:active::before {
            width: 300px;
            height: 300px;
        }

        #generateBtn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        #generateBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        #chart-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
        }

        #chartCanvas {
            width: 100%;
            background: white;
            border-radius: 10px;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            font-size: 0.9em;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 30px;
            height: 3px;
            border-radius: 2px;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: #ffd700;
        }

        .info-box p {
            line-height: 1.8;
            opacity: 0.9;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #ffd700;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }
            
            .control-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-group {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Distribution Sampler & ECDF Visualizer</h1>
        
        <p class="description">
            Generate random samples from various distributions and visualize the empirical cumulative distribution function (ECDF) 
            against the true CDF. See how confidence bands capture uncertainty in the empirical estimate.
        </p>

        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label>Distribution</label>
                    <select id="distribution">
                        <optgroup label="Continuous">
                            <option value="normal">Normal (Gaussian)</option>
                            <option value="uniform">Uniform</option>
                            <option value="exponential">Exponential</option>
                            <option value="gamma">Gamma</option>
                            <option value="beta">Beta</option>
                            <option value="cauchy">Cauchy</option>
                            <option value="logistic">Logistic</option>
                            <option value="lognormal">Log-Normal</option>
                            <option value="weibull">Weibull</option>
                            <option value="pareto">Pareto</option>
                        </optgroup>
                        <optgroup label="Discrete">
                            <option value="binomial">Binomial</option>
                            <option value="poisson">Poisson</option>
                            <option value="geometric">Geometric</option>
                            <option value="negativebinomial">Negative Binomial</option>
                        </optgroup>
                    </select>
                </div>

                <div class="control-group">
                    <label>Sample Size (n)</label>
                    <input type="number" id="sampleSize" value="100" min="10" max="5000" step="10">
                </div>

                <div class="control-group" id="param1Group">
                    <label id="param1Label">Mean (μ)</label>
                    <input type="number" id="param1" value="0" step="0.1">
                </div>

                <div class="control-group" id="param2Group">
                    <label id="param2Label">Std Dev (σ)</label>
                    <input type="number" id="param2" value="1" step="0.1">
                </div>

                <div class="control-group">
                    <label>Confidence Level</label>
                    <select id="confidence">
                        <option value="0.90">90%</option>
                        <option value="0.95" selected>95%</option>
                        <option value="0.99">99%</option>
                    </select>
                </div>
            </div>

            <div class="control-row">
                <div class="checkbox-group">
                    <input type="checkbox" id="showPointwise">
                    <label for="showPointwise">Pointwise Confidence Bands</label>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="showUniform">
                    <label for="showUniform">Uniform Confidence Bands (DKW)</label>
                </div>
            </div>

            <div class="button-row">
                <button id="generateBtn">Generate New Sample</button>
            </div>
        </div>

        <div id="chart-container">
            <canvas id="chartCanvas" width="1200" height="500"></canvas>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #2563eb;"></div>
                    <span>True CDF</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #dc2626;"></div>
                    <span>Empirical CDF</span>
                </div>
                <div class="legend-item" id="pointwiseLegend" style="display: none;">
                    <div class="legend-color" style="background: #f59e0b; border-style: dashed;"></div>
                    <span>Pointwise Bands</span>
                </div>
                <div class="legend-item" id="uniformLegend" style="display: none;">
                    <div class="legend-color" style="background: #8b5cf6; border-style: dashed;"></div>
                    <span>Uniform Bands (DKW)</span>
                </div>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="nStat">-</div>
                <div class="stat-label">Sample Size</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="meanStat">-</div>
                <div class="stat-label">Sample Mean</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stdStat">-</div>
                <div class="stat-label">Sample Std Dev</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="ksStat">-</div>
                <div class="stat-label">KS Statistic</div>
            </div>
        </div>

        <div class="info-box">
            <h3>Understanding the Visualization</h3>
            <p>
                <strong>Empirical CDF (Red):</strong> The step function shows the proportion of samples ≤ x. Each jump represents a data point.
                For n samples, F̂ₙ(x) = (1/n) × Σ I(Xᵢ ≤ x)
            </p>
            <p>
                <strong>True CDF (Blue):</strong> The theoretical cumulative distribution function F(x) for the selected distribution.
            </p>
            <p>
                <strong>Pointwise Confidence Bands (Orange):</strong> At each x, these bands have the specified probability of containing the true CDF value.
                <br>
                <em>Formula:</em> F̂ₙ(x) ± z<sub>α/2</sub> × √[F̂ₙ(x)(1 - F̂ₙ(x))/n]
                <br>
                where z<sub>α/2</sub> is the (1 - α/2) quantile of the standard normal distribution
            </p>
            <p>
                <strong>Uniform Confidence Bands (Purple):</strong> The Dvoretzky-Kiefer-Wolfowitz (DKW) inequality guarantees these bands contain the entire true CDF with the specified probability.
                <br>
                <em>Formula:</em> F̂ₙ(x) ± ε, where ε = √[ln(2/α)/(2n)]
                <br>
                This ensures P(sup<sub>x</sub> |F̂ₙ(x) - F(x)| > ε) ≤ α
            </p>
            <p>
                <strong>KS Statistic:</strong> Dₙ = sup<sub>x</sub> |F̂ₙ(x) - F(x)|
                <br>
                The maximum vertical distance between the empirical and true CDFs across all x values.
            </p>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');

        // Cached CDF data
        let cachedCDF = null;
        let cachedDistribution = null;
        let cachedParam1 = null;
        let cachedParam2 = null;

        // Current samples
        let currentSamples = [];

        // Custom sampling for negative binomial using Poisson-Gamma mixture
        function sampleNegativeBinomial(r, p) {
            // NegBin(r, p): number of failures before r successes
            // This follows from NB ~ Poisson(Lambda) where Lambda ~ Gamma(r, (1-p)/p)
            const shape = r;
            const scale = (1 - p) / p;
            const lambda = jStat.gamma.sample(shape, scale);
            return Math.round(jStat.poisson.sample(lambda));
        }

        // Fallback functions for Pareto distribution (Type I)
        function paretoSample(alpha, xm) {
            // Pareto Type I: x >= xm, F(x) = 1 - (xm/x)^alpha
            return xm / Math.pow(Math.random(), 1 / alpha);
        }
        
        function paretoCDF(x, alpha, xm) {
            // Pareto Type I CDF
            return x < xm ? 0 : 1 - Math.pow(xm / x, alpha);
        }
        
        function paretoInv(p, alpha, xm) {
            return xm / Math.pow(1 - p, 1 / alpha);
        }
        
        // Helper to check if jStat.pareto exists
        function hasJStatPareto() {
            return typeof jStat.pareto !== 'undefined' && 
                   typeof jStat.pareto.sample === 'function' &&
                   typeof jStat.pareto.cdf === 'function';
        }

        // Generate samples using jStat where available
        function generateSamples(dist, n, param1, param2) {
            const samples = [];
            
            for (let i = 0; i < n; i++) {
                switch(dist) {
                    case 'normal':
                        samples.push(jStat.normal.sample(param1, param2));
                        break;
                    
                    case 'uniform':
                        samples.push(jStat.uniform.sample(param1, param2));
                        break;
                    
                    case 'exponential':
                        // Generate using inverse transform: X = -ln(U)/λ for rate λ
                        samples.push(-Math.log(Math.random()) / param1);
                        break;
                    
                    case 'gamma':
                        samples.push(jStat.gamma.sample(param1, param2));
                        break;
                    
                    case 'beta':
                        samples.push(jStat.beta.sample(param1, param2));
                        break;
                    
                    case 'cauchy':
                        // Cauchy using inverse transform method
                        samples.push(param1 + param2 * Math.tan(Math.PI * (Math.random() - 0.5)));
                        break;
                    
                    case 'logistic': {
                        // Logistic using inverse transform
                        const u = Math.random();
                        samples.push(param1 + param2 * Math.log(u / (1 - u)));
                        break;
                    }
                    
                    case 'lognormal':
                        samples.push(jStat.lognormal.sample(param1, param2));
                        break;
                    
                    case 'weibull':
                        samples.push(jStat.weibull.sample(param1, param2));
                        break;
                    
                    case 'pareto':
                        // Pareto Type I: shape α, scale xm (minimum)
                        // Use jStat if available, otherwise use fallback
                        samples.push(hasJStatPareto()
                            ? jStat.pareto.sample(param1, param2)
                            : paretoSample(param1, param2));
                        break;
                    
                    case 'binomial': {
                        let successes = 0;
                        const trials = Math.round(param1);
                        for (let j = 0; j < trials; j++) {
                            if (Math.random() < param2) successes++;
                        }
                        samples.push(successes);
                        break;
                    }
                    
                    case 'poisson':
                        samples.push(jStat.poisson.sample(param1));
                        break;
                    
                    case 'geometric':
                        // Geom1: trials until first success (including the success)
                        // Support: {1, 2, 3, ...}, P(X=1) = p, mean = 1/p
                        const u = Math.random();
                        // Protect against log(0)
                        if (u === 0) {
                            samples.push(1);
                        } else {
                            samples.push(Math.floor(Math.log(u) / Math.log(1 - param1)) + 1);
                        }
                        break;
                    
                    case 'negativebinomial':
                        samples.push(sampleNegativeBinomial(Math.round(param1), param2));
                        break;
                    
                    default:
                        samples.push(0);
                        break;
                }
            }
            
            return samples.sort((a, b) => a - b);
        }

        // Calculate true CDF using jStat where available
        // CRITICAL: Verify parameterizations match between sampler and CDF
        function trueCDF(x, dist, param1, param2) {
            switch(dist) {
                case 'normal':
                    return jStat.normal.cdf(x, param1, param2);
                
                case 'uniform':
                    return jStat.uniform.cdf(x, param1, param2);
                
                case 'exponential':
                    // Use our own exponential CDF: F(x) = 1 - exp(-λx) for rate λ
                    if (x < 0) return 0;
                    return 1 - Math.exp(-param1 * x);
                
                case 'gamma':
                    // jStat.gamma uses (shape, scale) parameterization
                    return jStat.gamma.cdf(x, param1, param2);
                
                case 'beta':
                    // Standard beta on [0,1]
                    if (x <= 0) return 0;
                    if (x >= 1) return 1;
                    return jStat.beta.cdf(x, param1, param2);
                
                case 'cauchy':
                    // Cauchy CDF
                    return 0.5 + Math.atan((x - param1) / param2) / Math.PI;
                
                case 'logistic':
                    // Logistic CDF
                    return 1 / (1 + Math.exp(-(x - param1) / param2));
                
                case 'lognormal':
                    if (x <= 0) return 0;
                    return jStat.lognormal.cdf(x, param1, param2);
                
                case 'weibull':
                    // jStat.weibull uses (scale, shape) parameterization
                    if (x <= 0) return 0;
                    return jStat.weibull.cdf(x, param1, param2);
                
                case 'pareto':
                    // Pareto Type I: F(x) = 1 - (xm/x)^α for x >= xm
                    // Use jStat if available, otherwise use fallback
                    return hasJStatPareto()
                        ? jStat.pareto.cdf(x, param1, param2)
                        : paretoCDF(x, param1, param2);
                
                case 'binomial':
                    if (x < 0) return 0;
                    if (x >= param1) return 1;
                    return jStat.binomial.cdf(Math.floor(x), Math.round(param1), param2);
                
                case 'poisson':
                    if (x < 0) return 0;
                    return jStat.poisson.cdf(Math.floor(x), param1);
                
                case 'geometric':
                    // Geom1: trials until first success, support {1, 2, 3, ...}
                    // P(X <= x) = 1 - (1-p)^floor(x) for x >= 1
                    if (x < 1) return 0;
                    return 1 - Math.pow(1 - param1, Math.floor(x));
                
                case 'negativebinomial': {
                    // NegBin: failures before r successes, support {0,1,2,...}
                    // Need to check what jStat.negbin actually computes
                    if (x < 0) return 0;
                    const r = Math.round(param1);
                    const p = param2;
                    const k = Math.floor(x);
                    
                    // jStat.negbin might use different parameterization
                    // Let's use the identity P(K ≤ k) = I_p(r, k+1) directly
                    return jStat.beta.cdf(p, r, k + 1);
                }
                
                default:
                    return 0;
            }
        }

        // Calculate empirical CDF
        function empiricalCDF(samples, x) {
            let count = 0;
            for (let i = 0; i < samples.length; i++) {
                if (samples[i] <= x) count++;
                else break;
            }
            return count / samples.length;
        }

        // Generate new samples
        function generateNewSamples() {
            const dist = document.getElementById('distribution').value;
            const n = parseInt(document.getElementById('sampleSize').value);
            const param1 = parseFloat(document.getElementById('param1').value);
            const param2 = parseFloat(document.getElementById('param2').value);
            
            currentSamples = generateSamples(dist, n, param1, param2);
            
            if (cachedDistribution !== dist || cachedParam1 !== param1 || cachedParam2 !== param2) {
                cachedCDF = null;
            }
        }

        // Draw the chart
        function drawChart() {
            const dist = document.getElementById('distribution').value;
            const n = parseInt(document.getElementById('sampleSize').value);
            const param1 = parseFloat(document.getElementById('param1').value);
            const param2 = parseFloat(document.getElementById('param2').value);
            const confidence = parseFloat(document.getElementById('confidence').value);
            const showPointwise = document.getElementById('showPointwise').checked;
            const showUniform = document.getElementById('showUniform').checked;
            
            const samples = currentSamples;

            // Determine plot range
            let minX, maxX;
            switch(dist) {
                case 'normal':
                    minX = param1 - 4 * param2;
                    maxX = param1 + 4 * param2;
                    break;
                case 'cauchy':
                    // Use quantiles for Cauchy to avoid extreme ranges
                    minX = param1 + param2 * Math.tan(Math.PI * (0.01 - 0.5));
                    maxX = param1 + param2 * Math.tan(Math.PI * (0.99 - 0.5));
                    break;
                case 'logistic':
                    minX = param1 - 4 * param2;
                    maxX = param1 + 4 * param2;
                    break;
                case 'uniform':
                    const range = param2 - param1;
                    minX = param1 - 0.2 * range;
                    maxX = param2 + 0.2 * range;
                    break;
                case 'exponential':
                    minX = 0;  // Start at 0 for exponential
                    maxX = 5 / param1;
                    if (samples.length > 0) {
                        maxX = Math.max(samples[samples.length - 1] * 1.2, 5 / param1);
                    }
                    break;
                case 'gamma':
                case 'weibull':
                    minX = 0;  // Start at 0 for these distributions
                    maxX = jStat.gamma.inv(0.99, param1, param2) * 1.2;
                    if (samples.length > 0) {
                        maxX = Math.max(samples[samples.length - 1] * 1.2, maxX);
                    }
                    break;
                case 'lognormal':
                    minX = 0;  // Start at 0 for lognormal
                    maxX = jStat.lognormal.inv(0.99, param1, param2) * 1.2;
                    if (samples.length > 0) {
                        maxX = Math.max(samples[samples.length - 1] * 1.2, maxX);
                    }
                    break;
                case 'beta':
                    minX = -0.1;
                    maxX = 1.1;
                    break;
                case 'pareto':
                    minX = param2 - 0.1 * param2;  // Start just below xm
                    // Use fallback if jStat.pareto not available
                    maxX = (hasJStatPareto() && jStat.pareto.inv
                        ? jStat.pareto.inv(0.95, param1, param2) 
                        : paretoInv(0.95, param1, param2)) * 1.2;
                    if (samples.length > 0) {
                        maxX = Math.max(samples[samples.length - 1] * 1.2, maxX);
                    }
                    break;
                case 'binomial':
                    minX = -1;
                    maxX = param1 + 1;
                    break;
                case 'poisson':
                    minX = -1;
                    maxX = Math.max(15, param1 * 3);
                    if (samples.length > 0) {
                        maxX = Math.max(15, samples[samples.length - 1] + 2);
                    }
                    break;
                case 'geometric':
                case 'negativebinomial':
                    minX = -1;
                    maxX = 20;
                    if (samples.length > 0) {
                        maxX = Math.max(20, samples[samples.length - 1] + 2);
                    }
                    break;
                default:
                    minX = -1;
                    maxX = 10;
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Set up dimensions
            const padding = 60;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + height);
            ctx.lineTo(padding + width, padding + height);
            ctx.stroke();

            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = padding + height * (1 - i / 10);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + width, y);
                ctx.stroke();
            }

            // Draw true CDF
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 4;
            ctx.beginPath();
            
            // Check if distribution is discrete
            const isDiscrete = ['binomial', 'poisson', 'geometric', 'negativebinomial'].includes(dist);
            
            if (isDiscrete) {
                // For discrete distributions, draw step function
                const intMin = Math.floor(minX);
                const intMax = Math.ceil(maxX);
                
                // Start from the left edge
                let prevY = intMin > 0 ? trueCDF(intMin - 1, dist, param1, param2) : 0;
                ctx.moveTo(padding, padding + height * (1 - prevY));
                
                for (let i = intMin; i <= intMax; i++) {
                    const x = i;
                    const px = padding + width * ((x - minX) / (maxX - minX));
                    
                    // Draw horizontal line to just before the jump
                    ctx.lineTo(px, padding + height * (1 - prevY));
                    
                    // Draw vertical jump
                    const y = trueCDF(x, dist, param1, param2);
                    if (isFinite(y)) {
                        ctx.lineTo(px, padding + height * (1 - y));
                        prevY = y;
                    }
                }
                
                // Extend to right edge
                ctx.lineTo(padding + width, padding + height * (1 - prevY));
                
            } else {
                // For continuous distributions, use smooth curve
                for (let i = 0; i <= 500; i++) {
                    const x = minX + (maxX - minX) * i / 500;
                    const y = trueCDF(x, dist, param1, param2);
                    if (isFinite(y)) {
                        const px = padding + width * i / 500;
                        const py = padding + height * (1 - y);
                        
                        if (i === 0) {
                            ctx.moveTo(px, py);
                        } else {
                            ctx.lineTo(px, py);
                        }
                    }
                }
            }
            
            ctx.stroke();

            // Draw ECDF and statistics if samples exist
            if (samples.length > 0) {
                const alpha = 1 - confidence;
                const zAlpha = jStat.normal.inv(1 - alpha / 2, 0, 1);
                const epsilon = Math.sqrt(Math.log(2 / alpha) / (2 * n));

                // Draw empirical CDF
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                // Group samples by value
                const uniqueValues = [];
                const cdfValues = [];
                let currentValue = samples[0];
                let count = 0;
                
                for (let i = 0; i < samples.length; i++) {
                    if (samples[i] === currentValue) {
                        count++;
                    } else {
                        uniqueValues.push(currentValue);
                        cdfValues.push(count / n);
                        currentValue = samples[i];
                        count = 1;
                    }
                }
                uniqueValues.push(currentValue);
                cdfValues.push(count / n);
                
                for (let i = 1; i < cdfValues.length; i++) {
                    cdfValues[i] += cdfValues[i - 1];
                }
                
                const firstX = padding + width * (uniqueValues[0] - minX) / (maxX - minX);
                if (firstX > padding) {
                    ctx.moveTo(padding, padding + height);
                    ctx.lineTo(firstX, padding + height);
                }
                
                let lastCDF = 0;
                for (let i = 0; i < uniqueValues.length; i++) {
                    const px = padding + width * (uniqueValues[i] - minX) / (maxX - minX);
                    const pyBefore = padding + height * (1 - lastCDF);
                    const pyAfter = padding + height * (1 - cdfValues[i]);
                    
                    ctx.lineTo(px, pyBefore);
                    ctx.lineTo(px, pyAfter);
                    
                    if (i < uniqueValues.length - 1) {
                        const nextX = padding + width * (uniqueValues[i + 1] - minX) / (maxX - minX);
                        ctx.lineTo(nextX, pyAfter);
                    } else if (px < padding + width) {
                        ctx.lineTo(padding + width, pyAfter);
                    }
                    
                    lastCDF = cdfValues[i];
                }
                ctx.stroke();

                // Draw confidence bands
                if (showPointwise || showUniform) {
                    const numPoints = 200;
                    
                    if (showPointwise) {
                        ctx.strokeStyle = '#f59e0b';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 5]);
                        
                        for (let band of ['lower', 'upper']) {
                            ctx.beginPath();
                            for (let i = 0; i <= numPoints; i++) {
                                const x = minX + (maxX - minX) * i / numPoints;
                                const ecdf = empiricalCDF(samples, x);
                                const se = Math.sqrt(ecdf * (1 - ecdf) / n);
                                const y = band === 'lower' ? 
                                    Math.max(0, ecdf - zAlpha * se) : 
                                    Math.min(1, ecdf + zAlpha * se);
                                const px = padding + width * i / numPoints;
                                const py = padding + height * (1 - y);
                                
                                if (i === 0) ctx.moveTo(px, py);
                                else ctx.lineTo(px, py);
                            }
                            ctx.stroke();
                        }
                    }
                    
                    if (showUniform) {
                        ctx.strokeStyle = '#8b5cf6';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([3, 3]);
                        
                        for (let band of ['lower', 'upper']) {
                            ctx.beginPath();
                            for (let i = 0; i <= numPoints; i++) {
                                const x = minX + (maxX - minX) * i / numPoints;
                                const ecdf = empiricalCDF(samples, x);
                                const y = band === 'lower' ? 
                                    Math.max(0, ecdf - epsilon) : 
                                    Math.min(1, ecdf + epsilon);
                                const px = padding + width * i / numPoints;
                                const py = padding + height * (1 - y);
                                
                                if (i === 0) ctx.moveTo(px, py);
                                else ctx.lineTo(px, py);
                            }
                            ctx.stroke();
                        }
                    }
                    
                    ctx.setLineDash([]);
                }

                // Calculate statistics
                const mean = jStat.mean(samples);
                const std = jStat.stdev(samples, true);
                
                // Calculate theoretical mean for comparison
                let theoreticalMean = 'N/A';
                let theoreticalStd = 'N/A';
                switch(dist) {
                    case 'normal':
                        theoreticalMean = param1.toFixed(3);
                        theoreticalStd = param2.toFixed(3);
                        break;
                    case 'uniform':
                        theoreticalMean = ((param1 + param2) / 2).toFixed(3);
                        theoreticalStd = (Math.sqrt((param2 - param1) * (param2 - param1) / 12)).toFixed(3);
                        break;
                    case 'exponential':
                        // Rate parameterization: mean = 1/λ
                        theoreticalMean = (1 / param1).toFixed(3);
                        theoreticalStd = (1 / param1).toFixed(3);
                        break;
                    case 'gamma':
                        // Shape α, scale β: mean = α*β
                        theoreticalMean = (param1 * param2).toFixed(3);
                        theoreticalStd = (Math.sqrt(param1) * param2).toFixed(3);
                        break;
                    case 'beta':
                        // Mean = α/(α+β)
                        theoreticalMean = (param1 / (param1 + param2)).toFixed(3);
                        const betaVar = (param1 * param2) / ((param1 + param2) * (param1 + param2) * (param1 + param2 + 1));
                        theoreticalStd = Math.sqrt(betaVar).toFixed(3);
                        break;
                    case 'lognormal':
                        // Mean = exp(μ + σ²/2)
                        theoreticalMean = Math.exp(param1 + param2 * param2 / 2).toFixed(3);
                        const lnVar = (Math.exp(param2 * param2) - 1) * Math.exp(2 * param1 + param2 * param2);
                        theoreticalStd = Math.sqrt(lnVar).toFixed(3);
                        break;
                    case 'pareto':
                        // Mean exists only for α > 1
                        if (param1 > 1) {
                            theoreticalMean = (param1 * param2 / (param1 - 1)).toFixed(3);
                        } else {
                            theoreticalMean = '∞';
                        }
                        // Variance exists only for α > 2
                        if (param1 > 2) {
                            const paretoVar = (param2 * param2 * param1) / ((param1 - 1) * (param1 - 1) * (param1 - 2));
                            theoreticalStd = Math.sqrt(paretoVar).toFixed(3);
                        } else {
                            theoreticalStd = '∞';
                        }
                        break;
                    case 'poisson':
                        theoreticalMean = param1.toFixed(3);
                        theoreticalStd = Math.sqrt(param1).toFixed(3);
                        break;
                    case 'geometric':
                        // Geom1: mean = 1/p
                        theoreticalMean = (1 / param1).toFixed(3);
                        theoreticalStd = Math.sqrt((1 - param1) / (param1 * param1)).toFixed(3);
                        break;
                    case 'negativebinomial':
                        // Mean = r(1-p)/p, P(K=0) = p^r
                        theoreticalMean = (param1 * (1 - param2) / param2).toFixed(3);
                        theoreticalStd = Math.sqrt(param1 * (1 - param2) / (param2 * param2)).toFixed(3);
                        // Add diagnostic check
                        const nbCDF0 = trueCDF(0, 'negativebinomial', param1, param2);
                        const expectedCDF0 = Math.pow(param2, param1);
                        if (Math.abs(nbCDF0 - expectedCDF0) > 0.001) {
                            console.warn(`NegBin CDF mismatch at 0: got ${nbCDF0}, expected ${expectedCDF0}`);
                        }
                        break;
                    case 'binomial':
                        theoreticalMean = (param1 * param2).toFixed(3);
                        theoreticalStd = Math.sqrt(param1 * param2 * (1 - param2)).toFixed(3);
                        break;
                }
                
                // KS statistic - proper calculation for both continuous and discrete
                let ksStatistic = 0;
                for (let i = 0; i < samples.length; i++) {
                    const x = samples[i];
                    const cdfVal = trueCDF(x, dist, param1, param2);
                    if (isFinite(cdfVal)) {
                        // Check both sides of the ECDF step
                        const d1 = Math.abs(cdfVal - i / n);       // left of the jump
                        const d2 = Math.abs((i + 1) / n - cdfVal); // right of the jump
                        ksStatistic = Math.max(ksStatistic, d1, d2);
                    }
                }

                document.getElementById('nStat').textContent = n;
                document.getElementById('meanStat').innerHTML = `${mean.toFixed(3)}<br><small style="opacity: 0.7">(Theory: ${theoreticalMean})</small>`;
                document.getElementById('stdStat').innerHTML = `${std.toFixed(3)}<br><small style="opacity: 0.7">(Theory: ${theoreticalStd})</small>`;
                document.getElementById('ksStat').textContent = ksStatistic.toFixed(4);
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(padding + width/4, padding + height/2 - 30, width/2, 60);
                
                ctx.fillStyle = '#666';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Click "Generate New Sample" to add ECDF', canvas.width / 2, canvas.height / 2);
                
                document.getElementById('nStat').textContent = '-';
                document.getElementById('meanStat').textContent = '-';
                document.getElementById('stdStat').textContent = '-';
                document.getElementById('ksStat').textContent = '-';
            }

            // Axis labels
            ctx.fillStyle = '#333';
            ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('x', padding + width / 2, padding + height + 40);
            
            ctx.save();
            ctx.translate(20, padding + height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Cumulative Probability', 0, 0);
            ctx.restore();

            ctx.textAlign = 'right';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            for (let i = 0; i <= 10; i++) {
                const y = padding + height * (1 - i / 10);
                ctx.fillText((i / 10).toFixed(1), padding - 10, y + 4);
            }

            document.getElementById('pointwiseLegend').style.display = (showPointwise && samples.length > 0) ? 'flex' : 'none';
            document.getElementById('uniformLegend').style.display = (showUniform && samples.length > 0) ? 'flex' : 'none';
        }

        // Update parameter labels based on distribution
        function updateParameterLabels() {
            const dist = document.getElementById('distribution').value;
            const param1Label = document.getElementById('param1Label');
            const param2Label = document.getElementById('param2Label');
            const param1Input = document.getElementById('param1');
            const param2Input = document.getElementById('param2');
            const param1Group = document.getElementById('param1Group');
            const param2Group = document.getElementById('param2Group');
            
            // Reset min/max/step
            param1Input.removeAttribute('max');
            param2Input.removeAttribute('max');
            param1Input.min = '';
            param2Input.min = '';
            param1Input.step = '0.1';
            param2Input.step = '0.1';
            
            switch(dist) {
                case 'normal':
                    param1Label.textContent = 'Mean (μ)';
                    param2Label.textContent = 'Std Dev (σ)';
                    param1Input.value = 0;
                    param2Input.value = 1;
                    param2Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'uniform':
                    param1Label.textContent = 'Min (a)';
                    param2Label.textContent = 'Max (b)';
                    param1Input.value = 0;
                    param2Input.value = 1;
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'exponential':
                    param1Label.textContent = 'Rate (λ)';
                    param1Input.value = 1;
                    param1Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'none';
                    break;
                    
                case 'gamma':
                    param1Label.textContent = 'Shape (α)';
                    param2Label.textContent = 'Scale (β)';
                    param1Input.value = 2;
                    param2Input.value = 1;
                    param1Input.min = '0.01';
                    param2Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'beta':
                    param1Label.textContent = 'Alpha (α)';
                    param2Label.textContent = 'Beta (β)';
                    param1Input.value = 2;
                    param2Input.value = 5;
                    param1Input.min = '0.1';
                    param2Input.min = '0.1';
                    param1Input.step = '0.5';
                    param2Input.step = '0.5';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'cauchy':
                    param1Label.textContent = 'Location (x₀)';
                    param2Label.textContent = 'Scale (γ)';
                    param1Input.value = 0;
                    param2Input.value = 1;
                    param1Input.min = '';
                    param2Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'logistic':
                    param1Label.textContent = 'Location (μ)';
                    param2Label.textContent = 'Scale (s)';
                    param1Input.value = 0;
                    param2Input.value = 1;
                    param2Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'lognormal':
                    param1Label.textContent = 'Log Mean (μ)';
                    param2Label.textContent = 'Log Std (σ)';
                    param1Input.value = 0;
                    param2Input.value = 0.5;
                    param2Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'weibull':
                    param1Label.textContent = 'Scale (λ)';
                    param2Label.textContent = 'Shape (k)';
                    param1Input.value = 1;
                    param2Input.value = 2;
                    param1Input.min = '0.01';
                    param2Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'pareto':
                    param1Label.textContent = 'Shape (α)';
                    param2Label.textContent = 'Scale (xₘ)';
                    param1Input.value = 3;
                    param2Input.value = 1;
                    param1Input.min = '0.1';
                    param2Input.min = '0.1';
                    param1Input.step = '0.5';
                    param2Input.step = '0.1';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'binomial':
                    param1Label.textContent = 'Trials (n)';
                    param2Label.textContent = 'Probability (p)';
                    param1Input.value = 20;
                    param2Input.value = 0.3;
                    param1Input.step = '1';
                    param2Input.step = '0.05';
                    param1Input.min = '1';
                    param2Input.min = '0';
                    param2Input.max = '1';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'poisson':
                    param1Label.textContent = 'Rate (λ)';
                    param1Input.value = 3;
                    param1Input.step = '0.5';
                    param1Input.min = '0.1';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'none';
                    break;
                    
                case 'geometric':
                    param1Label.textContent = 'Probability (p)';
                    param1Input.value = 0.3;
                    param1Input.step = '0.05';
                    param1Input.min = '0.01';
                    param1Input.max = '1';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'none';
                    break;
                    
                case 'negativebinomial':
                    param1Label.textContent = 'Successes (r)';
                    param2Label.textContent = 'Probability (p)';
                    param1Input.value = 5;
                    param2Input.value = 0.4;
                    param1Input.step = '1';
                    param2Input.step = '0.05';
                    param1Input.min = '1';
                    param2Input.min = '0.01';
                    param2Input.max = '0.99';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
            }
        }

        // Event listeners
        document.getElementById('distribution').addEventListener('change', () => {
            updateParameterLabels();
            currentSamples = [];
            cachedCDF = null;
            drawChart();
        });

        document.getElementById('generateBtn').addEventListener('click', () => {
            generateNewSamples();
            drawChart();
        });
        
        document.getElementById('showPointwise').addEventListener('change', () => {
            if (currentSamples.length > 0) drawChart();
        });
        
        document.getElementById('showUniform').addEventListener('change', () => {
            if (currentSamples.length > 0) drawChart();
        });
        
        document.getElementById('confidence').addEventListener('change', () => {
            if (currentSamples.length > 0) drawChart();
        });
        
        document.getElementById('sampleSize').addEventListener('change', () => {
            currentSamples = [];
            drawChart();
        });
        
        document.getElementById('param1').addEventListener('change', () => {
            currentSamples = [];
            cachedCDF = null;
            drawChart();
        });
        
        document.getElementById('param2').addEventListener('change', () => {
            currentSamples = [];
            cachedCDF = null;
            drawChart();
        });

        // Initial setup
        updateParameterLabels();
        drawChart();
    </script>
</body>
</html>