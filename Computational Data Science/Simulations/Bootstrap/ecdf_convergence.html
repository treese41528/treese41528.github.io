<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLT for ECDF - 3D Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.6/jstat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 15px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #fff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .description {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1em;
            opacity: 0.9;
            line-height: 1.6;
            max-width: 1000px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .key-insights {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid rgba(255, 255, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 20px auto;
            max-width: 1000px;
        }
        
        .key-insights h3 {
            color: #fbbf24;
            margin-bottom: 10px;
        }
        
        .key-insights ul {
            line-height: 1.8;
            margin-left: 20px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 140px;
        }

        label {
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.9;
        }

        select, input[type="number"] {
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 8px;
            font-size: 14px;
        }

        select option {
            background: #1e1b4b;
            color: white;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1em;
            cursor: pointer;
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
            transition: all 0.3s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.6);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .viz-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        #scene-container {
            width: 100%;
            height: 700px;
            max-height: 80vh;  /* Responsive height */
            min-height: 400px;  /* Minimum for usability */
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }
            
            #scene-container {
                height: 500px;
                max-height: 70vh;
            }
            
            .control-group {
                min-width: 100px;
                flex: 1;
            }
            
            .control-row {
                gap: 10px;
            }
            
            .legend {
                font-size: 0.8em;
                gap: 10px;
            }
            
            .theory-box {
                padding: 15px;
                font-size: 0.9em;
            }
        }
        
        /* Small mobile */
        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            
            #scene-container {
                height: 400px;
            }
            
            .controls {
                padding: 15px;
            }
            
            button {
                padding: 10px 20px;
                font-size: 0.9em;
            }
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .legend-color {
            width: 30px;
            height: 15px;
            border-radius: 3px;
        }

        .theory-box {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .theory-box h3 {
            margin-bottom: 10px;
            color: #fbbf24;
        }

        .theory-box p {
            line-height: 1.8;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .formula {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            text-align: center;
        }

        .status {
            text-align: center;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 0.9em;
            opacity: 0.8;
        }

        .controls-hint {
            text-align: center;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.85em;
            opacity: 0.7;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .error-message {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CLT for ECDF Across Multiple Points</h1>
        
        <p class="description">
            At each of 10 different x-values, visualize how ‚àön¬∑(FÃÇ‚Çô(x) - F(x)) / ‚àö[F(x)¬∑(1-F(x))] converges to N(0,1). 
            Each x-position shows 5 overlapping histograms (colored by sample size n) plus the theoretical normal curve in cyan.
        </p>
        
        <div class="key-insights">
            <h3>üéØ What to Look For:</h3>
            <ul>
                <li><strong>Convergence Pattern:</strong> As n increases (red ‚Üí blue), histograms get closer to the cyan normal curve</li>
                <li><strong>Variance Effect:</strong> Middle quantiles (F(x) ‚âà 0.5) have maximum variance, extreme quantiles have less</li>
                <li><strong>Universal Shape:</strong> Despite different distributions, all standardized ECDFs converge to the same N(0,1)</li>
                <li><strong>Sample Size Impact:</strong> Larger n = tighter distribution = better approximation to true CDF</li>
            </ul>
        </div>

        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label>Distribution</label>
                    <select id="distribution">
                        <option value="normal">Normal (Œº=0, œÉ=1)</option>
                        <option value="uniform">Uniform (0, 1)</option>
                        <option value="exponential">Exponential (Œª=1)</option>
                        <option value="beta">Beta (Œ±=2, Œ≤=5)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Simulations per Point</label>
                    <input type="number" id="numSims" value="500" min="100" max="2000" step="100">
                </div>

                <div class="control-group">
                    <label>n‚ÇÅ (Red)</label>
                    <input type="number" id="n1" value="10" min="5" max="100" step="5">
                </div>

                <div class="control-group">
                    <label>n‚ÇÇ (Orange)</label>
                    <input type="number" id="n2" value="25" min="10" max="200" step="5">
                </div>

                <div class="control-group">
                    <label>n‚ÇÉ (Yellow)</label>
                    <input type="number" id="n3" value="50" min="20" max="300" step="10">
                </div>

                <div class="control-group">
                    <label>n‚ÇÑ (Green)</label>
                    <input type="number" id="n4" value="100" min="50" max="500" step="10">
                </div>

                <div class="control-group">
                    <label>n‚ÇÖ (Blue)</label>
                    <input type="number" id="n5" value="500" min="100" max="2000" step="50">
                </div>
            </div>

            <div class="control-row">
                <button id="runBtn">Run Simulation</button>
                <button id="resetCameraBtn">Reset Camera</button>
            </div>
        </div>

        <div class="status" id="status">Initializing 3D scene...</div>
        <div class="error-message" id="errorMsg"></div>

        <div class="controls-hint">
            <strong>Camera Controls:</strong> W/S = Forward/Back | A/D = Left/Right | Q/E = Up/Down | Arrow Keys = Look Around | Mouse Drag = Rotate View | Scroll = Zoom
        </div>

        <div class="viz-container">
            <div id="scene-container"></div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #dc2626;"></div>
                    <span id="legend1">n = 10</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f59e0b;"></div>
                    <span id="legend2">n = 25</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #eab308;"></div>
                    <span id="legend3">n = 50</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #22c55e;"></div>
                    <span id="legend4">n = 100</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #3b82f6;"></div>
                    <span id="legend5">n = 500</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #06b6d4; border: 2px solid #fff;"></div>
                    <span>Standard Normal (Theory)</span>
                </div>
            </div>
        </div>

        <div class="theory-box">
            <h3>Theory: CLT for the Empirical CDF at Multiple Points</h3>
            <p>
                <strong>Pointwise CLT for the ECDF:</strong> For each fixed point x, the standardized empirical CDF converges:
            </p>
            <div class="formula">
                Z‚Çô(x) = ‚àön ¬∑ (FÃÇ‚Çô(x) - F(x)) / ‚àö[F(x)¬∑(1-F(x))] ‚Üí·µà N(0, 1)
            </div>
            <p>
                This visualization samples 10 different x-values across the distribution's support. At each x-value (positioned along the horizontal axis):
            </p>
            <ul style="margin-left: 20px; line-height: 1.8;">
                <li>We run many simulations for each sample size n</li>
                <li>For each simulation, we compute Z‚Çô(x) - the standardized deviation from the true CDF</li>
                <li>The histograms show the empirical distribution of Z‚Çô(x), all centered at 0</li>
                <li>As n increases, the distributions tighten and converge to N(0,1) (cyan curve)</li>
            </ul>
            <p>
                <strong>Key observations:</strong> The variance F(x)¬∑(1-F(x)) is maximized when F(x) = 0.5 (median), 
                so convergence may appear different at different quantiles even though all are standardized to have variance 1.
            </p>
        </div>
    </div>

    <script>
        let scene, camera, renderer;
        let currentMeshes = [];
        let keys = {};
        let moveSpeed = 0.3;
        let lookSpeed = 0.03;
        let yaw = 0;
        let pitch = -0.5;
        let animationId = null;

        function showError(message) {
            const errorDiv = document.getElementById('errorMsg');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            console.error(message);
        }

        function hideError() {
            document.getElementById('errorMsg').style.display = 'none';
        }

        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function initScene() {
            try {
                console.log('Initializing Three.js scene...');
                const container = document.getElementById('scene-container');
                
                if (!container) {
                    showError('Scene container not found');
                    return;
                }

                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                console.log('Scene created');

                // Create camera with responsive FOV
                const aspect = container.clientWidth / container.clientHeight;
                
                // Adjust FOV based on aspect ratio for better mobile viewing
                let fov = 60;
                if (aspect < 1) { // Portrait mode
                    fov = 75;  // Wider FOV for narrow screens
                } else if (aspect < 1.5) { // Square-ish screens
                    fov = 65;
                }
                
                camera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);
                camera.position.set(2, 2, 0);  // Close to origin, up 2, right 2
                console.log('Camera created at:', camera.position, 'FOV:', fov);
                
                // Initialize camera rotation to look at the histograms
                yaw = -Math.PI / 2;  // Looking left along negative X axis
                pitch = -0.1;       // Slight downward angle
                
                updateCameraLookAt();

                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                // Clear container and add renderer
                container.innerHTML = '';
                container.appendChild(renderer.domElement);
                console.log('Renderer created and added to DOM');

                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.7);
                directionalLight1.position.set(10, 10, 10);
                scene.add(directionalLight1);

                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight2.position.set(-10, 5, -10);
                scene.add(directionalLight2);
                console.log('Lights added');

                // Add grid with better styling
                const gridHelper = new THREE.GridHelper(35, 35, 0x444444, 0x222222);
                scene.add(gridHelper);
                
                // Add reference plane at y=0 for better depth perception
                const planeGeometry = new THREE.PlaneGeometry(35, 35);
                const planeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x111111, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = -Math.PI / 2;
                plane.position.y = -0.01;
                scene.add(plane);
                console.log('Grid and reference plane added');

                // Add axes helper for debugging
                const axesHelper = new THREE.AxesHelper(5);
                scene.add(axesHelper);

                // Mouse controls
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                
                renderer.domElement.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });

                renderer.domElement.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - previousMousePosition.x;
                        const deltaY = e.clientY - previousMousePosition.y;
                        
                        yaw -= deltaX * 0.005;
                        pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, pitch - deltaY * 0.005));
                        
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    }
                });

                window.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                window.addEventListener('mouseleave', () => {
                    isDragging = false;
                });

                renderer.domElement.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 2;
                    const forward = new THREE.Vector3(
                        Math.sin(yaw) * Math.cos(pitch),
                        Math.sin(pitch),
                        Math.cos(yaw) * Math.cos(pitch)
                    );
                    
                    const direction = e.deltaY > 0 ? -1 : 1;
                    const newPosition = camera.position.clone();
                    newPosition.add(forward.multiplyScalar(direction * zoomSpeed));
                    
                    // Check zoom boundaries
                    const maxDistance = 50;
                    const minY = -5;
                    const maxY = 40;
                    const distanceFromOrigin = Math.sqrt(newPosition.x * newPosition.x + newPosition.z * newPosition.z);
                    
                    if (distanceFromOrigin <= maxDistance && 
                        newPosition.y >= minY && 
                        newPosition.y <= maxY) {
                        camera.position.copy(newPosition);
                    }
                }, { passive: false });

                // Start animation
                animate();
                
                document.getElementById('status').textContent = 'Scene initialized! Click "Run Simulation" to start';
                console.log('Scene initialization complete');
                
            } catch (error) {
                showError('Error initializing 3D scene: ' + error.message);
                console.error('Full error:', error);
            }
        }

        function updateCameraLookAt() {
            const forward = new THREE.Vector3(
                Math.sin(yaw) * Math.cos(pitch),
                Math.sin(pitch),
                Math.cos(yaw) * Math.cos(pitch)
            );
            const target = new THREE.Vector3(
                camera.position.x + forward.x,
                camera.position.y + forward.y,
                camera.position.z + forward.z
            );
            camera.lookAt(target);
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            
            updateCamera();
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        function updateCamera() {
            const forward = new THREE.Vector3(
                Math.sin(yaw) * Math.cos(pitch),
                Math.sin(pitch),
                Math.cos(yaw) * Math.cos(pitch)
            );
            const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));
            const up = new THREE.Vector3(0, 1, 0);

            // Store potential new position
            const newPosition = camera.position.clone();
            
            if (keys['w']) newPosition.add(forward.clone().multiplyScalar(moveSpeed));
            if (keys['s']) newPosition.add(forward.clone().multiplyScalar(-moveSpeed));
            if (keys['a']) newPosition.add(right.clone().multiplyScalar(moveSpeed));  // Fixed: reversed direction
            if (keys['d']) newPosition.add(right.clone().multiplyScalar(-moveSpeed)); // Fixed: reversed direction
            if (keys['q']) newPosition.add(up.clone().multiplyScalar(moveSpeed));
            if (keys['e']) newPosition.add(up.clone().multiplyScalar(-moveSpeed));

            // Define movement boundaries
            const maxDistance = 50;  // Maximum distance from origin
            const minY = -5;         // Minimum height
            const maxY = 40;         // Maximum height
            
            // Check boundaries
            const distanceFromOrigin = Math.sqrt(newPosition.x * newPosition.x + newPosition.z * newPosition.z);
            
            if (distanceFromOrigin <= maxDistance && 
                newPosition.y >= minY && 
                newPosition.y <= maxY) {
                camera.position.copy(newPosition);
            } else {
                // If outside boundaries, clamp the position
                if (distanceFromOrigin > maxDistance) {
                    const scale = maxDistance / distanceFromOrigin;
                    newPosition.x *= scale;
                    newPosition.z *= scale;
                }
                if (newPosition.y < minY) newPosition.y = minY;
                if (newPosition.y > maxY) newPosition.y = maxY;
                camera.position.copy(newPosition);
            }

            if (keys['arrowleft']) yaw -= lookSpeed;
            if (keys['arrowright']) yaw += lookSpeed;
            if (keys['arrowup']) pitch = Math.min(Math.PI / 2 - 0.1, pitch + lookSpeed);
            if (keys['arrowdown']) pitch = Math.max(-Math.PI / 2 + 0.1, pitch - lookSpeed);

            updateCameraLookAt();
        }

        function resetCamera() {
            camera.position.set(2, 2, 0);  // Close to origin, up 2, right 2
            yaw = -Math.PI / 2;  // Looking left along negative X axis
            pitch = -0.1;       // Slight downward angle
            updateCameraLookAt();
        }

        function sampleDistribution(dist, n) {
            const samples = [];
            for (let i = 0; i < n; i++) {
                switch(dist) {
                    case 'normal':
                        samples.push(jStat.normal.sample(0, 1));
                        break;
                    case 'uniform':
                        samples.push(Math.random());
                        break;
                    case 'exponential':
                        samples.push(-Math.log(Math.random()));
                        break;
                    case 'beta':
                        samples.push(jStat.beta.sample(2, 5));
                        break;
                }
            }
            return samples.sort((a, b) => a - b);
        }

        function trueCDF(x, dist) {
            switch(dist) {
                case 'normal':
                    return jStat.normal.cdf(x, 0, 1);
                case 'uniform':
                    return x < 0 ? 0 : (x > 1 ? 1 : x);
                case 'exponential':
                    return x < 0 ? 0 : 1 - Math.exp(-x);
                case 'beta':
                    return x <= 0 ? 0 : (x >= 1 ? 1 : jStat.beta.cdf(x, 2, 5));
            }
        }

        function empiricalCDF(samples, x) {
            let count = 0;
            for (let sample of samples) {
                if (sample <= x) count++;
                else break;
            }
            return count / samples.length;
        }

        function getEvalPoints(dist) {
            const points = [];
            for (let i = 1; i <= 10; i++) {
                const quantile = i / 11;
                let x;
                switch(dist) {
                    case 'normal':
                        x = jStat.normal.inv(quantile, 0, 1);
                        break;
                    case 'uniform':
                        x = quantile;
                        break;
                    case 'exponential':
                        x = -Math.log(1 - quantile);
                        break;
                    case 'beta':
                        x = jStat.beta.inv(quantile, 2, 5);
                        break;
                }
                points.push(x);
            }
            // Ensure points are sorted in ascending order
            return points.sort((a, b) => a - b);
        }

        async function runSimulation() {
            try {
                hideError();
                document.getElementById('status').textContent = 'Running simulation...';
                document.getElementById('runBtn').disabled = true;
                
                await new Promise(resolve => setTimeout(resolve, 50));

                // Clear existing meshes
                currentMeshes.forEach(mesh => {
                    scene.remove(mesh);
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) mesh.material.dispose();
                });
                currentMeshes = [];

                const dist = document.getElementById('distribution').value;
                const numSims = parseInt(document.getElementById('numSims').value);
                const numBins = 20;
                const opacity = 1.0;  // Full opacity - no transparency

                const evalPoints = getEvalPoints(dist);
                const sampleSizes = [
                    parseInt(document.getElementById('n1').value),
                    parseInt(document.getElementById('n2').value),
                    parseInt(document.getElementById('n3').value),
                    parseInt(document.getElementById('n4').value),
                    parseInt(document.getElementById('n5').value)
                ];
                const colors = [0xdc2626, 0xf59e0b, 0xeab308, 0x22c55e, 0x3b82f6];
                const offsets = [-0.3, -0.15, 0, 0.15, 0.3];
                
                // Update legend
                for (let i = 0; i < 5; i++) {
                    document.getElementById(`legend${i+1}`).textContent = `n = ${sampleSizes[i]}`;
                }
                
                const xSpacing = 3;
                const maxHeight = 0.5;

                for (let ptIdx = 0; ptIdx < evalPoints.length; ptIdx++) {
                    const x = evalPoints[ptIdx];
                    const Fx = trueCDF(x, dist);
                    const variance = Fx * (1 - Fx);
                    
                    if (variance < 0.01) continue;

                    const xPos = (ptIdx - 4.5) * xSpacing;

                    // Process each sample size
                    for (let nIdx = 0; nIdx < sampleSizes.length; nIdx++) {
                        const n = sampleSizes[nIdx];
                        const standardizedValues = [];
                        
                        for (let sim = 0; sim < numSims; sim++) {
                            const samples = sampleDistribution(dist, n);
                            const Fn = empiricalCDF(samples, x);
                            const standardized = Math.sqrt(n) * (Fn - Fx) / Math.sqrt(variance);
                            if (isFinite(standardized)) {
                                standardizedValues.push(standardized);
                            }
                        }

                        const minZ = -3;
                        const maxZ = 3;
                        const binWidth = (maxZ - minZ) / numBins;
                        const histogram = new Array(numBins).fill(0);
                        
                        standardizedValues.forEach(val => {
                            const binIdx = Math.floor((val - minZ) / binWidth);
                            if (binIdx >= 0 && binIdx < numBins) {
                                histogram[binIdx]++;
                            }
                        });

                        const densities = histogram.map(count => count / (standardizedValues.length * binWidth));

                        // Create bars for histogram
                        for (let i = 0; i < numBins; i++) {
                            const density = densities[i];
                            if (density > 0.01) {
                                const zPos = minZ + (i + 0.5) * binWidth;
                                const height = Math.min(density * maxHeight / 0.4, maxHeight * 2);
                                
                                const geometry = new THREE.BoxGeometry(binWidth * 0.8, height, 0.15);
                                const material = new THREE.MeshPhongMaterial({ 
                                    color: colors[nIdx],
                                    transparent: false,  // No transparency
                                    opacity: 1.0,        // Full opacity
                                    side: THREE.DoubleSide
                                });
                                const mesh = new THREE.Mesh(geometry, material);
                                
                                mesh.position.set(xPos + offsets[nIdx], height / 2, zPos);
                                
                                scene.add(mesh);
                                currentMeshes.push(mesh);
                            }
                        }
                    }

                    // Add normal curve with thicker line
                    const normalCurve = [];
                    for (let z = -3; z <= 3; z += 0.05) {
                        const density = jStat.normal.pdf(z, 0, 1);
                        const height = Math.min(density * maxHeight / 0.4, maxHeight * 2);
                        normalCurve.push(new THREE.Vector3(xPos, height, z));
                    }
                    
                    // Create a thicker curve using cylinder segments
                    for (let i = 0; i < normalCurve.length - 1; i++) {
                        const start = normalCurve[i];
                        const end = normalCurve[i + 1];
                        const distance = start.distanceTo(end);
                        
                        const geometry = new THREE.CylinderGeometry(0.03, 0.03, distance, 8);
                        const material = new THREE.MeshBasicMaterial({ color: 0x06b6d4 });
                        const cylinder = new THREE.Mesh(geometry, material);
                        
                        // Position and rotate the cylinder
                        cylinder.position.x = (start.x + end.x) / 2;
                        cylinder.position.y = (start.y + end.y) / 2;
                        cylinder.position.z = (start.z + end.z) / 2;
                        
                        const direction = new THREE.Vector3().subVectors(end, start).normalize();
                        const axis = new THREE.Vector3(0, 1, 0);
                        cylinder.quaternion.setFromUnitVectors(axis, direction);
                        
                        scene.add(cylinder);
                        currentMeshes.push(cylinder);
                    }

                    // Add label with better styling and background
                    const labelCanvas = document.createElement('canvas');
                    labelCanvas.width = 256;
                    labelCanvas.height = 128;
                    const ctx = labelCanvas.getContext('2d');
                    
                    // Add semi-transparent background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, 256, 128);
                    
                    // Add text with better formatting
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 32px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`x = ${x.toFixed(2)}`, 128, 50);
                    
                    ctx.fillStyle = '#88ccff';
                    ctx.font = '28px Arial';
                    ctx.fillText(`F(x) = ${Fx.toFixed(3)}`, 128, 90);
                    
                    const texture = new THREE.CanvasTexture(labelCanvas);
                    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.set(xPos, -1.0, -4.0);
                    sprite.scale.set(2.5, 1.25, 1);
                    scene.add(sprite);
                    currentMeshes.push(sprite);
                    
                    // Add vertical reference line from ground to max height
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(xPos, 0, 0),
                        new THREE.Vector3(xPos, maxHeight * 2.5, 0)
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x333333,
                        transparent: true,
                        opacity: 0.3
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    scene.add(line);
                    currentMeshes.push(line);
                    
                    // Add quantile marker
                    const markerGeometry = new THREE.SphereGeometry(0.1, 16, 16);
                    const markerMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffff00
                    });
                    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.set(xPos, -0.2, 0);
                    scene.add(marker);
                    currentMeshes.push(marker);
                    
                    // Add connecting lines between histogram groups for visual continuity
                    if (ptIdx > 0) {
                        const prevX = (ptIdx - 1 - 4.5) * xSpacing;
                        const connectionGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(prevX, 0, 0),
                            new THREE.Vector3(xPos, 0, 0)
                        ]);
                        const connectionMaterial = new THREE.LineBasicMaterial({ 
                            color: 0x666666,
                            transparent: true,
                            opacity: 0.2
                        });
                        const connectionLine = new THREE.Line(connectionGeometry, connectionMaterial);
                        scene.add(connectionLine);
                        currentMeshes.push(connectionLine);
                    }
                }

                document.getElementById('status').textContent = 'Simulation complete! Use controls to explore the 3D visualization.';
                
            } catch (error) {
                showError('Error running simulation: ' + error.message);
                console.error('Full error:', error);
            } finally {
                document.getElementById('runBtn').disabled = false;
            }
        }

        // Event listeners
        document.getElementById('runBtn').addEventListener('click', runSimulation);
        document.getElementById('resetCameraBtn').addEventListener('click', resetCamera);

        window.addEventListener('resize', () => {
            const container = document.getElementById('scene-container');
            if (camera && renderer && container) {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initScene);
        } else {
            initScene();
        }

        // Check for Three.js availability
        if (typeof THREE === 'undefined') {
            showError('Three.js library failed to load. Please check your internet connection.');
        }
    </script>
</body>
</html>