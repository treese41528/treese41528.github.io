<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generalized Inverse CDF Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background-color: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-weight: bold;
            color: #555;
            font-size: 14px;
        }
        
        select, input[type="range"] {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        canvas {
            border: 1px solid #ddd;
            border-radius: 5px;
            width: 100%;
            max-width: 500px;
            cursor: crosshair;
        }
        
        .canvas-container {
            text-align: center;
        }
        
        .canvas-title {
            font-weight: bold;
            color: #444;
            margin-bottom: 10px;
        }
        
        .info-box {
            background-color: #f0f8ff;
            border: 2px solid #4a90e2;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .info-box h3 {
            margin-top: 0;
            color: #4a90e2;
        }
        
        .value-display {
            font-size: 18px;
            color: #333;
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin-top: 10px;
        }
        
        .formula {
            font-family: 'Courier New', monospace;
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin: 10px 0;
        }
        
        .explanation {
            background-color: #fffbf0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin-top: 20px;
        }
        
        @media (max-width: 768px) {
            .visualization {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Generalized Inverse CDF Visualization</h1>
        <p class="subtitle">Understanding F⁻(u) = inf{x ∈ ℝ : F(x) ≥ u}</p>
        
        <div class="info-box">
            <h3>What is the Generalized Inverse CDF?</h3>
            <p>The generalized inverse CDF (quantile function) finds the smallest x value where the CDF reaches or exceeds a given probability u.</p>
            <div class="formula">F⁻(u) = inf{x : F(x) ≥ u}</div>
            <p>This definition works for ALL distributions: continuous, discrete, or mixed!</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="distType">Distribution Type:</label>
                <select id="distType">
                    <option value="continuous">Continuous (Normal)</option>
                    <option value="discrete">Discrete (Poisson)</option>
                    <option value="mixed">Mixed (Zero-inflated)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="uValue">u value: <span id="uDisplay">0.50</span></label>
                <input type="range" id="uValue" min="0.01" max="0.99" step="0.01" value="0.50">
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="animateToggle"> Animate u from 0 to 1
                </label>
            </div>
        </div>
        
        <div class="visualization">
            <div class="canvas-container">
                <div class="canvas-title">CDF: F(x)</div>
                <canvas id="cdfCanvas" width="500" height="400"></canvas>
            </div>
            
            <div class="canvas-container">
                <div class="canvas-title">Inverse CDF: F⁻(u)</div>
                <canvas id="invCanvas" width="500" height="400"></canvas>
            </div>
        </div>
        
        <div class="value-display">
            <strong>Current values:</strong> u = <span id="uCurrent">0.50</span>, 
            F⁻(u) = <span id="xCurrent">0.00</span>
        </div>
        
        <div class="explanation" id="explanation">
            <h3>How to read this visualization:</h3>
            <ul>
                <li><strong>Left plot (CDF):</strong> Shows F(x) with a horizontal line at height u. The vertical line shows where this intersects or exceeds F(x).</li>
                <li><strong>Right plot (Inverse CDF):</strong> Shows F⁻(u) directly. The current u value is marked with a vertical line.</li>
                <li><strong>For continuous distributions:</strong> F⁻(u) is simply where F(x) = u.</li>
                <li><strong>For discrete distributions:</strong> F⁻(u) finds the smallest x where F(x) ≥ u (notice the jumps!).</li>
                <li><strong>Move the slider</strong> or hover over either plot to see how u and F⁻(u) relate!</li>
            </ul>
        </div>
    </div>

    <script>
        // Get canvas contexts
        const cdfCanvas = document.getElementById('cdfCanvas');
        const invCanvas = document.getElementById('invCanvas');
        const cdfCtx = cdfCanvas.getContext('2d');
        const invCtx = invCanvas.getContext('2d');
        
        // Control elements
        const distTypeSelect = document.getElementById('distType');
        const uSlider = document.getElementById('uValue');
        const uDisplay = document.getElementById('uDisplay');
        const uCurrent = document.getElementById('uCurrent');
        const xCurrent = document.getElementById('xCurrent');
        const animateToggle = document.getElementById('animateToggle');
        
        // Animation variables
        let animationId = null;
        let animationU = 0.01;
        
        // Distribution parameters
        const params = {
            continuous: { mean: 0, std: 1 },
            discrete: { lambda: 3 },
            mixed: { p: 0.3, mean: 2, std: 0.8 }
        };
        
        // Helper functions for distributions
        function normalCDF(x, mean, std) {
            return 0.5 * (1 + erf((x - mean) / (std * Math.sqrt(2))));
        }
        
        function erf(x) {
            // Approximation of error function
            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;
            
            const sign = x >= 0 ? 1 : -1;
            x = Math.abs(x);
            
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            
            return sign * y;
        }
        
        function inverseNormalStandard(p) {
            // Inverse normal CDF using Acklam's approximation
            // Works for 0 < p < 1
            const a1 = -39.6968302866538;
            const a2 = 220.946098424521;
            const a3 = -275.928510446969;
            const a4 = 138.357751867269;
            const a5 = -30.6647980661472;
            const a6 = 2.50662827745924;
            
            const b1 = -54.4760987982241;
            const b2 = 161.585836858041;
            const b3 = -155.698979859887;
            const b4 = 66.8013118877197;
            const b5 = -13.2806815528857;
            
            const c1 = -0.00778489400243029;
            const c2 = -0.322396458041136;
            const c3 = -2.40075827716184;
            const c4 = -2.54973253934373;
            const c5 = 4.37466414146497;
            const c6 = 2.93816398269878;
            
            const d1 = 0.00778469570904146;
            const d2 = 0.32246712907004;
            const d3 = 2.445134137143;
            const d4 = 3.75440866190742;
            
            const p_low = 0.02425;
            const p_high = 1 - p_low;
            
            let q, r;
            
            if (p < p_low) {
                // Lower region
                q = Math.sqrt(-2 * Math.log(p));
                return (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
                       ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
            } else if (p <= p_high) {
                // Central region
                q = p - 0.5;
                r = q * q;
                return (((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q /
                       (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1);
            } else {
                // Upper region
                q = Math.sqrt(-2 * Math.log(1 - p));
                return -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
                        ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
            }
        }
        
        function poissonCDF(k, lambda) {
            let sum = 0;
            for (let i = 0; i <= k; i++) {
                sum += Math.exp(-lambda) * Math.pow(lambda, i) / factorial(i);
            }
            return sum;
        }
        
        function factorial(n) {
            if (n <= 1) return 1;
            return n * factorial(n - 1);
        }
        
        function getCDF(x, type) {
            switch (type) {
                case 'continuous':
                    return normalCDF(x, params.continuous.mean, params.continuous.std);
                case 'discrete':
                    return poissonCDF(Math.floor(x), params.discrete.lambda);
                case 'mixed':
                    if (x < 0) return 0;
                    return params.mixed.p * (x >= 0 ? 1 : 0) + 
                           (1 - params.mixed.p) * normalCDF(x, params.mixed.mean, params.mixed.std);
            }
        }
        
        function getInverseCDF(u, type) {
            switch (type) {
                case 'continuous':
                    // For continuous normal distribution, use proper inverse normal function
                    const zNormal = inverseNormalStandard(u);
                    return params.continuous.mean + params.continuous.std * zNormal;
                    
                case 'discrete':
                    // For discrete, find smallest k where F(k) >= u
                    for (let k = 0; k < 20; k++) {
                        if (poissonCDF(k, params.discrete.lambda) >= u) {
                            return k;
                        }
                    }
                    return 20;
                    
                case 'mixed':
                    // For mixed distribution with jump at 0
                    if (u <= params.mixed.p) return 0;
                    
                    // For u > p, we need to invert the continuous part
                    // Solve: p + (1-p)*Φ((x-μ)/σ) = u
                    // This gives: Φ((x-μ)/σ) = (u-p)/(1-p)
                    const adjustedU = (u - params.mixed.p) / (1 - params.mixed.p);
                    const zMixed = inverseNormalStandard(adjustedU);
                    return params.mixed.mean + params.mixed.std * zMixed;
            }
        }
        
        function drawCDF(u) {
            const type = distTypeSelect.value;
            const width = cdfCanvas.width;
            const height = cdfCanvas.height;
            const margin = 40;
            
            // Clear canvas
            cdfCtx.clearRect(0, 0, width, height);
            
            // Draw axes
            cdfCtx.strokeStyle = '#333';
            cdfCtx.lineWidth = 2;
            cdfCtx.beginPath();
            cdfCtx.moveTo(margin, height - margin);
            cdfCtx.lineTo(width - margin, height - margin);
            cdfCtx.moveTo(margin, height - margin);
            cdfCtx.lineTo(margin, margin);
            cdfCtx.stroke();
            
            // Axis labels
            cdfCtx.fillStyle = '#333';
            cdfCtx.font = '14px Arial';
            cdfCtx.textAlign = 'center';
            cdfCtx.fillText('x', width/2, height - 10);
            cdfCtx.save();
            cdfCtx.translate(15, height/2);
            cdfCtx.rotate(-Math.PI/2);
            cdfCtx.fillText('F(x)', 0, 0);
            cdfCtx.restore();
            
            // Determine x range based on distribution type
            let xMin, xMax;
            switch (type) {
                case 'continuous':
                    xMin = -4;
                    xMax = 4;
                    break;
                case 'discrete':
                    xMin = -1;
                    xMax = 10;
                    break;
                case 'mixed':
                    xMin = -2;
                    xMax = 6;
                    break;
            }
            
            // Draw CDF
            cdfCtx.strokeStyle = '#4a90e2';
            cdfCtx.lineWidth = 3;
            cdfCtx.beginPath();
            
            if (type === 'discrete') {
                // For discrete distributions, draw step function
                for (let k = 0; k <= 10; k++) {
                    const cdfValue = getCDF(k, type);
                    const x1 = margin + (width - 2 * margin) * (k - xMin) / (xMax - xMin);
                    const x2 = margin + (width - 2 * margin) * (k + 1 - xMin) / (xMax - xMin);
                    const y = height - margin - (height - 2 * margin) * cdfValue;
                    
                    // Draw horizontal line
                    cdfCtx.strokeStyle = '#4a90e2';
                    cdfCtx.lineWidth = 3;
                    cdfCtx.beginPath();
                    cdfCtx.moveTo(x1, y);
                    cdfCtx.lineTo(x2, y);
                    cdfCtx.stroke();
                    
                    // Draw vertical jump to next value if not last point
                    if (k < 10) {
                        const nextY = height - margin - (height - 2 * margin) * getCDF(k + 1, type);
                        cdfCtx.strokeStyle = '#4a90e2';
                        cdfCtx.lineWidth = 1;
                        cdfCtx.setLineDash([2, 2]);
                        cdfCtx.beginPath();
                        cdfCtx.moveTo(x2, y);
                        cdfCtx.lineTo(x2, nextY);
                        cdfCtx.stroke();
                        cdfCtx.setLineDash([]);
                    }
                    
                    // Draw filled circle at left endpoint (closed)
                    cdfCtx.fillStyle = '#4a90e2';
                    cdfCtx.strokeStyle = '#4a90e2';
                    cdfCtx.lineWidth = 2;
                    cdfCtx.beginPath();
                    cdfCtx.arc(x1, y, 5, 0, 2 * Math.PI);
                    cdfCtx.fill();
                    
                    // Draw empty circle at right endpoint (open) - except for last point
                    if (k < 10) {
                        cdfCtx.fillStyle = 'white';
                        cdfCtx.strokeStyle = '#4a90e2';
                        cdfCtx.lineWidth = 2;
                        cdfCtx.beginPath();
                        cdfCtx.arc(x2, y, 5, 0, 2 * Math.PI);
                        cdfCtx.fill();
                        cdfCtx.stroke();
                    }
                }
            } else {
                // For continuous and mixed distributions
                const numPoints = 500;
                for (let i = 0; i <= numPoints; i++) {
                    const x = xMin + (xMax - xMin) * i / numPoints;
                    const y = getCDF(x, type);
                    const pixelX = margin + (width - 2 * margin) * (x - xMin) / (xMax - xMin);
                    const pixelY = height - margin - (height - 2 * margin) * y;
                    
                    if (i === 0) {
                        cdfCtx.moveTo(pixelX, pixelY);
                    } else {
                        cdfCtx.lineTo(pixelX, pixelY);
                    }
                }
            }
            cdfCtx.stroke();
            
            // Draw horizontal line at u
            cdfCtx.strokeStyle = '#ff6b6b';
            cdfCtx.lineWidth = 2;
            cdfCtx.setLineDash([5, 5]);
            cdfCtx.beginPath();
            cdfCtx.moveTo(margin, height - margin - (height - 2 * margin) * u);
            cdfCtx.lineTo(width - margin, height - margin - (height - 2 * margin) * u);
            cdfCtx.stroke();
            cdfCtx.setLineDash([]);
            
            // Find and draw F^{-1}(u)
            const xInv = getInverseCDF(u, type);
            const pixelXInv = margin + (width - 2 * margin) * (xInv - xMin) / (xMax - xMin);
            
            // Draw vertical line at F⁻(u)
            cdfCtx.strokeStyle = '#51cf66';
            cdfCtx.lineWidth = 2;
            cdfCtx.beginPath();
            cdfCtx.moveTo(pixelXInv, height - margin);
            cdfCtx.lineTo(pixelXInv, margin);
            cdfCtx.stroke();
            
            // Highlight the region where F(x) >= u
            cdfCtx.fillStyle = 'rgba(81, 207, 102, 0.2)';
            cdfCtx.fillRect(pixelXInv, margin, width - margin - pixelXInv, height - 2 * margin);
            
            // Draw intersection point
            const fValueAtInv = getCDF(xInv, type);
            const pixelYIntersect = height - margin - (height - 2 * margin) * fValueAtInv;
            cdfCtx.fillStyle = '#ff6b6b';
            cdfCtx.beginPath();
            cdfCtx.arc(pixelXInv, pixelYIntersect, 6, 0, 2 * Math.PI);
            cdfCtx.fill();
            
            // Labels
            cdfCtx.fillStyle = '#ff6b6b';
            cdfCtx.font = '12px Arial';
            cdfCtx.textAlign = 'right';
            cdfCtx.fillText(`u = ${u.toFixed(2)}`, margin - 5, height - margin - (height - 2 * margin) * u + 4);
            
            cdfCtx.fillStyle = '#51cf66';
            cdfCtx.textAlign = 'center';
            cdfCtx.fillText(`F⁻(u) = ${xInv.toFixed(2)}`, pixelXInv, height - margin + 20);
            
            // Add label for the shaded region
            cdfCtx.fillStyle = '#51cf66';
            cdfCtx.font = '14px Arial';
            cdfCtx.textAlign = 'left';
            cdfCtx.fillText('F(x) ≥ u', pixelXInv + 10, margin + 20);
            
            // Draw grid
            cdfCtx.strokeStyle = '#e0e0e0';
            cdfCtx.lineWidth = 1;
            for (let i = 0.1; i < 1; i += 0.1) {
                const y = height - margin - (height - 2 * margin) * i;
                cdfCtx.beginPath();
                cdfCtx.moveTo(margin, y);
                cdfCtx.lineTo(width - margin, y);
                cdfCtx.stroke();
            }
        }
        
        function drawInverseCDF(u) {
            const type = distTypeSelect.value;
            const width = invCanvas.width;
            const height = invCanvas.height;
            const margin = 40;
            
            // Clear canvas
            invCtx.clearRect(0, 0, width, height);
            
            // Draw axes
            invCtx.strokeStyle = '#333';
            invCtx.lineWidth = 2;
            invCtx.beginPath();
            invCtx.moveTo(margin, height - margin);
            invCtx.lineTo(width - margin, height - margin);
            invCtx.moveTo(margin, height - margin);
            invCtx.lineTo(margin, margin);
            invCtx.stroke();
            
            // Axis labels
            invCtx.fillStyle = '#333';
            invCtx.font = '14px Arial';
            invCtx.textAlign = 'center';
            invCtx.fillText('u', width/2, height - 10);
            invCtx.save();
            invCtx.translate(15, height/2);
            invCtx.rotate(-Math.PI/2);
            invCtx.fillText('F⁻(u)', 0, 0);
            invCtx.restore();
            
            // Determine y range
            let yMin, yMax;
            switch (type) {
                case 'continuous':
                    yMin = -4;
                    yMax = 4;
                    break;
                case 'discrete':
                    yMin = -1;
                    yMax = 10;
                    break;
                case 'mixed':
                    yMin = -2;
                    yMax = 6;
                    break;
            }
            
            // Draw inverse CDF
            invCtx.strokeStyle = '#4a90e2';
            invCtx.lineWidth = 3;
            invCtx.beginPath();
            
            const numPoints = 200;
            let lastPixelY = null;
            for (let i = 1; i < numPoints; i++) {
                const uVal = i / numPoints;
                const y = getInverseCDF(uVal, type);
                const pixelX = margin + (width - 2 * margin) * uVal;
                const pixelY = height - margin - (height - 2 * margin) * (y - yMin) / (yMax - yMin);
                
                // Check if point is within visible range
                const isVisible = pixelY >= margin && pixelY <= height - margin;
                
                if (i === 1) {
                    if (isVisible) {
                        invCtx.moveTo(pixelX, pixelY);
                        lastPixelY = pixelY;
                    }
                } else {
                    if (type === 'discrete' && Math.abs(y - getInverseCDF((i-1)/numPoints, type)) > 0.5) {
                        // Draw jump discontinuity
                        invCtx.stroke();
                        invCtx.beginPath();
                        if (isVisible) {
                            invCtx.moveTo(pixelX, pixelY);
                            lastPixelY = pixelY;
                        }
                    } else {
                        if (isVisible && lastPixelY !== null) {
                            invCtx.lineTo(pixelX, pixelY);
                            lastPixelY = pixelY;
                        } else if (!isVisible && lastPixelY !== null) {
                            // Draw to edge of visible area
                            const edgeY = pixelY < margin ? margin : height - margin;
                            invCtx.lineTo(pixelX, edgeY);
                            invCtx.stroke();
                            invCtx.beginPath();
                            lastPixelY = null;
                        } else if (isVisible && lastPixelY === null) {
                            // Coming back into visible area
                            const edgeY = pixelY < margin ? margin : height - margin;
                            invCtx.moveTo(pixelX, edgeY);
                            invCtx.lineTo(pixelX, pixelY);
                            lastPixelY = pixelY;
                        }
                    }
                }
            }
            invCtx.stroke();
            
            // Draw dots to indicate curve continues beyond visible area
            invCtx.fillStyle = '#4a90e2';
            invCtx.font = '16px Arial';
            invCtx.textAlign = 'center';
            
            // Check if curve goes below visible area (near u=0)
            const yAt001 = getInverseCDF(0.001, type);
            const pixelYAt001 = height - margin - (height - 2 * margin) * (yAt001 - yMin) / (yMax - yMin);
            if (pixelYAt001 > height - margin) {
                invCtx.fillText('⋮', margin + 10, height - margin - 5);
                invCtx.font = '12px Arial';
                invCtx.fillText('→ -∞', margin + 10, height - margin + 15);
            }
            
            // Check if curve goes above visible area (near u=1)
            const yAt999 = getInverseCDF(0.999, type);
            const pixelYAt999 = height - margin - (height - 2 * margin) * (yAt999 - yMin) / (yMax - yMin);
            if (pixelYAt999 < margin) {
                invCtx.fillText('⋮', width - margin - 10, margin + 15);
                invCtx.font = '12px Arial';
                invCtx.fillText('→ +∞', width - margin - 10, margin - 5);
            }
            
            // Draw vertical line at current u
            const pixelU = margin + (width - 2 * margin) * u;
            invCtx.strokeStyle = '#ff6b6b';
            invCtx.lineWidth = 2;
            invCtx.setLineDash([5, 5]);
            invCtx.beginPath();
            invCtx.moveTo(pixelU, height - margin);
            invCtx.lineTo(pixelU, margin);
            invCtx.stroke();
            invCtx.setLineDash([]);
            
            // Draw point at (u, F⁻(u))
            const yInv = getInverseCDF(u, type);
            const pixelY = height - margin - (height - 2 * margin) * (yInv - yMin) / (yMax - yMin);
            
            invCtx.fillStyle = '#ff6b6b';
            invCtx.beginPath();
            invCtx.arc(pixelU, pixelY, 6, 0, 2 * Math.PI);
            invCtx.fill();
            
            // Labels
            invCtx.fillStyle = '#ff6b6b';
            invCtx.font = '12px Arial';
            invCtx.textAlign = 'center';
            invCtx.fillText(`u = ${u.toFixed(2)}`, pixelU, height - margin + 20);
            
            invCtx.fillStyle = '#51cf66';
            invCtx.textAlign = 'left';
            // Adjust label position if it would go off screen
            let labelX = pixelU + 10;
            let labelY = pixelY;
            const labelText = `F⁻(u) = ${yInv.toFixed(2)}`;
            const textWidth = invCtx.measureText(labelText).width;
            
            // If label would extend past right edge, reposition it
            if (labelX + textWidth > width - 20) {
                labelX = pixelU - textWidth - 10; // Move to left of dot
                labelY = pixelY - 15; // Move above dot to avoid overlap
            }
            
            // Make sure label doesn't go above the top margin
            if (labelY < margin + 20) {
                labelY = pixelY + 20; // Move below dot instead
            }
            
            invCtx.fillText(labelText, labelX, labelY);
            
            // Draw grid
            invCtx.strokeStyle = '#e0e0e0';
            invCtx.lineWidth = 1;
            for (let i = 0.1; i < 1; i += 0.1) {
                const x = margin + (width - 2 * margin) * i;
                invCtx.beginPath();
                invCtx.moveTo(x, margin);
                invCtx.lineTo(x, height - margin);
                invCtx.stroke();
            }
        }
        
        function updateVisualization(u) {
            drawCDF(u);
            drawInverseCDF(u);
            
            const xInv = getInverseCDF(u, distTypeSelect.value);
            uCurrent.textContent = u.toFixed(2);
            xCurrent.textContent = xInv.toFixed(2);
        }
        
        function animate() {
            if (animateToggle.checked) {
                animationU += 0.005;
                if (animationU > 0.99) {
                    animationU = 0.01;
                }
                uSlider.value = animationU;
                uDisplay.textContent = animationU.toFixed(2);
                updateVisualization(animationU);
                animationId = requestAnimationFrame(animate);
            }
        }
        
        // Event listeners
        uSlider.addEventListener('input', (e) => {
            const u = parseFloat(e.target.value);
            uDisplay.textContent = u.toFixed(2);
            updateVisualization(u);
        });
        
        distTypeSelect.addEventListener('change', () => {
            updateVisualization(parseFloat(uSlider.value));
        });
        
        animateToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
                animate();
            } else {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }
        });
        
        // Canvas interaction
        function handleCanvasHover(e, canvas, type) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const margin = 40;
            const canvasWidth = canvas.width;
            
            if (type === 'cdf') {
                // For CDF canvas, y position determines u
                const y = e.clientY - rect.top;
                const u = 1 - (y - margin) / (canvas.height - 2 * margin);
                if (u >= 0 && u <= 1) {
                    uSlider.value = u;
                    uDisplay.textContent = u.toFixed(2);
                    updateVisualization(u);
                }
            } else {
                // For inverse CDF canvas, x position determines u
                const u = (x - margin) / (canvasWidth - 2 * margin);
                if (u >= 0 && u <= 1) {
                    uSlider.value = u;
                    uDisplay.textContent = u.toFixed(2);
                    updateVisualization(u);
                }
            }
        }
        
        cdfCanvas.addEventListener('mousemove', (e) => handleCanvasHover(e, cdfCanvas, 'cdf'));
        invCanvas.addEventListener('mousemove', (e) => handleCanvasHover(e, invCanvas, 'inv'));
        
        // Initial draw
        updateVisualization(0.5);
    </script>
</body>
</html>