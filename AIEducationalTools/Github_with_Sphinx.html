<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Complete guide to hosting Sphinx documentation on GitHub Pages with automated deployment using GitHub Actions">
    <title>Hosting Sphinx Documentation on GitHub Pages: A Complete Guide</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1e40af;
            --secondary: #64748b;
            --bg: #ffffff;
            --bg-alt: #f8fafc;
            --text: #1e293b;
            --text-light: #475569;
            --border: #e2e8f0;
            --code-bg: #f1f5f9;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            line-height: 1.7;
            color: var(--text);
            background: var(--bg);
            font-size: 17px;
        }

        .container {
            max-width: 1280px;
            margin: 0 auto;
            padding: 0 24px;
        }

        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 48px 0;
            margin-bottom: 0;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 16px;
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.25rem;
            opacity: 0.95;
            font-weight: 400;
        }

        .content-wrapper {
            display: flex;
            gap: 48px;
            align-items: flex-start;
            padding: 48px 0;
        }

        nav {
            flex: 0 0 280px;
            background: var(--bg-alt);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 24px;
            position: sticky;
            top: 24px;
            align-self: flex-start;
        }

        main {
            flex: 1;
            min-width: 0;
        }

        nav h2 {
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--secondary);
            margin-bottom: 16px;
            font-weight: 600;
        }

        nav ol {
            list-style: none;
            counter-reset: section;
        }

        nav li {
            counter-increment: section;
            margin-bottom: 8px;
        }

        nav a {
            color: var(--text);
            text-decoration: none;
            display: block;
            padding: 4px 0;
            transition: color 0.2s;
        }

        nav a:hover {
            color: var(--primary);
        }

        nav a::before {
            content: counter(section) ". ";
            color: var(--secondary);
            font-weight: 600;
        }

        main h2 {
            font-size: 2rem;
            margin-top: 64px;
            margin-bottom: 24px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--border);
            font-weight: 700;
        }

        main h3 {
            font-size: 1.5rem;
            margin-top: 40px;
            margin-bottom: 16px;
            font-weight: 600;
        }

        p {
            margin-bottom: 20px;
        }

        strong {
            font-weight: 600;
            color: var(--text);
        }

        code {
            background: var(--code-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
            font-size: 0.9em;
            color: var(--primary-dark);
        }

        pre {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin: 24px 0;
            line-height: 1.5;
        }

        pre code {
            background: none;
            padding: 0;
            border-radius: 0;
            color: var(--text);
            font-size: 0.875rem;
        }

        .code-header {
            background: var(--bg-alt);
            border: 1px solid var(--border);
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            padding: 8px 16px;
            font-size: 0.875rem;
            color: var(--secondary);
            font-weight: 500;
            margin-bottom: 0;
        }

        .code-header + pre {
            margin-top: 0;
            border-radius: 0 0 8px 8px;
        }

        .callout {
            background: var(--bg-alt);
            border-left: 4px solid var(--primary);
            padding: 16px 20px;
            margin: 24px 0;
            border-radius: 0 8px 8px 0;
        }

        .callout-warning {
            border-left-color: var(--warning);
            background: #fffbeb;
        }

        .callout-success {
            border-left-color: var(--success);
            background: #f0fdf4;
        }

        .callout-danger {
            border-left-color: var(--danger);
            background: #fef2f2;
        }

        .callout p:last-child {
            margin-bottom: 0;
        }

        ul, ol {
            margin: 16px 0 24px 24px;
        }

        li {
            margin-bottom: 8px;
        }

        a {
            color: var(--primary);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .file-tree {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin: 24px 0;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.875rem;
            line-height: 1.8;
            white-space: pre;  
        }


        .file-tree-comment {
            color: var(--secondary);
            font-style: italic;
        }

        footer {
            margin-top: 80px;
            padding: 32px 0;
            border-top: 1px solid var(--border);
            color: var(--text-light);
            text-align: center;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .subtitle {
                font-size: 1.1rem;
            }

            main h2 {
                font-size: 1.75rem;
            }

            main h3 {
                font-size: 1.25rem;
            }

            .content-wrapper {
                flex-direction: column;
                gap: 24px;
            }

            nav {
                position: static;
                flex: 1 1 auto;
                width: 100%;
            }

            pre {
                padding: 16px;
            }
        }

        @media print {
            nav {
                display: none;
            }
            
            header {
                background: none;
                color: var(--text);
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Hosting Sphinx Documentation on GitHub Pages</h1>
            <p class="subtitle">A Complete Guide to Automated Deployment with GitHub Actions</p>
        </div>
    </header>

    <div class="container">
        <div class="content-wrapper">
            <nav>
                <h2>Table of Contents</h2>
                <ol>
                    <li><a href="#getting-started">Getting Started with GitHub and Repositories</a></li>
                    <li><a href="#sphinx-structure">Understanding Sphinx Project Structure</a></li>
                    <li><a href="#github-pages">Configuring GitHub Pages</a></li>
                    <li><a href="#github-actions">Implementing Automated Builds</a></li>
                    <li><a href="#maintenance">Maintaining Production-Quality Documentation</a></li>
                    <li><a href="#troubleshooting">Troubleshooting Common Issues</a></li>
                    <li><a href="#conclusion">Putting it All Together</a></li>
                </ol>
            </nav>

            <main>
                <section id="introduction">
                    <p>
                        <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>
                        offers free, automated hosting for Sphinx documentation with no server maintenance. This guide walks you through setting up
                        <strong>automated deployment workflows using GitHub Actions</strong>, a modern approach that gives you full control over builds while keeping your source and output cleanly separated. By the end, you'll have documentation that rebuilds automatically whenever you push changes, deploys to a public URL, and requires no manual intervention.
                    </p>
                </section>

                <section id="getting-started">
                    <h2>Getting Started with GitHub and Repositories</h2>
                    
                    <p>
                        Creating your first documentation repository requires a GitHub account and a few commands. Navigate to
                        <a href="https://github.com/" target="_blank" rel="noopener">github.com</a> and click
                        <strong>Sign up</strong> to create your account. Verify your email address when prompted, since an unverified email can prevent you from creating repositories and using some GitHub features. See
                        <a href="https://docs.github.com/en/get-started/signing-up-for-github/verifying-your-email-address" target="_blank" rel="noopener">
                            Verifying your email address
                        </a>
                        for details. After that, enable two-factor authentication in your account settings for security, as described in
                        <a href="https://docs.github.com/en/authentication/securing-your-account-with-two-factor-authentication-2fa" target="_blank" rel="noopener">
                            GitHub's 2FA documentation
                        </a>.
                    </p>

                    <p>
                        To create a repository for your documentation, click the
                        <strong>+</strong> icon in the top-right corner and select <strong>New repository</strong>. Choose a memorable name like
                        <code>my-project-docs</code> and select <strong>Public</strong> visibility. With
                        <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages" target="_blank" rel="noopener">
                        GitHub Free</a>, GitHub Pages sites must be published from public repositories; private repositories can only be used as a Pages source on paid plans. Initialize the repository with a README file and add a Python
                        <code>.gitignore</code> template to exclude build artifacts. After clicking <strong>Create repository</strong>, you'll have a home for your documentation at
                        <code>https://github.com/username/repository-name</code>.
                    </p>

                    <div class="callout callout-success">
                        <p><strong>Your Documentation URL:</strong> Your documentation will eventually be published at <code>https://username.github.io/repository-name/</code>. User sites (repositories named <code>username.github.io</code>) deploy to the root domain, while project sites get a path with the repository name.</p>
                    </div>

                    <h3>Installing Git on different operating systems</h3>

                    <p>
                        To work with GitHub from your local machine, you need the
                        <strong>Git</strong> command-line tools installed. The official Git
                        website provides installers and documentation for all major platforms:
                        see <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">
                        git-scm.com/downloads</a>. After installation, you should be able to run
                        <code>git --version</code> in your terminal or command prompt.
                    </p>

                    <h4>Windows</h4>
                    <p>
                        On Windows, download the installer from
                        <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">
                            Git for Windows
                        </a>. During setup, you can accept the default options; they configure
                        Git Bash and integrate Git into the regular command prompt. After
                        installation, open “Git Bash” or “Command Prompt” and verify:
                    </p>

                    <pre><code>git --version</code></pre>

                    <p>
                        If you prefer a graphical client alongside the CLI, you can also install
                        <a href="https://desktop.github.com/" target="_blank" rel="noopener">
                            GitHub Desktop
                        </a>, which uses the same underlying Git but provides a GUI for staging,
                        committing, and pushing changes.
                    </p>

                    <h4>Windows Subsystem for Linux (WSL)</h4>
                    <p>
                        If you use <strong>Windows Subsystem for Linux (WSL)</strong>, you should
                        install Git <em>inside the Linux environment</em> as well, so that Git
                        commands run from your WSL shell see the same paths and tooling as your
                        Sphinx build. First install WSL (see
                        <a href="https://learn.microsoft.com/windows/wsl/install" target="_blank" rel="noopener">
                            Microsoft’s WSL installation guide
                        </a>), then from your WSL terminal:
                    </p>

                    <pre><code># Update package index (Ubuntu/Debian)
                    sudo apt update

                    # Install Git inside WSL
                    sudo apt install git

                    # Verify
                    git --version</code></pre>

                    <p>
                        Your Windows Git (Git for Windows / GitHub Desktop) and WSL Git are
                        independent installs. For Sphinx builds and Python environments that
                        live inside WSL, always run <code>git</code> from the WSL terminal,
                        not from PowerShell or Command Prompt.
                    </p>

                    <h4>macOS</h4>
                    <p>
                        On macOS, Git is often available via Apple’s Command Line Tools or through
                        package managers. The two common approaches are:
                    </p>

                    <ul>
                        <li>
                            Install Xcode Command Line Tools by running
                            <code>xcode-select --install</code> in Terminal, then verify with
                            <code>git --version</code>.
                        </li>
                        <li>
                            Use <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>
                            and install a recent Git version:
                            <pre><code>brew install git
                    git --version</code></pre>
                        </li>
                    </ul>

                    <p>
                        You can also install an official macOS Git build from
                        <a href="https://git-scm.com/download/mac" target="_blank" rel="noopener">
                            git-scm.com
                        </a> if you prefer not to use Homebrew.
                    </p>

                    <h4>Linux</h4>
                    <p>
                        Most Linux distributions include Git in their package repositories. Use
                        your distribution’s package manager to install or update it, then verify
                        with <code>git --version</code>. For example:
                    </p>

                    <pre><code># Debian / Ubuntu
                    sudo apt update
                    sudo apt install git

                    # Fedora
                    sudo dnf install git

                    # Arch Linux
                    sudo pacman -S git</code></pre>

                    <h4>Initial Git configuration</h4>
                    <p>
                        After installing Git (whether on Windows, macOS, Linux, or WSL), configure
                        your global name and email so commits are correctly attributed. These
                        should match the email you use for GitHub:
                    </p>

                    <pre><code>git config --global user.name "Your Name"
                    git config --global user.email "your.email@example.com"</code></pre>

                    <p>
                        You only need to do this once per machine (and once per WSL distro).
                        From this point on, all of the <code>git</code> commands in this guide
                        (clone, add, commit, push, pull) will work as expected.
                    </p>

                    <h3>Essential git commands for documentation workflows</h3>

                    <p>Git tracks changes to your documentation through commits, which are snapshots of your files at specific points in time. Before using git, configure it with your identity using these commands:</p>

                    <div class="code-header">bash</div>
                    <pre><code>git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"</code></pre>

                    <p>Clone your repository to your local machine to start working:</p>

                    <pre><code>git clone https://github.com/username/repository-name.git
cd repository-name</code></pre>

                    <p>The basic documentation workflow follows this pattern: edit files, stage changes, commit them with descriptive messages, then push to GitHub. Here's how it works in practice:</p>

                    <pre><code># Check what files have changed
git status

# Stage specific files for commit
git add docs/index.rst
git add docs/conf.py

# Or stage everything in the docs directory
git add docs/

# Commit with a descriptive message
git commit -m "Add installation documentation"

# Push to GitHub
git push origin main</code></pre>

                    <p>Branches let you work on features without affecting the main documentation. Create a branch for major updates:</p>

                    <pre><code># Create and switch to a new branch
git checkout -b update-api-docs

# Make your changes, then stage and commit
git add docs/api/
git commit -m "Update API reference for v2.0"

# Push the branch to GitHub
git push -u origin update-api-docs</code></pre>

                    <p>After pushing a branch, create a pull request through GitHub's web interface to merge changes back into main. Pull requests enable review and testing before documentation goes live.</p>

                    <p>Keep your local copy synchronized with GitHub using pull commands:</p>

                    <pre><code># Download and merge changes from GitHub
git pull origin main</code></pre>
                </section>

                <section id="sphinx-structure">
                    <h2>Understanding Sphinx Project Structure and Configuration</h2>

                    <p>
                        Sphinx generates HTML documentation from reStructuredText or Markdown source files. The typical structure separates configuration, source content, and build outputs cleanly. When you run
                        <code>sphinx-quickstart docs</code> and choose to keep the source and build directories separate, it creates a layout similar to:
                    </p>

                    <div class="file-tree">docs/
├── source/               <span class="file-tree-comment"># Documentation source files</span>
│   ├── conf.py          <span class="file-tree-comment"># Sphinx configuration</span>
│   ├── index.rst        <span class="file-tree-comment"># Main page and table of contents</span>
│   ├── _static/         <span class="file-tree-comment"># Custom CSS, images, logos</span>
│   └── _templates/      <span class="file-tree-comment"># Custom HTML templates</span>
├── _build/              <span class="file-tree-comment"># Generated HTML (gitignored)</span>
│   └── html/           <span class="file-tree-comment"># The files GitHub Pages will serve</span>
├── Makefile            <span class="file-tree-comment"># Build commands for Linux/Mac</span>
└── make.bat            <span class="file-tree-comment"># Build commands for Windows</span></div>

                    <p>
                        The <strong>conf.py file</strong> controls every aspect of your documentation build. At minimum, it needs project metadata and, for Sphinx-only deployments, GitHub Pages support. See the
                        <a href="https://www.sphinx-doc.org/en/master/usage/quickstart.html" target="_blank" rel="noopener">
                            Sphinx quickstart guide
                        </a>
                        and the
                        <a href="https://www.sphinx-doc.org/en/master/usage/configuration.html" target="_blank" rel="noopener">
                            configuration reference
                        </a>.
                    </p>

                    <div class="code-header">conf.py</div>
                    <pre><code># Project information
project = 'My Project'
author = 'Your Name'
release = '1.0.0'

# Essential extensions
extensions = [
    'sphinx.ext.autodoc',        # Generate docs from docstrings
    'sphinx.ext.napoleon',       # Google/NumPy docstring styles
    'sphinx.ext.viewcode',       # Add source code links
    'sphinx.ext.githubpages',    # Adds .nojekyll for GitHub Pages
]

# HTML output configuration
html_theme = 'furo'              # Modern, clean theme
html_static_path = ['_static']
html_title = 'My Project Documentation'</code></pre>

                    <div class="callout callout-warning">
                        <p>
                            <strong>GitHub Pages extension:</strong>
                            The <code>sphinx.ext.githubpages</code> extension automatically creates a
                            <code>.nojekyll</code> file in the built HTML directory so GitHub Pages will not ignore directories starting with underscores (for example <code>_static/</code> and <code>_sources/</code>). If you are not using a deployment action that writes <code>.nojekyll</code> for you, this extension is strongly recommended. See
                            <a href="https://www.sphinx-doc.org/en/master/usage/extensions/githubpages.html" target="_blank" rel="noopener">
                                the extension documentation
                            </a>.
                        </p>
                    </div>

                    <h3>Choosing themes for GitHub Pages</h3>

                    <p>
                        For 2024–2025, three themes stand out for GitHub Pages hosting.
                        <strong>Furo</strong> offers a modern, minimal design with built-in dark mode and excellent mobile support. Install it with
                        <code>pip install furo</code> and set <code>html_theme = 'furo'</code> in <code>conf.py</code>. See
                        <a href="https://pradyunsg.me/furo/" target="_blank" rel="noopener">Furo's documentation</a>.
                    </p>

                    <p>
                        <strong>sphinx_rtd_theme</strong> (Read the Docs theme) remains a popular choice, recognizable and battle-tested across many projects. Install it with
                        <code>pip install sphinx-rtd-theme</code> and set <code>html_theme = 'sphinx_rtd_theme'</code>. Documentation is available on
                        <a href="https://sphinx-rtd-theme.readthedocs.io/" target="_blank" rel="noopener">Read the Docs</a>.
                    </p>

                    <p>
                        <strong>pydata-sphinx-theme</strong> is used by scientific Python projects such as NumPy and Pandas. It offers a Bootstrap-based responsive layout tailored for data and scientific documentation. Install it with
                        <code>pip install pydata-sphinx-theme</code> and see
                        <a href="https://pydata-sphinx-theme.readthedocs.io/" target="_blank" rel="noopener">
                            the theme documentation
                        </a>.
                        All three themes work well with GitHub Pages and handle static assets correctly.
                    </p>

                    <h3>Building documentation locally</h3>

                    <p>Build your documentation into HTML with the Makefile commands:</p>

                    <pre><code>cd docs
make html</code></pre>

                    <p>
                        This runs <code>sphinx-build -b html source/ _build/html/</code> internally, converting your source files into a complete static website. The generated HTML appears in
                        <code>docs/_build/html/</code> with structure similar to:
                    </p>

                    <div class="file-tree">_build/html/
├── index.html           <span class="file-tree-comment"># Your documentation homepage</span>
├── _static/             <span class="file-tree-comment"># CSS, JavaScript, fonts from theme</span>
├── _sources/            <span class="file-tree-comment"># Source files for "View Source" links</span>
├── _images/             <span class="file-tree-comment"># Images referenced in documentation</span>
├── genindex.html        <span class="file-tree-comment"># Automatically generated index</span>
├── search.html          <span class="file-tree-comment"># Search functionality</span>
└── searchindex.js       <span class="file-tree-comment"># Search index data</span></div>

                    <p>Preview your documentation before deploying by running a local web server:</p>

                    <pre><code>cd docs/_build/html
python -m http.server 8000</code></pre>

                    <p>
                        Open <code>http://localhost:8000</code> in your browser to see exactly how it will look on GitHub Pages. For live reloading during development, install
                        <a href="https://github.com/executablebooks/sphinx-autobuild" target="_blank" rel="noopener">sphinx-autobuild</a>:
                    </p>

                    <pre><code>pip install sphinx-autobuild
sphinx-autobuild docs docs/_build/html</code></pre>

                    <p>This automatically rebuilds when you save files and refreshes your browser.</p>

                    <h3>Creating a requirements file for dependencies</h3>

                    <p>Your documentation needs specific versions of Sphinx, themes, and extensions. Capture these dependencies in <code>docs/requirements.txt</code>:</p>

                    <div class="code-header">requirements.txt</div>
                    <pre><code>sphinx>=7.0.0,<8.0.0
furo>=2023.0.0
myst-parser>=2.0.0
sphinx-autodoc-typehints
sphinx-copybutton
sphinxcontrib-bibtex</code></pre>

                    <p>
                        This file serves two purposes: it documents what you need locally for building documentation, and it tells GitHub Actions what to install in the workflow. Pin major versions (and optionally minor versions) to reduce the risk of unexpected breakages when dependencies update.
                    </p>
                </section>

                <section id="github-pages">
                    <h2>Configuring GitHub Pages for Automated Deployment</h2>

                    <p>
                        GitHub Pages can serve your documentation in multiple ways, but a
                        <strong>branch-based deployment triggered by GitHub Actions</strong> typically provides the best experience for Sphinx projects. It lets you control the build process, keeps source files and output separate, and provides detailed logs when something goes wrong.
                        The setup described here uses a dedicated <code>gh-pages</code> branch as the Pages source.
                        For an overview of available options, see
                        <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages" target="_blank" rel="noopener">
                            About GitHub Pages
                        </a>.
                    </p>

                    <p>
                        Navigate to your repository on GitHub, click <strong>Settings</strong>, then <strong>Pages</strong> in the sidebar. Under
                        <strong>Build and deployment</strong>, set <strong>Source</strong> to
                        <strong>Deploy from a branch</strong>. Once the <code>gh-pages</code> branch exists (the workflow in the next section will create it), configure:
                    </p>

                    <ul>
                        <li><strong>Branch:</strong> <code>gh-pages</code></li>
                        <li><strong>Folder:</strong> <code>/</code></li>
                    </ul>

                    <p>
                        GitHub also supports using <strong>Source: GitHub Actions</strong> with the official
                        <code>actions/deploy-pages</code> workflow. If you prefer that model, follow the templates in the
                        <a href="https://docs.github.com/en/pages" target="_blank" rel="noopener">GitHub Pages documentation</a>.
                        The configuration below focuses on the branch-based approach using a custom workflow and the
                        <a href="https://github.com/peaceiris/actions-gh-pages" target="_blank" rel="noopener">
                            peaceiris/actions-gh-pages
                        </a> action.
                    </p>

                    <h3>Why the .nojekyll file matters</h3>

                    <p>
                        GitHub Pages historically uses Jekyll for static site generation.
                        Jekyll ignores any file or directory starting with an underscore. Sphinx uses underscore directories extensively:
                        <strong>_static/ for CSS and JavaScript, _sources/ for source references, _images/ for figures</strong>. Without a <code>.nojekyll</code> file, your documentation may load as unstyled HTML because the browser cannot find theme assets.
                    </p>

                    <p>
                        The <code>sphinx.ext.githubpages</code> extension can create <code>.nojekyll</code> during builds, and
                        <code>peaceiris/actions-gh-pages</code> also writes a <code>.nojekyll</code> file by default when publishing to the <code>gh-pages</code> branch. If your documentation displays without CSS after deployment, a missing or misplaced <code>.nojekyll</code> file is one of the first things to check.
                    </p>

                    <h3>Understanding GitHub Pages URL structure</h3>

                    <p>Your documentation URL depends on repository naming. Repositories named <code>username.github.io</code> become user sites at <code>https://username.github.io/</code> with content served from the root. All other repositories become project sites at <code>https://username.github.io/repository-name/</code> with the repository name in the path.</p>

                    <p>Sphinx generates relative paths by default, so project site URLs usually work without extra configuration. If you encounter asset loading issues related to absolute URLs, you can set the base URL explicitly in <code>conf.py</code>:</p>

                    <pre><code>html_baseurl = 'https://username.github.io/project-name/'</code></pre>

                    <h3>Setting up custom domains</h3>

                    <p>
                        For custom domains like <code>docs.example.com</code>, first verify ownership to prevent domain takeover attacks. Go to your
                        <a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site" target="_blank" rel="noopener">
                            repository's Pages settings
                        </a>, add the desired domain, and follow the DNS verification instructions.
                    </p>

                    <p>After verification, configure DNS at your domain provider:</p>

                    <p><strong>For subdomains (docs.example.com):</strong></p>
                    <ul>
                        <li>Add a CNAME record pointing to <code>username.github.io</code></li>
                    </ul>

                    <p><strong>For apex domains (example.com):</strong></p>
                    <ul>
                        <li>
                            Add four A records pointing to GitHub's IP addresses (documented in the GitHub Pages DNS documentation):
                            <ul>
                                <li>185.199.108.153</li>
                                <li>185.199.109.153</li>
                                <li>185.199.110.153</li>
                                <li>185.199.111.153</li>
                            </ul>
                        </li>
                    </ul>

                    <p>
                        DNS propagation can take some time. Once complete, enable
                        <strong>Enforce HTTPS</strong> in the repository's Pages settings. GitHub automatically provisions and renews TLS certificates (via Let's Encrypt) for your custom domain.
                    </p>
                </section>

                <section id="github-actions">
                    <h2>Implementing Automated Builds with GitHub Actions</h2>

                    <p>
                        GitHub Actions automates the entire documentation pipeline: installing dependencies, building HTML, and deploying to GitHub Pages on each push. The workflow below uses
                        <a href="https://github.com/peaceiris/actions-gh-pages" target="_blank" rel="noopener">peaceiris/actions-gh-pages</a>
                        to publish the built HTML into a dedicated <code>gh-pages</code> branch. In your GitHub Pages settings, you should set
                        <strong>Source: Deploy from a branch</strong>, <strong>Branch: gh-pages</strong>, <strong>Folder: /</strong>.
                    </p>

                    <p>
                        If you prefer to use the official Pages actions (<code>actions/configure-pages</code>,
                        <code>actions/upload-pages-artifact</code>, <code>actions/deploy-pages</code>) with
                        <strong>Source: GitHub Actions</strong>, use one of the starter workflows in the
                        <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site-with-github-actions" target="_blank" rel="noopener">
                            GitHub documentation
                        </a>.
                    </p>

                    <p>Create a workflow file at <code>.github/workflows/documentation.yml</code> in your repository:</p>

                    <div class="code-header">.github/workflows/documentation.yml</div>
                    <pre><code>name: Build and Deploy Documentation

on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  docs:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: 'docs/requirements.txt'
      
      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r docs/requirements.txt
      
      - name: Build documentation
        run: |
          sphinx-build -b html docs/ _build/
      
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./_build/
          force_orphan: true</code></pre>

                    <p>
                        This workflow triggers on three events: <strong>pushes to the main branch</strong> (which deploy), <strong>pull requests</strong> (which test builds without deploying), and <strong>manual dispatch</strong> (via the Actions tab for testing). The
                        <code>permissions</code> block grants write access needed for deployment to the <code>gh-pages</code> branch.
                    </p>

                    <h3>Breaking down the workflow steps</h3>

                    <p>
                        The <strong>actions/checkout@v4</strong> step clones your repository code into the workflow environment. If you need full git history (for example, for versioning based on tags), you can set <code>fetch-depth: 0</code>:
                    </p>

                    <pre><code>- uses: actions/checkout@v4
  with:
    fetch-depth: 0</code></pre>

                    <p>
                        The <strong>actions/setup-python@v5</strong> step installs Python and enables pip caching to speed up builds. The cache key includes your <code>requirements.txt</code> hash, so changing dependencies invalidates the cache automatically:
                    </p>

                    <pre><code>- uses: actions/setup-python@v5
  with:
    python-version: '3.11'
    cache: 'pip'
    cache-dependency-path: 'docs/requirements.txt'</code></pre>

                    <div class="callout callout-success">
                        <p><strong>Performance Boost:</strong> For many documentation projects, pip caching reduces build times from minutes to tens of seconds by reusing installed packages across runs.</p>
                    </div>

                    <p>
                        The build step runs <code>sphinx-build</code>. For stricter quality control, you can add <code>-W</code> to treat warnings as errors:
                    </p>

                    <pre><code>- name: Build documentation
  run: |
    sphinx-build -W --keep-going -b html docs/ _build/</code></pre>

                    <p>
                        The <strong>peaceiris/actions-gh-pages@v4</strong> action handles deployment. It creates or updates a <code>gh-pages</code> branch with your built HTML, managing all git operations automatically. The <code>if</code> condition ensures deployment only happens on main-branch pushes, not on pull requests. By default, this action also writes a <code>.nojekyll</code> file in the published branch so GitHub Pages serves Sphinx’s underscore directories correctly.
                    </p>

                    <pre><code>- name: Deploy to GitHub Pages
  uses: peaceiris/actions-gh-pages@v4
  if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  with:
    github_token: ${{ secrets.GITHUB_TOKEN }}
    publish_dir: ./_build/
    force_orphan: true
    user_name: 'github-actions[bot]'
    user_email: 'github-actions[bot]@users.noreply.github.com'</code></pre>

                    <p>The <strong><code>force_orphan: true</code></strong> option keeps the <code>gh-pages</code> branch history compact by replacing it on each deployment, which avoids long-term growth in branch size.</p>

                    <h3>Handling advanced dependency requirements</h3>

                    <p>Some documentation requires system packages like Pandoc or Graphviz. Install them before Python dependencies:</p>

                    <pre><code>- name: Install system dependencies
  run: |
    sudo apt-get update
    sudo apt-get install -y pandoc graphviz

- name: Install Python dependencies
  run: |
    pip install -r docs/requirements.txt</code></pre>

                    <p>For projects using Poetry or pipenv, adjust the setup steps accordingly:</p>

                    <pre><code>- uses: actions/setup-python@v5
  with:
    python-version: '3.11'
    cache: 'poetry'

- name: Install dependencies
  run: |
    pip install poetry
    poetry install --only docs</code></pre>

                    <h3>Monitoring builds and deployments</h3>

                    <p>
                        After pushing your workflow file, the <strong>Actions</strong> tab shows build status. Successful runs display a green checkmark; failures show a red X with detailed logs. Click any workflow run to inspect each step's output, including Sphinx warnings and errors.
                    </p>

                    <p>
                        When your Pages source is set to <strong>Deploy from a branch</strong> and your workflow pushes to <code>gh-pages</code>, GitHub runs an internal
                        <strong><code>pages-build-deployment</code></strong> workflow that publishes the contents of that branch to the Pages CDN. You can view the status of that deployment under the repository’s Actions tab and in the Pages settings.
                    </p>

                    <h3>Triggering builds strategically</h3>

                    <p>Limit builds to documentation-related changes using path filters:</p>

                    <pre><code>on:
  push:
    branches: [main]
    paths:
      - 'docs/**'
      - '.github/workflows/documentation.yml'</code></pre>

                    <p>Path filters help avoid unnecessary documentation builds when you change only application code. For large projects, you can also schedule periodic rebuilds:</p>

                    <pre><code>on:
  push:
    branches: [main]
  schedule:
    - cron: '0 2 * * 0'  # Weekly Sunday 2 AM UTC</code></pre>
                </section>

                <section id="maintenance">
                    <h2>Maintaining Production-Quality Documentation</h2>

                    <p>
                        Effective documentation maintenance balances automation, testing, and clear contribution guidelines. Establish a
                        <strong>local-first workflow</strong> where contributors build and preview documentation before pushing. This catches formatting errors, broken references, and missing dependencies early rather than relying solely on CI.
                    </p>

                    <h3>Testing documentation locally before deployment</h3>

                    <p>Run a clean build to verify everything works:</p>

                    <pre><code>cd docs
make clean
make html</code></pre>

                    <p>
                        The <code>clean</code> command removes cached doctrees that can cause stale content. Check the build output for warnings: Sphinx reports broken cross-references, missing images, and syntax errors. Treat warnings seriously, as they often reflect real problems visitors will encounter.
                    </p>

                    <p>Test internal and external links with the linkcheck builder:</p>

                    <pre><code>make linkcheck</code></pre>

                    <p>
                        This crawls URLs referenced in your documentation and reports broken links, redirects, and timeouts. Run it periodically because external sites evolve over time.
                    </p>

                    <p>Preview the built HTML in a browser using Python's built-in server:</p>

                    <pre><code>cd _build/html
python -m http.server 8000</code></pre>

                    <p>
                        Navigate through several pages, test search, verify images, and check that code examples display correctly. Test on mobile by accessing
                        <code>http://your-local-ip:8000</code> from a phone or tablet on the same network.
                    </p>

                    <h3>Pull request workflow for documentation changes</h3>

                    <p>
                        Configure your workflow to build documentation on pull requests without deploying. This pattern ensures every change is validated, but only main-branch pushes publish:
                    </p>

                    <pre><code>on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install dependencies
        run: pip install -r docs/requirements.txt
      
      - name: Build documentation
        run: sphinx-build -W --keep-going -b html docs/ _build/
      
      - name: Upload preview
        if: github.event_name == 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: docs-preview
          path: _build/html/
          retention-days: 7
      
      - name: Deploy to GitHub Pages
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: _build/</code></pre>

                    <p>
                        This workflow builds on every PR, uploads the HTML as a downloadable artifact for reviewers, and only deploys from
                        <code>main</code>.
                    </p>

                    <h3>Versioning documentation for releases</h3>

                    <p>
                        Documentation should track software versions to help users on older releases. The
                        <a href="https://sphinx-multiversion.readthedocs.io/" target="_blank" rel="noopener">
                            sphinx-multiversion
                        </a> extension builds documentation for multiple git branches and tags simultaneously:
                    </p>

                    <pre><code>pip install sphinx-multiversion</code></pre>

                    <p>Configure it in <code>conf.py</code>:</p>

                    <pre><code>extensions = [
    'sphinx_multiversion',
    # other extensions
]

html_sidebars = {
    '**': [
        'versioning.html',
    ],
}</code></pre>

                    <p>Build multiple versions:</p>

                    <pre><code>sphinx-multiversion docs _build/html</code></pre>

                    <p>
                        This creates subdirectories such as <code>_build/html/main/</code>, <code>_build/html/v1.0/</code>, and
                        <code>_build/html/v2.0/</code> from branches and tags. A version selector lets users switch between them. The root <code>index.html</code> can redirect to the latest stable version.
                    </p>

                    <h3>Managing .gitignore for documentation projects</h3>

                    <p>Configure git to ignore build artifacts while tracking source files:</p>

                    <div class="code-header">.gitignore</div>
                    <pre><code># Sphinx build outputs
docs/_build/
docs/_autosummary/

# Python cache
__pycache__/
*.pyc
*.pyo

# Virtual environments
venv/
env/
.venv/

# IDE settings
.vscode/
.idea/
*.swp

# OS files
.DS_Store
Thumbs.db</code></pre>

                    <div class="callout callout-warning">
                        <p><strong>Do not commit built HTML to main:</strong> Avoid committing <code>_build/</code> directories to your main branch. They bloat the repository and create merge conflicts. The <code>gh-pages</code> branch contains only built HTML and is managed automatically by the deployment workflow.</p>
                    </div>
                </section>

                <section id="troubleshooting">
                    <h2>Troubleshooting Common Deployment Issues</h2>

                    <p>Documentation deployment tends to fail for a small number of recurring reasons. Understanding these patterns saves significant debugging time.</p>

                    <h3>When GitHub Pages shows 404 errors</h3>

                    <p>
                        A 404 error after deployment usually means GitHub cannot find <code>index.html</code> at the expected path. First, verify your Pages settings: go to
                        <strong>Settings → Pages</strong> and confirm the source is configured as:
                    </p>

                    <ul>
                        <li><strong>Source:</strong> Deploy from a branch</li>
                        <li><strong>Branch:</strong> <code>gh-pages</code></li>
                        <li><strong>Folder:</strong> <code>/</code></li>
                    </ul>

                    <p>Next, check that the <code>gh-pages</code> branch exists and contains HTML files:</p>

                    <pre><code>git fetch origin
git checkout gh-pages
ls -la</code></pre>

                    <p>
                        You should see <code>index.html</code>, <code>_static/</code>, and other Sphinx output. If the branch is empty or missing, the workflow did not deploy successfully. Review the GitHub Actions logs for errors.
                    </p>

                    <p><strong>A very common cause</strong> is missing permissions. Ensure your workflow includes:</p>

                    <pre><code>permissions:
  contents: write</code></pre>

                    <p>Without this, the deployment step cannot push to <code>gh-pages</code>. After updating permissions, push an empty commit to trigger a rebuild:</p>

                    <pre><code>git commit --allow-empty -m "Fix permissions for Pages deployment"
git push</code></pre>

                    <h3>Fixing build failures in GitHub Actions</h3>

                    <p>
                        Build failures in Actions typically trace to missing dependencies or configuration errors. Open the failed workflow run and expand the
                        <strong>Build documentation</strong> step to see Sphinx error messages.
                    </p>

                    <p><strong>ModuleNotFoundError</strong> indicates missing Python packages. Verify <code>docs/requirements.txt</code> includes everything:</p>

                    <pre><code>sphinx>=7.0.0
furo
myst-parser
sphinx-autodoc-typehints
sphinx-copybutton</code></pre>

                    <p>Test locally with a fresh virtual environment:</p>

                    <pre><code>python -m venv test-env
source test-env/bin/activate  # On Windows: test-env\Scripts\activate
pip install -r docs/requirements.txt
cd docs && make html</code></pre>

                    <p>
                        If the local build succeeds but Actions fails, check the Python version. Your workflow might use Python 3.11 while you develop on 3.9, revealing version-specific incompatibilities.
                    </p>

                    <p>
                        <strong>Extension errors</strong> such as "Handler threw an exception" often mean incompatible package versions. Pin versions in <code>requirements.txt</code> to match your local environment:
                    </p>

                    <pre><code>pip freeze | grep -i sphinx &gt; docs/requirements.txt</code></pre>

                    <p>For system dependencies like Pandoc or Graphviz, add installation steps:</p>

                    <pre><code>- name: Install system dependencies
  run: |
    sudo apt-get update
    sudo apt-get install -y pandoc graphviz</code></pre>

                    <h3>Resolving theme and styling problems</h3>

                    <p>
                        When documentation deploys but appears unstyled as plain HTML, a missing <code>.nojekyll</code> file or incorrect static paths is often responsible. Verify the
                        <code>sphinx.ext.githubpages</code> extension is enabled:
                    </p>

                    <pre><code>extensions = [
    'sphinx.ext.githubpages',
    # other extensions
]</code></pre>

                    <p>
                        This extension automatically creates <code>.nojekyll</code> in the build directory. If you are relying solely on
                        <code>peaceiris/actions-gh-pages</code>, ensure that your <code>publish_dir</code> includes the full Sphinx build output (including <code>.nojekyll</code> and <code>_static/</code>):
                    </p>

                    <pre><code>publish_dir: ./_build/</code></pre>

                    <p>
                        Theme CSS might also fail to load due to incorrect paths. Inspect the page source and check
                        <code>&lt;link rel="stylesheet" href="..."&gt;</code> elements. They should use relative paths like <code>_static/css/theme.css</code>, not absolute paths starting with <code>/</code>. If paths are absolute, configure <code>html_baseurl</code> appropriately or review any custom configuration that modifies URLs.
                    </p>

                    <p><strong>Custom CSS not applying</strong> usually means configuration or path issues:</p>

                    <pre><code>html_static_path = ['_static']
html_css_files = [
    'custom.css',  # Must exist as docs/source/_static/custom.css (or equivalent)
]</code></pre>

                    <p>After changing <code>conf.py</code>, run <code>make clean && make html</code> to clear cached builds.</p>

                    <h3>Debugging path and asset loading issues</h3>

                    <p>
                        Asset loading problems manifest as broken images, missing JavaScript, or CSS 404 errors. Open browser developer tools, go to the <strong>Network</strong> tab, and reload the page. Failed requests appear in red with 404 or 500 status codes.
                    </p>

                    <p><strong>Underscore directory 404s</strong> (for example <code>_static</code> or <code>_sources</code>) may mean Jekyll is still processing files despite <code>.nojekyll</code>. Verify that <code>.nojekyll</code> exists in the deployed <code>gh-pages</code> branch:</p>

                    <pre><code>git checkout gh-pages
ls -la .nojekyll</code></pre>

                    <p>
                        If it is missing, confirm that your build or deployment process is writing it. For peaceiris-based deployments, ensure that <code>publish_dir</code> is pointing at the root of the built HTML.
                    </p>

                    <p><strong>Image path issues</strong> occur when images exist locally but 404 in production. Sphinx expects images in either <code>_static</code> or paths relative to the document. Reference them consistently:</p>

                    <pre><code>.. image:: _static/images/logo.png
   :alt: Project logo</code></pre>

                    <p>After updating image references, rebuild completely with <code>make clean && make html</code> and redeploy.</p>

                    <h3>Handling workflow permission errors</h3>

                    <p>
                        Permission errors during deployment (for example "Resource not accessible by integration") mean GitHub Actions cannot write to your repository. Fix this by explicitly granting write permissions to repository contents:
                    </p>

                    <pre><code>permissions:
  contents: write  # Required for peaceiris/actions-gh-pages to push to gh-pages</code></pre>

                    <p>
                        If you migrate to the official GitHub Pages actions with <strong>Source: GitHub Actions</strong>, you will instead use:
                    </p>

                    <pre><code>permissions:
  contents: read
  pages: write
  id-token: write</code></pre>

                    <p>After updating permissions, rerun the workflow from the Actions tab using the “Run workflow” button or by pushing a new commit.</p>

                    <h3>Emergency recovery procedures</h3>

                    <p>If deployment breaks production documentation, you can roll back quickly:</p>

                    <pre><code># Inspect recent commits on gh-pages
git log gh-pages --oneline

# Reset to the last known good commit
git checkout gh-pages
git reset --hard &lt;good-commit-sha&gt;
git push --force origin gh-pages</code></pre>

                    <p>
                        If the <code>gh-pages</code> branch is severely corrupted or misconfigured, delete and recreate it:
                    </p>

                    <pre><code>git push origin --delete gh-pages
# Next push to main will trigger a fresh deployment
git push origin main</code></pre>

                    <p>This forces a clean rebuild from the current main branch state.</p>
                </section>

                <section id="conclusion">
                    <h2>Putting it All Together</h2>

                    <p>
                        To get started quickly, create a new GitHub repository, initialize it with a README and Python
                        <code>.gitignore</code>, then clone it locally. Install Sphinx and set up a documentation structure:
                    </p>

                    <pre><code>pip install sphinx furo sphinx-autobuild
sphinx-quickstart docs</code></pre>

                    <p>Configure <code>docs/conf.py</code> with essential extensions and a modern theme:</p>

                    <pre><code>extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.napoleon', 
    'sphinx.ext.viewcode',
    'sphinx.ext.githubpages',
]

html_theme = 'furo'</code></pre>

                    <p>
                        Create <code>docs/requirements.txt</code> listing all dependencies, build locally with <code>make html</code>, and preview at
                        <code>http://localhost:8000</code>. Commit and push your source files:
                    </p>

                    <pre><code>git add docs/ .gitignore
git commit -m "Initial Sphinx documentation"
git push origin main</code></pre>

                    <p>
                        Add <code>.github/workflows/documentation.yml</code> with the workflow from the GitHub Actions section above. Push the workflow file and watch the Actions tab as it builds automatically. After the first successful deployment, verify your Pages settings are configured to serve from the
                        <code>gh-pages</code> branch.
                    </p>

                    <div class="callout callout-success">
                        <p><strong>Result:</strong> Your documentation now rebuilds automatically on every push to main, deploys to a public URL, and requires no manual steps beyond writing and reviewing content.</p>
                    </div>

                    <p>
                        For production deployment, consider additional safeguards: enable branch protection on <code>main</code> to require PR reviews, run link checking in CI to catch broken references, implement documentation versioning for releases, and configure custom domains with HTTPS enforcement. Pin dependency versions in
                        <code>requirements.txt</code> for reproducible builds and monitor Actions usage against your account’s free tier limits.
                    </p>

                    <p>
                        The key to maintainable documentation lies in automation, thorough testing, and clear contribution guidelines. Contributors should build locally before submitting PRs, CI should validate every change, and deployment should happen automatically from a trusted branch. This workflow scales from individual projects to large open-source collaborations while maintaining consistently high documentation quality.
                    </p>
                </section>
            </main>
        </div>

        <footer>
            <p>GitHub Pages Deployment Guide for Sphinx | Generated November 2025</p>
        </footer>
    </div>
</body>
</html>
