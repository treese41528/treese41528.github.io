

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lecture 03.1 – Surface Representations &mdash; Fitting SMPL to IMU Optimization</title>
      <link rel="stylesheet" type="text/css" href="/VirtualHumans/_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="/VirtualHumans/_static/css/theme.css?v=e59714d7" />

  
    <link rel="canonical" href="https://treese41528.github.io/VirtualHumans/lecture_03_1_surface_representations.html" />
      <script src="/VirtualHumans/_static/jquery.js?v=5d32c60e"></script>
      <script src="/VirtualHumans/_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="/VirtualHumans/_static/documentation_options.js?v=f2a433a1"></script>
      <script src="/VirtualHumans/_static/doctools.js?v=9bcbadda"></script>
      <script src="/VirtualHumans/_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/VirtualHumans/_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Lecture 03.2 – Procrustes Alignment" href="lecture_03_2_procrustes_alignment.html" />
    <link rel="prev" title="Lecture 02.2 – Rotations and Kinematic Chains" href="lecture_02_2_rotations_kinematic_chains.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Virtual Humans Lecture
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="lecture_01_1_historical_body_models.html">Lecture 01.1 – Historical Body Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_1_historical_body_models.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_1_historical_body_models.html#early-origins-simplified-primitives-and-kinematic-skeletons-1970s1980s">Early Origins: Simplified Primitives and Kinematic Skeletons (1970s–1980s)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_1_historical_body_models.html#advances-in-the-1990s-superquadrics-differentiable-fitting-and-physical-models">Advances in the 1990s: Superquadrics, Differentiable Fitting, and Physical Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_1_historical_body_models.html#the-impact-of-3d-scanning-and-data-from-anthropometry-to-statistical-models-1990s2000s">The Impact of 3D Scanning and Data: From Anthropometry to Statistical Models (1990s–2000s)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_1_historical_body_models.html#scape-and-the-emergence-of-pose-aware-models-mid-2000s">SCAPE and the Emergence of Pose-Aware Models (Mid-2000s)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_1_historical_body_models.html#consolidation-in-the-2010s-smpl-and-integration-with-learning-based-methods">Consolidation in the 2010s: SMPL and Integration with Learning-Based Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_1_historical_body_models.html#deep-learning-and-neural-implicit-models-late-2010spresent">Deep Learning and Neural Implicit Models (Late 2010s–Present)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_1_historical_body_models.html#timeline-summary-of-milestones">Timeline Summary of Milestones</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_1_historical_body_models.html#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html">Lecture 01.2 – Introduction to Human Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#historical-context-of-human-body-modeling">1. Historical Context of Human Body Modeling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#early-developments">Early Developments</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#mid-20th-century-approaches">Mid-20th Century Approaches</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#data-driven-revolution-1990s-2000s">Data-Driven Revolution (1990s-2000s)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#mathematical-foundations-of-human-body-models">2. Mathematical Foundations of Human Body Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#the-smpl-model">The SMPL Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#pca-based-statistical-shape-modeling">PCA-Based Statistical Shape Modeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#kinematic-modeling">Kinematic Modeling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#applications-of-human-body-models">3. Applications of Human Body Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#computer-animation-and-visual-effects">Computer Animation and Visual Effects</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#virtual-humans-and-avatars">Virtual Humans and Avatars</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#biomechanics-and-ergonomics">Biomechanics and Ergonomics</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#human-computer-interaction-hci">Human-Computer Interaction (HCI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#computer-vision-and-ai">Computer Vision and AI</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#education-and-training">Education and Training</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#challenges-and-future-directions">4. Challenges and Future Directions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#computational-efficiency">Computational Efficiency</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#accuracy-and-detail">Accuracy and Detail</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#generalization">Generalization</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#clothing-and-accessories">Clothing and Accessories</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#emerging-approaches">Emerging Approaches</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_2_introduction_to_human_models.html#conclusion">5. Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html">Lecture 01.3 – Introduction to Human Models (Overview)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#historical-context">1. Historical Context</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#early-scientific-studies">Early Scientific Studies</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#mid-20th-century-to-digital-era">Mid-20th Century to Digital Era</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#st-century-advances">21st Century Advances</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#mathematical-foundations">2. Mathematical Foundations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#parametric-body-models">Parametric Body Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#implicit-surface-representations">Implicit Surface Representations</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#kinematic-modeling">Kinematic Modeling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#image-formation-and-rendering">3. Image Formation and Rendering</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#camera-models">Camera Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#shading-and-visibility">Shading and Visibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#differentiable-rendering">Differentiable Rendering</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#surface-representation-methods">4. Surface Representation Methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#explicit-mesh-models">Explicit Mesh Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#implicit-function-models">Implicit Function Models</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#motion-capture-and-behavior-synthesis">5. Motion Capture and Behavior Synthesis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#capturing-human-motion">Capturing Human Motion</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#behavior-synthesis">Behavior Synthesis</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#clothing-modeling">6. Clothing Modeling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#physically-based-simulation">Physically-Based Simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#data-driven-approaches">Data-Driven Approaches</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#implicit-clothing-models">Implicit Clothing Models</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#human-object-interaction">7. Human-Object Interaction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#physics-based-methods">Physics-Based Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#learning-based-approaches">Learning-Based Approaches</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#hybrid-systems">Hybrid Systems</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#applications">8. Applications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#entertainment-and-media">Entertainment and Media</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#healthcare-and-biomechanics">Healthcare and Biomechanics</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#engineering-and-design">Engineering and Design</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#human-computer-interaction">Human-Computer Interaction</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#scientific-research">Scientific Research</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#challenges-and-future-directions">9. Challenges and Future Directions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#scalability-and-generalization">Scalability and Generalization</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#higher-fidelity-dynamics">Higher-Fidelity Dynamics</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#data-and-labeling-constraints">Data and Labeling Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#physics-and-learning-integration">Physics and Learning Integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#semantic-and-cognitive-aspects">Semantic and Cognitive Aspects</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_01_3_introduction_to_human_models_continued.html#realism-vs-controllability">Realism vs. Controllability</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lecture_02_1_image_formation.html">Lecture 02.1 – Image Formation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_1_image_formation.html#historical-developments-in-image-formation">1. Historical Developments in Image Formation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#ancient-and-medieval-optics-camera-obscura">Ancient and Medieval Optics – Camera Obscura</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#renaissance-perspective-and-geometry">Renaissance Perspective and Geometry</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#early-cameras-and-photographic-imaging">Early Cameras and Photographic Imaging</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#modern-developments">Modern Developments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_1_image_formation.html#the-pinhole-camera-model">2. The Pinhole Camera Model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#coordinate-setup">Coordinate Setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#proof-by-similar-triangles">Proof by Similar Triangles</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#numerical-example">Numerical Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#inadequacy-of-a-simple-pinhole">Inadequacy of a Simple Pinhole</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_1_image_formation.html#camera-intrinsics-and-the-projection-matrix">3. Camera Intrinsics and the Projection Matrix</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#extrinsic-parameters">Extrinsic Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#full-projection-example">Full Projection Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_1_image_formation.html#image-distortions-correction">4. Image Distortions &amp; Correction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_1_image_formation.html#properties-of-perspective-projection">5. Properties of Perspective Projection</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_1_image_formation.html#advanced-theoretical-extensions">6. Advanced Theoretical Extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#light-field-imaging-and-plenoptic-cameras">Light Field Imaging and Plenoptic Cameras</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#non-conventional-imaging-techniques">Non-Conventional Imaging Techniques</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_1_image_formation.html#applications-in-modern-vision-and-graphics">7. Applications in Modern Vision and Graphics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#computer-vision-and-3d-reconstruction">Computer Vision and 3D Reconstruction</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#medical-imaging">Medical Imaging</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_1_image_formation.html#photorealistic-rendering-in-computer-graphics">Photorealistic Rendering in Computer Graphics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_1_image_formation.html#python-example-simulating-image-formation">8. Python Example: Simulating Image Formation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lecture_02_2_rotations_kinematic_chains.html">Lecture 02.2 – Rotations and Kinematic Chains</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_2_rotations_kinematic_chains.html#representations-of-3d-rotations">1. Representations of 3D Rotations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_2_rotations_kinematic_chains.html#a-rotation-matrices">A) Rotation Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_2_rotations_kinematic_chains.html#b-euler-angles">B) Euler Angles</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_02_2_rotations_kinematic_chains.html#c-quaternions">C) Quaternions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_2_rotations_kinematic_chains.html#lie-algebra-so-3-and-exponential-map">2. Lie Algebra <span class="math notranslate nohighlight">\(so(3)\)</span> and Exponential Map</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_2_rotations_kinematic_chains.html#rodrigues-rotation-formula">3. Rodrigues’ Rotation Formula</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_2_rotations_kinematic_chains.html#kinematic-chains-forward-inverse-kinematics">4. Kinematic Chains: Forward &amp; Inverse Kinematics</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_02_2_rotations_kinematic_chains.html#comparison-of-rotation-representations">Comparison of Rotation Representations</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Lecture 03.1 – Surface Representations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#mathematical-foundations-of-surface-representations">1. Mathematical Foundations of Surface Representations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-parametric-surfaces">A) Parametric Surfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-implicit-surfaces">B) Implicit Surfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-explicit-surfaces">C) Explicit Surfaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#surface-differential-properties">2. Surface Differential Properties</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-surface-normals">A) Surface Normals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-fundamental-forms-and-curvature">B) Fundamental Forms and Curvature</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-geodesics">C) Geodesics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#discrete-surface-representations">3. Discrete Surface Representations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-polygon-meshes">A) Polygon Meshes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-point-clouds">B) Point Clouds</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-signed-distance-fields-sdf">C) Signed Distance Fields (SDF)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-surface-representations">4. Advanced Surface Representations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-bezier-curves-and-surfaces">A) Bézier Curves and Surfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-b-splines-and-nurbs">B) B-Splines and NURBS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-subdivision-surfaces">C) Subdivision Surfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#d-level-sets">D) Level Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#e-neural-implicit-representations">E) Neural Implicit Representations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#comparative-analysis-and-applications">5. Comparative Analysis and Applications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-computational-efficiency-and-storage">A) Computational Efficiency and Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-practical-applications">B) Practical Applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-operations-complexity">C) Operations Complexity</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#implementation-examples">6. Implementation Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-basic-mesh-processing-python">A) Basic Mesh Processing (Python)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-implicit-surface-utilities">B) Implicit Surface Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-bezier-curve-implementation">C) Bézier Curve Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#d-curvature-estimation-on-meshes">D) Curvature Estimation on Meshes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-topics-and-future-directions">7. Advanced Topics and Future Directions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-multi-resolution-representations">A) Multi-Resolution Representations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-machine-learning-for-geometry">B) Machine Learning for Geometry</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-dynamic-surfaces">C) Dynamic Surfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#d-non-manifold-geometries">D) Non-Manifold Geometries</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html">Lecture 03.2 – Procrustes Alignment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#goal-learning-a-model-of-pose-and-shape">Goal: Learning a Model of Pose and Shape</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#the-challenge-of-registration">The Challenge of Registration</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#surface-representation-mesh">Surface Representation: Mesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#the-procrustes-alignment-problem-mathematical-formulation">The Procrustes Alignment Problem: Mathematical Formulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#rigid-transformations">Rigid Transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#procrustes-alignment-solution">Procrustes Alignment Solution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#decoupling-translation-by-centroid-alignment">Decoupling Translation by Centroid Alignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#optimal-rotation-via-svd">Optimal Rotation via SVD</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#reflection-adjustment">Reflection Adjustment</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#optimal-scale-optional">Optimal Scale (Optional)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#complete-mathematical-derivation">Complete Mathematical Derivation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#translation-derivation">Translation Derivation</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#rotation-derivation">Rotation Derivation</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#scale-derivation">Scale Derivation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#summary-of-procrustes-alignment-algorithm">Summary of Procrustes Alignment Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#python-implementation-example">Python Implementation Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#practical-applications">Practical Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_03_2_procrustes_alignment.html#interactive-visualization-ideas">Interactive Visualization Ideas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lecture_04_1_icp.html">Lecture 4.1: Iterative Closest Point</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_1_icp.html#introduction-to-shape-alignment-and-registration">Introduction to Shape Alignment and Registration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#the-registration-problem">The Registration Problem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_1_icp.html#review-procrustes-analysis">Review: Procrustes Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_1_icp.html#problem-unknown-correspondences">Problem: Unknown Correspondences</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_1_icp.html#the-iterative-closest-point-icp-algorithm">The Iterative Closest Point (ICP) Algorithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#basic-icp-algorithm">Basic ICP Algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#computational-considerations">Computational Considerations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lecture_04_1_icp.html#closest-point-computation">Closest Point Computation</a></li>
<li class="toctree-l4"><a class="reference internal" href="lecture_04_1_icp.html#convergence-and-local-minima">Convergence and Local Minima</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_1_icp.html#point-to-point-vs-point-to-plane-icp">Point-to-Point vs. Point-to-Plane ICP</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#point-to-point-icp">Point-to-Point ICP</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#point-to-plane-icp">Point-to-Plane ICP</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_1_icp.html#gradient-based-icp-for-non-rigid-registration">Gradient-based ICP for Non-Rigid Registration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#gradient-based-icp-algorithm">Gradient-based ICP Algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#advantages-of-gradient-based-icp">Advantages of Gradient-based ICP</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#computing-gradients">Computing Gradients</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_1_icp.html#improving-icp-s-robustness">Improving ICP’s Robustness</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#data-association-direction">Data Association Direction</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#robust-cost-functions">Robust Cost Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#trimmed-icp">Trimmed ICP</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#ransac-based-approaches">RANSAC-based Approaches</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#additional-information">Additional Information</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_1_icp.html#point-to-surface-distance">Point-to-Surface Distance</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_1_icp.html#icp-variants-and-extensions">ICP Variants and Extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#generalized-icp-gicp">Generalized ICP (GICP)</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#em-icp-and-probabilistic-approaches">EM-ICP and Probabilistic Approaches</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#coherent-point-drift-cpd">Coherent Point Drift (CPD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#multi-scale-approaches">Multi-Scale Approaches</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_1_icp.html#applications-of-icp">Applications of ICP</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_1_icp.html#implementing-icp">Implementing ICP</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#efficient-python-implementation">Efficient Python Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_1_icp.html#practical-tips">Practical Tips</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_1_icp.html#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lecture_04_2_body_models.html">Lecture 04.2 - Body Models: Vertex-Based Models and SMPL</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_2_body_models.html#body-models-as-parameterized-functions">1. Body Models as Parameterized Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_2_body_models.html#rotations-articulation-and-pose-representation">2. Rotations, Articulation, and Pose Representation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#rotation-representation">2.1 Rotation Representation</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#kinematic-chain">2.2 Kinematic Chain</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_2_body_models.html#linear-blend-skinning-and-its-limitations">3. Linear Blend Skinning and its Limitations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#linear-blend-skinning">3.1 Linear Blend Skinning</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#problems-with-standard-lbs">3.2 Problems with Standard LBS</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#blend-shapes-for-correcting-lbs-artifacts">3.3 Blend Shapes for Correcting LBS Artifacts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_2_body_models.html#the-smpl-body-model">4. The SMPL Body Model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#smpl-philosophy">4.1 SMPL Philosophy</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#smpl-model-architecture">4.2 SMPL Model Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#shape-blend-shapes">4.2.1 Shape Blend Shapes</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#pose-blend-shapes">4.2.2 Pose Blend Shapes</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#joint-regression">4.2.3 Joint Regression</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#model-training">4.3 Model Training</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_2_body_models.html#comparison-with-scape">5. Comparison with SCAPE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#the-scape-model">5.1 The SCAPE Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#different-approaches-to-deformation">5.2 Different Approaches to Deformation</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#performance-comparison">5.3 Performance Comparison</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#other-advantages">5.4 Other Advantages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_2_body_models.html#alignment-techniques-procrustes-analysis-and-icp">6. Alignment Techniques: Procrustes Analysis and ICP</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#procrustes-analysis">6.1 Procrustes Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#iterative-closest-point-icp">6.2 Iterative Closest Point (ICP)</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#fitting-smpl-to-scans">6.3 Fitting SMPL to Scans</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_2_body_models.html#image-formation-and-the-pinhole-camera-model">7. Image Formation and the Pinhole Camera Model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#the-pinhole-camera-model">7.1 The Pinhole Camera Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#lens-distortion">7.2 Lens Distortion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_2_body_models.html#extensions-and-advanced-applications">8. Extensions and Advanced Applications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#dynamic-soft-tissue-modeling">8.1 Dynamic Soft Tissue Modeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#specialized-extensions">8.2 Specialized Extensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#deep-learning-for-model-fitting">8.3 Deep Learning for Model Fitting</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#probabilistic-approaches">8.4 Probabilistic Approaches</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_04_2_body_models.html#hybrid-models">8.5 Hybrid Models</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_04_2_body_models.html#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lecture_05_1_body_model_training.html">Lecture 5.1 - Training a Body Model and Fitting SMPL to Scans</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lecture_05_1_body_model_training.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lecture_05_1_body_model_training.html#body-models-based-on-triangle-deformations">Body Models Based on Triangle Deformations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_05_1_body_model_training.html#scape-and-blendscape-models">SCAPE and BlendSCAPE Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_05_1_body_model_training.html#triangle-deformation-process">Triangle Deformation Process</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_05_1_body_model_training.html#comparison-smpl-vs-scape-blendscape">Comparison: SMPL vs. SCAPE/BlendSCAPE</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_05_1_body_model_training.html#training-a-body-model-from-registrations">Training a Body Model from Registrations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_05_1_body_model_training.html#the-challenge-of-raw-scan-data">The Challenge of Raw Scan Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_05_1_body_model_training.html#training-from-registrations">Training from Registrations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_05_1_body_model_training.html#obtaining-registrations-fitting-smpl-to-scans">Obtaining Registrations: Fitting SMPL to Scans</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_05_1_body_model_training.html#non-rigid-registration-process">Non-Rigid Registration Process</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_05_1_body_model_training.html#iterative-closest-point-icp-review">Iterative Closest Point (ICP) Review</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_05_1_body_model_training.html#registration-objective-formulation">Registration Objective Formulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_05_1_body_model_training.html#point-to-surface-distance">Point-to-Surface Distance</a></li>
<li class="toctree-l3"><a class="reference internal" href="lecture_05_1_body_model_training.html#multi-stage-optimization-strategy">Multi-Stage Optimization Strategy</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_05_1_body_model_training.html#joint-registration-and-model-training">Joint Registration and Model Training</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lecture_05_1_body_model_training.html#co-registration-approach">Co-Registration Approach</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lecture_05_1_body_model_training.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a><ul>
<li class="toctree-l2"><a class="reference internal" href="references.html#lecture-01-1-historical-body-models">Lecture 01.1 (Historical Body Models)</a></li>
<li class="toctree-l2"><a class="reference internal" href="references.html#lecture-01-2-introduction-to-human-models">Lecture 01.2 (Introduction to Human Models)</a></li>
<li class="toctree-l2"><a class="reference internal" href="references.html#lecture-01-3-introduction-to-human-models-continued">Lecture 01.3 (Introduction to Human Models Continued)</a></li>
<li class="toctree-l2"><a class="reference internal" href="references.html#lecture-02-1-image-formation">Lecture 02.1 (Image Formation)</a></li>
<li class="toctree-l2"><a class="reference internal" href="references.html#lecture-02-2-rotations-kinematic-chains">Lecture 02.2 (Rotations &amp; Kinematic Chains)</a></li>
<li class="toctree-l2"><a class="reference internal" href="references.html#lecture-03-1-surface-representations">Lecture 03.1 (Surface Representations)</a></li>
<li class="toctree-l2"><a class="reference internal" href="references.html#lecture-03-2-procrustes-alignment">Lecture 03.2 (Procrustes Alignment)</a></li>
<li class="toctree-l2"><a class="reference internal" href="references.html#lecture-04-1-iterative-closest-points">Lecture 04.1 (Iterative Closest Points)</a></li>
<li class="toctree-l2"><a class="reference internal" href="references.html#lecture-04-2-body-models">Lecture 04.2 (Body Models)</a></li>
<li class="toctree-l2"><a class="reference internal" href="references.html#lecture-05-1-body-model-training">Lecture 05.1 (Body Model Training)</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Virtual Humans Lecture</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Lecture 03.1 – Surface Representations</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/lecture_03_1_surface_representations.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="lecture-03-1-surface-representations">
<span id="id1"></span><h1>Lecture 03.1 – Surface Representations<a class="headerlink" href="#lecture-03-1-surface-representations" title="Link to this heading"></a></h1>
<iframe width="600" height="400" src="https://www.youtube.com/embed/5uE7Pc5mr1I"
title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><a class="reference external" href="https://virtualhumans.mpi-inf.mpg.de/VH23/slides/pdf/Lecture_03_1_Surface_Representations.pdf">Lecture Slides: Surface Representations</a></p>
<p>In this lecture, we examine different approaches to representing surfaces in computational geometry and computer graphics. The choice of representation significantly impacts what operations can be efficiently performed and what applications are most suitable. We’ll explore parametric (explicit), implicit, and discrete representations such as <strong>meshes</strong>, <strong>point clouds</strong>, and <strong>signed distance fields</strong> (SDFs), along with their mathematical foundations, differential properties, and practical implementations.</p>
<section id="mathematical-foundations-of-surface-representations">
<h2>1. Mathematical Foundations of Surface Representations<a class="headerlink" href="#mathematical-foundations-of-surface-representations" title="Link to this heading"></a></h2>
<p>A surface can be represented mathematically in several ways, each with distinct advantages for different applications. We’ll explore three fundamental approaches: parametric, implicit, and explicit.</p>
<section id="a-parametric-surfaces">
<h3>A) Parametric Surfaces<a class="headerlink" href="#a-parametric-surfaces" title="Link to this heading"></a></h3>
<p>A parametric surface is defined by a mapping from a 2D parameter domain into 3D space:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf{x}(u,v) = \bigl( x(u,v),\, y(u,v),\, z(u,v) \bigr)\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\((u,v) \in D \subset \mathbb{R}^2\)</span> maps to a point on the surface in <span class="math notranslate nohighlight">\(\mathbb{R}^3\)</span>. For a regular surface, the partial derivatives <span class="math notranslate nohighlight">\(\mathbf{x}_u = \frac{\partial \mathbf{x}}{\partial u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x}_v = \frac{\partial \mathbf{x}}{\partial v}\)</span> must be linearly independent (their cross product is non-zero). Intuitively, <span class="math notranslate nohighlight">\(\mathbf{x}_u\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x}_v\)</span> span the tangent plane at each surface point.</p>
<p>For example, a sphere of radius <span class="math notranslate nohighlight">\(R\)</span> can be parameterized using spherical coordinates:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
x(u,v) &amp;= R\,\cos u\,\sin v, \\
y(u,v) &amp;= R\,\sin u\,\sin v, \\
z(u,v) &amp;= R\,\cos v,
\end{aligned}\end{split}\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(u \in [0, 2\pi)\)</span> (longitude) and <span class="math notranslate nohighlight">\(v \in [0, \pi]\)</span> (latitude).</p>
</section>
<section id="b-implicit-surfaces">
<h3>B) Implicit Surfaces<a class="headerlink" href="#b-implicit-surfaces" title="Link to this heading"></a></h3>
<p>An implicit surface is defined as the zero level set of a scalar function in 3D space:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[F(x,y,z) = 0\]</div>
</div></blockquote>
<p>For example, a sphere of radius <span class="math notranslate nohighlight">\(R\)</span> centered at the origin is given by:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[F(x,y,z) = x^2 + y^2 + z^2 - R^2 = 0\]</div>
</div></blockquote>
<p>This representation makes inside/outside queries straightforward:
- If <span class="math notranslate nohighlight">\(F(p) &lt; 0\)</span>, point <span class="math notranslate nohighlight">\(p\)</span> is inside the surface
- If <span class="math notranslate nohighlight">\(F(p) &gt; 0\)</span>, point <span class="math notranslate nohighlight">\(p\)</span> is outside the surface
- If <span class="math notranslate nohighlight">\(F(p) = 0\)</span>, point <span class="math notranslate nohighlight">\(p\)</span> is on the surface</p>
<p>A key requirement for a well-defined implicit surface is that <span class="math notranslate nohighlight">\(\nabla F \neq 0\)</span> on the surface, ensuring a smooth definition via the implicit function theorem.</p>
</section>
<section id="c-explicit-surfaces">
<h3>C) Explicit Surfaces<a class="headerlink" href="#c-explicit-surfaces" title="Link to this heading"></a></h3>
<p>An explicit surface is typically represented as a function of two variables:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[z = f(x,y)\]</div>
</div></blockquote>
<p>This is essentially the graph of a bivariate function over the x-y plane. It’s useful for representing terrains or height fields but cannot capture overhangs or multiple z-values for a single (x,y) pair. This is a special case of the parametric representation with <span class="math notranslate nohighlight">\(u = x\)</span> and <span class="math notranslate nohighlight">\(v = y\)</span>.</p>
<p>Any explicit representation can be converted to implicit form by:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[F(x,y,z) = f(x,y) - z = 0\]</div>
</div></blockquote>
</section>
</section>
<section id="surface-differential-properties">
<h2>2. Surface Differential Properties<a class="headerlink" href="#surface-differential-properties" title="Link to this heading"></a></h2>
<p>Understanding differential properties such as normals and curvature is essential for analyzing and manipulating surfaces.</p>
<section id="a-surface-normals">
<h3>A) Surface Normals<a class="headerlink" href="#a-surface-normals" title="Link to this heading"></a></h3>
<p><strong>Parametric Surfaces:</strong> For a parametric surface <span class="math notranslate nohighlight">\(\mathbf{x}(u,v)\)</span>, the normal vector is:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf{n}(u,v) = \mathbf{x}_u \times \mathbf{x}_v\]</div>
</div></blockquote>
<p>The unit normal is <span class="math notranslate nohighlight">\(\hat{\mathbf{n}} = \frac{\mathbf{x}_u \times \mathbf{x}_v}{|\mathbf{x}_u \times \mathbf{x}_v|}\)</span>.</p>
<p><strong>Implicit Surfaces:</strong> For an implicit surface <span class="math notranslate nohighlight">\(F(x,y,z) = 0\)</span>, the normal at a point is given by the gradient:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf{n}(x,y,z) = \nabla F(x,y,z) = \left( \frac{\partial F}{\partial x}, \frac{\partial F}{\partial y}, \frac{\partial F}{\partial z} \right)\]</div>
</div></blockquote>
<p>The unit normal is <span class="math notranslate nohighlight">\(\hat{\mathbf{n}} = \frac{\nabla F}{|\nabla F|}\)</span>. This makes intuitive sense because the gradient points in the direction of greatest increase, which is perpendicular to the level set.</p>
<p><strong>Explicit Surfaces:</strong> For a surface <span class="math notranslate nohighlight">\(z = f(x,y)\)</span>, the normal vector is:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf{n} = (-f_x, -f_y, 1)\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(f_x = \frac{\partial f}{\partial x}\)</span> and <span class="math notranslate nohighlight">\(f_y = \frac{\partial f}{\partial y}\)</span> are the partial derivatives. The unit normal is:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\hat{\mathbf{n}} = \frac{(-f_x, -f_y, 1)}{\sqrt{1 + f_x^2 + f_y^2}}\]</div>
</div></blockquote>
</section>
<section id="b-fundamental-forms-and-curvature">
<h3>B) Fundamental Forms and Curvature<a class="headerlink" href="#b-fundamental-forms-and-curvature" title="Link to this heading"></a></h3>
<p>The curvature of a surface quantifies how the surface bends in different directions. It’s essential for shape analysis, smoothing, and rendering.</p>
<p><strong>First Fundamental Form:</strong>
The first fundamental form is the metric induced on the surface from 3D space. If we define:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[E = \mathbf{x}_u \cdot \mathbf{x}_u, \quad F = \mathbf{x}_u \cdot \mathbf{x}_v, \quad G = \mathbf{x}_v \cdot \mathbf{x}_v\]</div>
</div></blockquote>
<p>Then any tangent vector <span class="math notranslate nohighlight">\(\mathbf{w} = a\mathbf{x}_u + b\mathbf{x}_v\)</span> has squared length:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[I(\mathbf{w}) = Ea^2 + 2Fab + Gb^2\]</div>
</div></blockquote>
<p><strong>Second Fundamental Form:</strong>
The second fundamental form relates to the surface’s curvature. It is defined using second derivatives:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[L = \mathbf{x}_{uu} \cdot \mathbf{n}, \quad M = \mathbf{x}_{uv} \cdot \mathbf{n}, \quad N = \mathbf{x}_{vv} \cdot \mathbf{n}\]</div>
</div></blockquote>
<p>These coefficients form a quadratic form:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[II = L\,du^2 + 2M\,du\,dv + N\,dv^2\]</div>
</div></blockquote>
<p><strong>Curvature Measures:</strong>
Using the fundamental forms, we can compute important curvature measures:</p>
<ol class="arabic simple">
<li><p><strong>Gaussian Curvature:</strong> <span class="math notranslate nohighlight">\(K = \kappa_1 \kappa_2 = \frac{LN-M^2}{EG-F^2}\)</span></p></li>
<li><p><strong>Mean Curvature:</strong> <span class="math notranslate nohighlight">\(H = \frac{\kappa_1 + \kappa_2}{2} = \frac{EN-2FM+GL}{2(EG-F^2)}\)</span></p></li>
<li><p><strong>Principal Curvatures:</strong> <span class="math notranslate nohighlight">\(\kappa_{1,2} = H \pm \sqrt{H^2-K}\)</span></p></li>
</ol>
<p>The principal curvatures (<span class="math notranslate nohighlight">\(\kappa_1, \kappa_2\)</span>) are the eigenvalues of the shape operator, representing the maximum and minimum normal curvatures at a point.</p>
<p><strong>Curvature for Implicit Surfaces:</strong>
For an implicit surface <span class="math notranslate nohighlight">\(F(x,y,z) = 0\)</span>, curvature can be derived from the gradient and Hessian of <span class="math notranslate nohighlight">\(F\)</span>. The mean curvature is proportional to the divergence of the unit normal:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[-2H = \nabla \cdot \left( \frac{\nabla F}{|\nabla F|} \right)\]</div>
</div></blockquote>
<p>If <span class="math notranslate nohighlight">\(F\)</span> is a signed distance function (with <span class="math notranslate nohighlight">\(|\nabla F| = 1\)</span> near the surface), this simplifies to:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[-2H = \Delta F \quad \text{(the Laplacian of F)}\]</div>
</div></blockquote>
<p><strong>Curvature for Explicit Surfaces:</strong>
For a surface <span class="math notranslate nohighlight">\(z = f(x,y)\)</span>, the Gaussian curvature is:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[K = \frac{f_{xx}f_{yy}-(f_{xy})^2}{(1+f_x^2+f_y^2)^2}\]</div>
</div></blockquote>
<p>And the mean curvature is:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[H = \frac{(1+f_y^2)f_{xx}-2f_xf_y f_{xy}+(1+f_x^2)f_{yy}}{2(1+f_x^2+f_y^2)^{3/2}}\]</div>
</div></blockquote>
</section>
<section id="c-geodesics">
<h3>C) Geodesics<a class="headerlink" href="#c-geodesics" title="Link to this heading"></a></h3>
<p>A geodesic is a curve on a surface that is “as straight as possible” - it has no acceleration component within the tangent plane. Formally, a curve on a surface is geodesic if its geodesic curvature (the curvature component within the surface) is zero.</p>
<p>For example, on a sphere, geodesics are great circles (like the equator or meridians). On a plane, geodesics are straight lines.</p>
<p>A geodesic <span class="math notranslate nohighlight">\(\mathbf{x}(u(t),v(t))\)</span> on a parametric surface must satisfy:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\ddot{u} + \Gamma_{ij}^u \dot{u}_i \dot{u}_j = 0, \quad \ddot{v} + \Gamma_{ij}^v \dot{u}_i \dot{u}_j = 0\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\Gamma_{ij}^u, \Gamma_{ij}^v\)</span> are the Christoffel symbols derived from the first fundamental form.</p>
<p>Geodesics represent shortest paths between points on a surface and are crucial for parameterization, path planning, and surface analysis.</p>
</section>
</section>
<section id="discrete-surface-representations">
<h2>3. Discrete Surface Representations<a class="headerlink" href="#discrete-surface-representations" title="Link to this heading"></a></h2>
<p>In practice, continuous surface representations are discretized for computational purposes.</p>
<section id="a-polygon-meshes">
<h3>A) Polygon Meshes<a class="headerlink" href="#a-polygon-meshes" title="Link to this heading"></a></h3>
<p>A polygon mesh consists of:
- <strong>Vertices</strong>: Points in 3D space (positions)
- <strong>Edges</strong>: Connections between vertices
- <strong>Faces</strong>: Closed loops of edges (typically triangles or quads)</p>
<p><strong>Data Structure:</strong>
A triangle mesh can be represented by:
- A vertex array: <span class="math notranslate nohighlight">\(V\)</span> (n×3 array of coordinates)
- A face array: <span class="math notranslate nohighlight">\(F\)</span> (m×3 array of vertex indices)</p>
<p><strong>Computing Normals:</strong>
- <strong>Face Normal</strong>: For a triangle with vertices <span class="math notranslate nohighlight">\(p_1, p_2, p_3\)</span>, the normal is:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf{n}_f = \frac{(p_2 - p_1) \times (p_3 - p_1)}{|(p_2 - p_1) \times (p_3 - p_1)|}\]</div>
</div></blockquote>
<ul>
<li><p><strong>Vertex Normal</strong>: Typically computed by averaging adjacent face normals:</p>
<div class="math notranslate nohighlight">
\[\mathbf{n}_v = \frac{\sum_{f \in \mathcal{F}(v)} \theta_f \mathbf{n}_f}{|\sum_{f \in \mathcal{F}(v)} \theta_f \mathbf{n}_f|}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{F}(v)\)</span> is the set of faces adjacent to vertex <span class="math notranslate nohighlight">\(v\)</span>, and <span class="math notranslate nohighlight">\(\theta_f\)</span> is the angle at vertex <span class="math notranslate nohighlight">\(v\)</span> in face <span class="math notranslate nohighlight">\(f\)</span>.</p>
</li>
</ul>
<p><strong>Barycentric Interpolation:</strong>
Points inside a triangle can be represented as convex combinations of the vertices:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[p = \phi_i p_i + \phi_j p_j + \phi_k p_k\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\phi_i + \phi_j + \phi_k = 1\)</span> and <span class="math notranslate nohighlight">\(\phi_i, \phi_j, \phi_k \geq 0\)</span>.</p>
<p><strong>Pros and Cons:</strong>
- <strong>Pros</strong>: Efficient for rendering, adaptable resolution, widespread support
- <strong>Cons</strong>: Complex for topology changes, limited smoothness, memory overhead for connections</p>
<p><strong>Implementation Example (Python):</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Define three vertices of a triangle</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="c1"># Compute edge vectors</span>
<span class="n">AB</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">A</span>
<span class="n">AC</span> <span class="o">=</span> <span class="n">C</span> <span class="o">-</span> <span class="n">A</span>

<span class="c1"># Compute face normal using cross product</span>
<span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">AB</span><span class="p">,</span> <span class="n">AC</span><span class="p">)</span>
<span class="n">normal_unit</span> <span class="o">=</span> <span class="n">normal</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Face normal:&quot;</span><span class="p">,</span> <span class="n">normal_unit</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="b-point-clouds">
<h3>B) Point Clouds<a class="headerlink" href="#b-point-clouds" title="Link to this heading"></a></h3>
<p>A point cloud is simply a collection of 3D points, often with additional attributes like normals or colors.</p>
<p><strong>Data Structure:</strong>
- Point positions: <span class="math notranslate nohighlight">\(P\)</span> (n×3 array)
- Optional attributes: normals, colors, etc.</p>
<p><strong>Estimating Normals:</strong>
Since point clouds lack connectivity, normals must be estimated from local neighborhoods:
1. For each point, find its k-nearest neighbors
2. Compute the covariance matrix of the neighborhood
3. The normal is the eigenvector corresponding to the smallest eigenvalue (PCA)</p>
<p><strong>Pros and Cons:</strong>
- <strong>Pros</strong>: Direct output from scanners, flexible topology, simple structure
- <strong>Cons</strong>: No connectivity information, difficult to render directly, challenging for surface reconstruction</p>
</section>
<section id="c-signed-distance-fields-sdf">
<h3>C) Signed Distance Fields (SDF)<a class="headerlink" href="#c-signed-distance-fields-sdf" title="Link to this heading"></a></h3>
<p>An SDF represents a surface implicitly by storing the signed distance to the surface at each point in a volume:
- Negative values: inside the surface
- Positive values: outside the surface
- Zero: on the surface</p>
<p><strong>Data Structure:</strong>
- 3D grid (voxels) storing distance values
- Or a sparse representation (octree, hash grid)
- Or a continuous function approximation (neural network)</p>
<p><strong>Mathematical Definition:</strong>
For a domain <span class="math notranslate nohighlight">\(\Omega\)</span> with boundary <span class="math notranslate nohighlight">\(\partial\Omega\)</span>, the SDF is:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}F(p) =
\begin{cases}
-\min_{q \in \partial\Omega}||p-q|| &amp; \text{if } p \in \Omega \\
\min_{q \in \partial\Omega}||p-q|| &amp; \text{if } p \notin \Omega
\end{cases}\end{split}\]</div>
</div></blockquote>
<p>For a sphere of radius <span class="math notranslate nohighlight">\(R\)</span>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[F_{\text{sphere}}(x,y,z) = \sqrt{x^2 + y^2 + z^2} - R\]</div>
</div></blockquote>
<p><strong>Surface Extraction:</strong>
The surface can be extracted using algorithms like Marching Cubes, which find the zero level set in the volume.</p>
<p><strong>Normal Computation:</strong>
The normal at any point is simply the normalized gradient of the SDF:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf{n}(p) = \frac{\nabla F(p)}{|\nabla F(p)|}\]</div>
</div></blockquote>
<p><strong>Closest Point Computation:</strong>
The closest point on the surface to a query point <span class="math notranslate nohighlight">\(p\)</span> is:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[q = p - F(p) \cdot \nabla F(p)\]</div>
</div></blockquote>
<p><strong>Implementation Example (Python):</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">def</span><span class="w"> </span><span class="nf">sphere_sdf</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
    <span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">pz</span> <span class="o">=</span> <span class="n">point</span>
    <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">center</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">px</span> <span class="o">-</span> <span class="n">cx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">py</span> <span class="o">-</span> <span class="n">cy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pz</span> <span class="o">-</span> <span class="n">cz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dist</span> <span class="o">-</span> <span class="n">radius</span>

<span class="n">test_points</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">test_points</span><span class="p">:</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">sphere_sdf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SDF at&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Pros and Cons:</strong>
- <strong>Pros</strong>: Easy inside/outside queries, natural for CSG operations, handles topology changes
- <strong>Cons</strong>: Memory-intensive for high resolutions, indirect access to surface points</p>
</section>
</section>
<section id="advanced-surface-representations">
<h2>4. Advanced Surface Representations<a class="headerlink" href="#advanced-surface-representations" title="Link to this heading"></a></h2>
<section id="a-bezier-curves-and-surfaces">
<h3>A) Bézier Curves and Surfaces<a class="headerlink" href="#a-bezier-curves-and-surfaces" title="Link to this heading"></a></h3>
<p>Bézier curves use Bernstein polynomials as a basis:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[B_k^n(t) = {n \choose k} t^k (1-t)^{n-k}\]</div>
</div></blockquote>
<p>A Bézier curve of degree <span class="math notranslate nohighlight">\(n\)</span> is defined as:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[C(t) = \sum_{k=0}^{n} P_k B_k^n(t), \quad t \in [0,1]\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(P_k\)</span> are control points.</p>
<p>Bézier surfaces are formed by taking the tensor product of Bézier curves:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[S(u,v) = \sum_{i=0}^{m} \sum_{j=0}^{n} P_{ij} B_i^m(u) B_j^n(v), \quad u,v \in [0,1]\]</div>
</div></blockquote>
<p><strong>Properties:</strong>
- The curve/surface interpolates the first and last control points
- Derivatives at endpoints depend on adjacent control points
- The curve/surface lies in the convex hull of the control points
- Limited flexibility for complex shapes (need multiple patches)</p>
</section>
<section id="b-b-splines-and-nurbs">
<h3>B) B-Splines and NURBS<a class="headerlink" href="#b-b-splines-and-nurbs" title="Link to this heading"></a></h3>
<p>B-splines provide more local control than Bézier curves by using piecewise polynomial functions:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[C(t) = \sum_{i=0}^{n} P_i N_{i,p}(t)\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(N_{i,p}(t)\)</span> are B-spline basis functions of degree <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>Non-Uniform Rational B-Splines (NURBS) extend B-splines with weights and rational functions:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[C(t) = \frac{\sum_{i=0}^{n} w_i P_i N_{i,p}(t)}{\sum_{i=0}^{n} w_i N_{i,p}(t)}\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(w_i\)</span> are weights associated with control points.</p>
<p><strong>Properties:</strong>
- Local control: changing one control point affects only a local region
- Can represent conic sections exactly (unlike polynomial Bézier curves)
- Widely used in CAD and industrial design
- More complex to implement than Bézier curves</p>
</section>
<section id="c-subdivision-surfaces">
<h3>C) Subdivision Surfaces<a class="headerlink" href="#c-subdivision-surfaces" title="Link to this heading"></a></h3>
<p>Subdivision surfaces generate smooth surfaces through iterative refinement of a control mesh:</p>
<ol class="arabic simple">
<li><p>Start with a coarse control mesh</p></li>
<li><p>Apply subdivision rules to split faces and reposition vertices</p></li>
<li><p>Iterate until desired smoothness is achieved</p></li>
</ol>
<p>Common subdivision schemes:
- <strong>Catmull-Clark</strong>: for quad-dominant meshes
- <strong>Loop</strong>: for triangle meshes
- <strong>Doo-Sabin</strong>: for quad meshes, generalizing biquadratic B-splines</p>
<p><strong>Properties:</strong>
- Simple to implement
- Arbitrary topology support
- Can represent sharp features and boundaries
- Widely used in animation and modeling
- Limit surface has provable continuity properties</p>
</section>
<section id="d-level-sets">
<h3>D) Level Sets<a class="headerlink" href="#d-level-sets" title="Link to this heading"></a></h3>
<p>Level sets represent a surface as the zero crossing of a scalar field, typically stored on a grid. Unlike a simple SDF, level set methods include evolution equations that allow the surface to change over time:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t} + F|\nabla \phi| = 0\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(F\)</span> is a speed function that can depend on curvature, external forces, etc.</p>
<p><strong>Applications:</strong>
- Fluid simulation
- Image segmentation
- Shape deformation
- Topology optimization</p>
<p><strong>Advantages:</strong>
- Natural handling of topology changes
- Integration with physics simulations
- No need for reparameterization</p>
</section>
<section id="e-neural-implicit-representations">
<h3>E) Neural Implicit Representations<a class="headerlink" href="#e-neural-implicit-representations" title="Link to this heading"></a></h3>
<p>Recent approaches use neural networks to represent implicit surfaces:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[F_\theta(x,y,z) = 0\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(F_\theta\)</span> is a neural network with parameters <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
<p>Examples include:
- DeepSDF: learns a signed distance field
- Neural Radiance Fields (NeRF): represents both geometry and appearance
- Occupancy Networks: learn binary inside/outside functions</p>
<p><strong>Advantages:</strong>
- Compact representation
- Can learn from data
- Handles complex topology
- Continuous and differentiable
- Can represent multiple shapes with one model</p>
</section>
</section>
<section id="comparative-analysis-and-applications">
<h2>5. Comparative Analysis and Applications<a class="headerlink" href="#comparative-analysis-and-applications" title="Link to this heading"></a></h2>
<section id="a-computational-efficiency-and-storage">
<h3>A) Computational Efficiency and Storage<a class="headerlink" href="#a-computational-efficiency-and-storage" title="Link to this heading"></a></h3>
<table class="docutils align-default" id="id2">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">Computational Efficiency Comparison</span><a class="headerlink" href="#id2" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 25.0%" />
<col style="width: 25.0%" />
<col style="width: 30.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Representation</p></th>
<th class="head"><p>Memory Complexity</p></th>
<th class="head"><p>Query Performance</p></th>
<th class="head"><p>Topology Handling</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Mesh</p></td>
<td><p>O(N) vertices + connectivity</p></td>
<td><p>Fast point sampling</p></td>
<td><p>Difficult for changes</p></td>
</tr>
<tr class="row-odd"><td><p>Point Cloud</p></td>
<td><p>O(N) points</p></td>
<td><p>Fast, but incomplete</p></td>
<td><p>Flexible but implicit</p></td>
</tr>
<tr class="row-even"><td><p>SDF (grid)</p></td>
<td><p>O(N³) for grid resolution N</p></td>
<td><p>Fast inside/outside</p></td>
<td><p>Natural for changes</p></td>
</tr>
<tr class="row-odd"><td><p>NURBS</p></td>
<td><p>O(control points)</p></td>
<td><p>Evaluation complexity depends on degree</p></td>
<td><p>Fixed topology per patch</p></td>
</tr>
<tr class="row-even"><td><p>Neural Implicit</p></td>
<td><p>O(network parameters)</p></td>
<td><p>Forward pass through network</p></td>
<td><p>Flexible</p></td>
</tr>
</tbody>
</table>
</section>
<section id="b-practical-applications">
<h3>B) Practical Applications<a class="headerlink" href="#b-practical-applications" title="Link to this heading"></a></h3>
<p><strong>Computer Graphics and CAD:</strong>
- Meshes: real-time rendering, games, film
- NURBS: CAD, industrial design, manufacturing
- Subdivision: character animation, modeling
- Implicit: CSG operations, special effects</p>
<p><strong>Robotics and Computer Vision:</strong>
- SDFs: collision detection, path planning
- Point clouds: 3D scanning, SLAM
- Meshes: object recognition, tracking
- Neural implicits: scene reconstruction, completion</p>
<p><strong>Physics Simulation:</strong>
- Level sets: fluid simulation, interface tracking
- Meshes: deformable bodies, cloth
- Implicit: fracture simulation, topology changes</p>
<p><strong>Medical Imaging:</strong>
- Level sets: segmentation, registration
- Meshes: visualization, finite element analysis
- Implicit: morphological operations</p>
</section>
<section id="c-operations-complexity">
<h3>C) Operations Complexity<a class="headerlink" href="#c-operations-complexity" title="Link to this heading"></a></h3>
<table class="docutils align-default" id="id3">
<caption><span class="caption-number">Table 2 </span><span class="caption-text">Operation Complexity Comparison</span><a class="headerlink" href="#id3" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 25.0%" />
<col style="width: 25.0%" />
<col style="width: 30.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Mesh</p></th>
<th class="head"><p>Point Cloud</p></th>
<th class="head"><p>Implicit</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Rendering</p></td>
<td><p>Fast (GPU optimized)</p></td>
<td><p>Challenging</p></td>
<td><p>Requires extraction</p></td>
</tr>
<tr class="row-odd"><td><p>Boolean Operations</p></td>
<td><p>Complex</p></td>
<td><p>N/A</p></td>
<td><p>Simple</p></td>
</tr>
<tr class="row-even"><td><p>Deformation</p></td>
<td><p>Natural</p></td>
<td><p>Simple but lacks connectivity</p></td>
<td><p>Requires reparameterization</p></td>
</tr>
<tr class="row-odd"><td><p>Curvature Analysis</p></td>
<td><p>Discrete approximations</p></td>
<td><p>Challenging</p></td>
<td><p>Direct from function</p></td>
</tr>
<tr class="row-even"><td><p>Closest Point</p></td>
<td><p>Acceleration structures needed</p></td>
<td><p>kD-tree search</p></td>
<td><p>Direct for SDFs</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="implementation-examples">
<h2>6. Implementation Examples<a class="headerlink" href="#implementation-examples" title="Link to this heading"></a></h2>
<section id="a-basic-mesh-processing-python">
<h3>A) Basic Mesh Processing (Python)<a class="headerlink" href="#a-basic-mesh-processing-python" title="Link to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Compute mesh face normal</span>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_face_normal</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">face</span><span class="p">):</span>
    <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">face</span><span class="p">]</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">v3</span> <span class="o">-</span> <span class="n">v1</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">normal</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>

<span class="c1"># Compute vertex normals from face normals</span>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_vertex_normals</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">):</span>
    <span class="n">vertex_normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">compute_face_normal</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vertex_idx</span> <span class="ow">in</span> <span class="n">face</span><span class="p">:</span>
            <span class="n">vertex_normals</span><span class="p">[</span><span class="n">vertex_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">normal</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">vertex_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Normalize</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vertex_normals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">vertex_normals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vertex_normals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">vertex_normals</span>
</pre></div>
</div>
</section>
<section id="b-implicit-surface-utilities">
<h3>B) Implicit Surface Utilities<a class="headerlink" href="#b-implicit-surface-utilities" title="Link to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Torus SDF</span>
<span class="k">def</span><span class="w"> </span><span class="nf">torus_sdf</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">point</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">r</span>

<span class="c1"># Compute SDF gradient (for normal)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">numerical_gradient</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">point</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="n">x</span><span class="o">+</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span> <span class="o">-</span> <span class="n">func</span><span class="p">([</span><span class="n">x</span><span class="o">-</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span><span class="p">)</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span> <span class="o">-</span> <span class="n">func</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">z</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span><span class="p">)</span>
    <span class="n">dz</span> <span class="o">=</span> <span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">+</span><span class="n">epsilon</span><span class="p">])</span> <span class="o">-</span> <span class="n">func</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">-</span><span class="n">epsilon</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span><span class="p">)</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">grad</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>

<span class="c1"># Project point to surface</span>
<span class="k">def</span><span class="w"> </span><span class="nf">project_to_surface</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">max_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_steps</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">numerical_gradient</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">grad</span>
    <span class="k">return</span> <span class="n">p</span>
</pre></div>
</div>
</section>
<section id="c-bezier-curve-implementation">
<h3>C) Bézier Curve Implementation<a class="headerlink" href="#c-bezier-curve-implementation" title="Link to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">def</span><span class="w"> </span><span class="nf">bernstein</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bernstein polynomial basis function.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">bezier_curve</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate points along a Bezier curve.&quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">control_points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_points</span><span class="p">):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">control_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">+=</span> <span class="n">bernstein</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="d-curvature-estimation-on-meshes">
<h3>D) Curvature Estimation on Meshes<a class="headerlink" href="#d-curvature-estimation-on-meshes" title="Link to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_curvature</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">vertex_normals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Estimate mean curvature using the Laplace-Beltrami operator.&quot;&quot;&quot;</span>
    <span class="n">curvatures</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>

    <span class="c1"># Build adjacency information</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="n">face</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">face</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">v2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
                <span class="n">neighbors</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
                <span class="n">neighbors</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>

    <span class="c1"># Compute curvature for each vertex</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="c1"># Compute cotangent weights and mean curvature</span>
        <span class="n">laplacian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">total_weight</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Simple uniform weight, cotangent weights would be better</span>
            <span class="n">laplacian</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">vec</span>
            <span class="n">total_weight</span> <span class="o">+=</span> <span class="n">weight</span>

        <span class="k">if</span> <span class="n">total_weight</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">laplacian</span> <span class="o">/=</span> <span class="n">total_weight</span>

        <span class="c1"># Mean curvature is half the magnitude of the Laplacian</span>
        <span class="n">curvatures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">laplacian</span><span class="p">)</span>

        <span class="c1"># Sign based on normal direction</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">laplacian</span><span class="p">,</span> <span class="n">vertex_normals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curvatures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">curvatures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">curvatures</span>
</pre></div>
</div>
</section>
</section>
<section id="advanced-topics-and-future-directions">
<h2>7. Advanced Topics and Future Directions<a class="headerlink" href="#advanced-topics-and-future-directions" title="Link to this heading"></a></h2>
<section id="a-multi-resolution-representations">
<h3>A) Multi-Resolution Representations<a class="headerlink" href="#a-multi-resolution-representations" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Adaptive meshes</p></li>
<li><p>Progressive LOD (Level of Detail)</p></li>
<li><p>Wavelets for surfaces</p></li>
<li><p>Hierarchical structures (octrees, BSP trees)</p></li>
</ul>
</section>
<section id="b-machine-learning-for-geometry">
<h3>B) Machine Learning for Geometry<a class="headerlink" href="#b-machine-learning-for-geometry" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Neural implicit fields</p></li>
<li><p>Point cloud processing networks</p></li>
<li><p>Mesh generation from data</p></li>
<li><p>Differentiable rendering</p></li>
<li><p>DeepSDF and NeRF architectures</p></li>
</ul>
</section>
<section id="c-dynamic-surfaces">
<h3>C) Dynamic Surfaces<a class="headerlink" href="#c-dynamic-surfaces" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Time-evolving geometries</p></li>
<li><p>Physical simulations</p></li>
<li><p>Fluid interfaces</p></li>
<li><p>Growth and morphogenesis models</p></li>
</ul>
</section>
<section id="d-non-manifold-geometries">
<h3>D) Non-Manifold Geometries<a class="headerlink" href="#d-non-manifold-geometries" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Mixed-dimensional models</p></li>
<li><p>Cell complexes</p></li>
<li><p>Combinatorial representations</p></li>
<li><p>Geometric deep learning</p></li>
</ul>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lecture_02_2_rotations_kinematic_chains.html" class="btn btn-neutral float-left" title="Lecture 02.2 – Rotations and Kinematic Chains" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lecture_03_2_procrustes_alignment.html" class="btn btn-neutral float-right" title="Lecture 03.2 – Procrustes Alignment" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>