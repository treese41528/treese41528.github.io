

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Section 2.2 Uniform Random Variates &mdash; STAT 418</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=3d0abd52" />

  
    <link rel="canonical" href="https://treese41528.github.io/STAT418/Website/part1_foundations/chapter2/ch2_2-uniform-random-variates.html" />
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=30646c52"></script>
      <script>let toggleHintShow = 'Show solution';</script>
      <script>let toggleHintHide = 'Hide solution';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>window.MathJax = {"options": {"enableMenu": true, "menuOptions": {"settings": {"enrich": true, "speech": true, "braille": true, "collapsible": true, "assistiveMml": false}}}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
      <script src="../../_static/custom.js?v=8718e0ab"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Section 2.3 Inverse CDF Method" href="ch2_3-inverse-cdf-method.html" />
    <link rel="prev" title="Section 2.1 Monte Carlo Fundamentals" href="ch2_1-monte-carlo-fundamentals.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            STAT 350: Introduction to Statistics
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Course Content</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Part I: Foundations of Probability and Computation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../chapter1/index.html">Chapter 1: Statistical Paradigms and Core Concepts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../chapter1/ch1_1-probability-and-inference-paradigms.html">Section 1.1 Paradigms of Probability and Statistical Inference</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_1-probability-and-inference-paradigms.html#the-mathematical-foundation-kolmogorov-s-axioms">The Mathematical Foundation: Kolmogorov’s Axioms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_1-probability-and-inference-paradigms.html#interpretations-of-probability">Interpretations of Probability</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_1-probability-and-inference-paradigms.html#statistical-inference-paradigms">Statistical Inference Paradigms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_1-probability-and-inference-paradigms.html#historical-and-philosophical-debates">Historical and Philosophical Debates</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_1-probability-and-inference-paradigms.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_1-probability-and-inference-paradigms.html#looking-ahead-our-course-focus">Looking Ahead: Our Course Focus</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_1-probability-and-inference-paradigms.html#references-and-further-reading">References and Further Reading</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../chapter1/ch1_2-probability_distributions_review.html">Section 1.2 Probability Distributions: Theory and Computation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_2-probability_distributions_review.html#from-abstract-foundations-to-concrete-tools">From Abstract Foundations to Concrete Tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_2-probability_distributions_review.html#the-python-ecosystem-for-probability">The Python Ecosystem for Probability</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_2-probability_distributions_review.html#introduction-why-probability-distributions-matter">Introduction: Why Probability Distributions Matter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_2-probability_distributions_review.html#id1">The Python Ecosystem for Probability</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_2-probability_distributions_review.html#discrete-distributions">Discrete Distributions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_2-probability_distributions_review.html#continuous-distributions">Continuous Distributions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_2-probability_distributions_review.html#additional-important-distributions">Additional Important Distributions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_2-probability_distributions_review.html#summary-and-practical-guidelines">Summary and Practical Guidelines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_2-probability_distributions_review.html#conclusion">Conclusion</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_2-probability_distributions_review.html#references-and-further-reading">References and Further Reading</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../chapter1/ch1_3-python_random_generation.html">Section 1.3 Python Random Generation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_3-python_random_generation.html#from-mathematical-distributions-to-computational-samples">From Mathematical Distributions to Computational Samples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_3-python_random_generation.html#the-python-ecosystem-at-a-glance">The Python Ecosystem at a Glance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_3-python_random_generation.html#understanding-pseudo-random-number-generation">Understanding Pseudo-Random Number Generation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_3-python_random_generation.html#the-standard-library-random-module">The Standard Library: <code class="docutils literal notranslate"><span class="pre">random</span></code> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_3-python_random_generation.html#numpy-fast-vectorized-random-sampling">NumPy: Fast Vectorized Random Sampling</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_3-python_random_generation.html#scipy-stats-the-complete-statistical-toolkit">SciPy Stats: The Complete Statistical Toolkit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_3-python_random_generation.html#bringing-it-all-together-library-selection-guide">Bringing It All Together: Library Selection Guide</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_3-python_random_generation.html#looking-ahead-from-random-numbers-to-monte-carlo-methods">Looking Ahead: From Random Numbers to Monte Carlo Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_3-python_random_generation.html#references-and-further-reading">References and Further Reading</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../chapter1/ch1_4-chapter-summary.html">Section 1.4 Chapter 1 Summary: Foundations in Place</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_4-chapter-summary.html#the-three-pillars-of-chapter-1">The Three Pillars of Chapter 1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_4-chapter-summary.html#how-the-pillars-connect">How the Pillars Connect</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_4-chapter-summary.html#what-lies-ahead-the-road-to-simulation">What Lies Ahead: The Road to Simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_4-chapter-summary.html#chapter-1-exercises-synthesis-problems">Chapter 1 Exercises: Synthesis Problems</a></li>
<li class="toctree-l4"><a class="reference internal" href="../chapter1/ch1_4-chapter-summary.html#references-and-further-reading">References and Further Reading</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Chapter 2: Monte Carlo Simulation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html">Section 2.1 Monte Carlo Fundamentals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#the-historical-development-of-monte-carlo-methods">The Historical Development of Monte Carlo Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#the-core-principle-expectation-as-integration">The Core Principle: Expectation as Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#theoretical-foundations">Theoretical Foundations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#variance-estimation-and-confidence-intervals">Variance Estimation and Confidence Intervals</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#worked-examples">Worked Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#comparison-with-deterministic-methods">Comparison with Deterministic Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#sample-size-determination">Sample Size Determination</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#convergence-diagnostics-and-monitoring">Convergence Diagnostics and Monitoring</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#chapter-2-1-exercises-monte-carlo-fundamentals-mastery">Chapter 2.1 Exercises: Monte Carlo Fundamentals Mastery</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#id1">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#transition-to-what-follows">Transition to What Follows</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_1-monte-carlo-fundamentals.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Section 2.2 Uniform Random Variates</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#why-uniform-the-universal-currency-of-randomness">Why Uniform? The Universal Currency of Randomness</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-paradox-of-computational-randomness">The Paradox of Computational Randomness</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chaotic-dynamical-systems-an-instructive-failure">Chaotic Dynamical Systems: An Instructive Failure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linear-congruential-generators">Linear Congruential Generators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shift-register-generators">Shift-Register Generators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-kiss-generator-combining-strategies">The KISS Generator: Combining Strategies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modern-generators-mersenne-twister-and-pcg">Modern Generators: Mersenne Twister and PCG</a></li>
<li class="toctree-l4"><a class="reference internal" href="#statistical-testing-of-random-number-generators">Statistical Testing of Random Number Generators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chapter-2-2-exercises-uniform-random-variates-mastery">Chapter 2.2 Exercises: Uniform Random Variates Mastery</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transition-to-what-follows">Transition to What Follows</a></li>
<li class="toctree-l4"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ch2_3-inverse-cdf-method.html">Section 2.3 Inverse CDF Method</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ch2_3-inverse-cdf-method.html#mathematical-foundations">Mathematical Foundations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_3-inverse-cdf-method.html#continuous-distributions-with-closed-form-inverses">Continuous Distributions with Closed-Form Inverses</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_3-inverse-cdf-method.html#numerical-inversion">Numerical Inversion</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_3-inverse-cdf-method.html#discrete-distributions">Discrete Distributions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_3-inverse-cdf-method.html#mixed-distributions">Mixed Distributions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_3-inverse-cdf-method.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_3-inverse-cdf-method.html#chapter-2-3-exercises-inverse-cdf-method-mastery">Chapter 2.3 Exercises: Inverse CDF Method Mastery</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_3-inverse-cdf-method.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_3-inverse-cdf-method.html#id1">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_3-inverse-cdf-method.html#transition-to-what-follows">Transition to What Follows</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_3-inverse-cdf-method.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ch2_4-transformation-methods.html">Section 2.4 Transformation Methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ch2_4-transformation-methods.html#why-transformation-methods">Why Transformation Methods?</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_4-transformation-methods.html#the-boxmuller-transform">The Box–Muller Transform</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_4-transformation-methods.html#the-polar-marsaglia-method">The Polar (Marsaglia) Method</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_4-transformation-methods.html#method-comparison-boxmuller-vs-polar-vs-ziggurat">Method Comparison: Box–Muller vs Polar vs Ziggurat</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_4-transformation-methods.html#the-ziggurat-algorithm">The Ziggurat Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_4-transformation-methods.html#the-clt-approximation-historical">The CLT Approximation (Historical)</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_4-transformation-methods.html#distributions-derived-from-the-normal">Distributions Derived from the Normal</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_4-transformation-methods.html#multivariate-normal-generation">Multivariate Normal Generation</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_4-transformation-methods.html#implementation-guidance">Implementation Guidance</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_4-transformation-methods.html#chapter-2-4-exercises-transformation-methods-mastery">Chapter 2.4 Exercises: Transformation Methods Mastery</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_4-transformation-methods.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_4-transformation-methods.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ch2_5-rejection-sampling.html">Section 2.5 Rejection Sampling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#the-dartboard-intuition">The Dartboard Intuition</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#the-accept-reject-algorithm">The Accept-Reject Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#efficiency-analysis">Efficiency Analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#choosing-the-proposal-distribution">Choosing the Proposal Distribution</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#python-implementation">Python Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#the-squeeze-principle">The Squeeze Principle</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#geometric-example-sampling-from-the-unit-disk">Geometric Example: Sampling from the Unit Disk</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#worked-examples">Worked Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#limitations-and-the-curse-of-dimensionality">Limitations and the Curse of Dimensionality</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#connections-to-other-methods">Connections to Other Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#chapter-2-5-exercises-rejection-sampling-mastery">Chapter 2.5 Exercises: Rejection Sampling Mastery</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_5-rejection-sampling.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ch2_6-variance-reduction-methods.html">Section 2.6 Variance Reduction Methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ch2_6-variance-reduction-methods.html#the-variance-reduction-paradigm">The Variance Reduction Paradigm</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_6-variance-reduction-methods.html#importance-sampling">Importance Sampling</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_6-variance-reduction-methods.html#control-variates">Control Variates</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_6-variance-reduction-methods.html#antithetic-variates">Antithetic Variates</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_6-variance-reduction-methods.html#stratified-sampling">Stratified Sampling</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_6-variance-reduction-methods.html#common-random-numbers">Common Random Numbers</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_6-variance-reduction-methods.html#conditional-monte-carlo-raoblackwellization">Conditional Monte Carlo (Rao–Blackwellization)</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_6-variance-reduction-methods.html#combining-variance-reduction-techniques">Combining Variance Reduction Techniques</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_6-variance-reduction-methods.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_6-variance-reduction-methods.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_6-variance-reduction-methods.html#chapter-2-6-exercises-variance-reduction-mastery">Chapter 2.6 Exercises: Variance Reduction Mastery</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_6-variance-reduction-methods.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ch2_7-chapter-summary.html">Section 2.7 Chapter 2 Summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ch2_7-chapter-summary.html#the-complete-monte-carlo-workflow">The Complete Monte Carlo Workflow</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_7-chapter-summary.html#method-selection-guide">Method Selection Guide</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_7-chapter-summary.html#quick-reference-tables">Quick Reference Tables</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_7-chapter-summary.html#common-pitfalls-checklist">Common Pitfalls Checklist</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_7-chapter-summary.html#connections-to-later-chapters">Connections to Later Chapters</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_7-chapter-summary.html#learning-outcomes-checklist">Learning Outcomes Checklist</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_7-chapter-summary.html#further-reading-optimization-and-missing-data">Further Reading: Optimization and Missing Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_7-chapter-summary.html#final-perspective">Final Perspective</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2_7-chapter-summary.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../part2_frequentist/index.html">Part II: Frequentist Inference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../part2_frequentist/chapter3/index.html">Chapter 3: Parametric Inference and Likelihood Methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html">Section 3.1 Exponential Families</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#historical-origins-from-scattered-results-to-unified-theory">Historical Origins: From Scattered Results to Unified Theory</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#the-canonical-exponential-family">The Canonical Exponential Family</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#converting-familiar-distributions">Converting Familiar Distributions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#the-log-partition-function-a-moment-generating-machine">The Log-Partition Function: A Moment-Generating Machine</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#sufficiency-capturing-all-parameter-information">Sufficiency: Capturing All Parameter Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#minimal-sufficiency-and-completeness">Minimal Sufficiency and Completeness</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#conjugate-priors-and-bayesian-inference">Conjugate Priors and Bayesian Inference</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#exponential-dispersion-models-and-glms">Exponential Dispersion Models and GLMs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#python-implementation">Python Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#chapter-3-1-exercises-exponential-families-mastery">Chapter 3.1 Exercises: Exponential Families Mastery</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_1-exponential-families.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html">Section 3.2 Maximum Likelihood Estimation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#the-likelihood-function">The Likelihood Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#the-score-function">The Score Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#fisher-information">Fisher Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#closed-form-maximum-likelihood-estimators">Closed-Form Maximum Likelihood Estimators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#numerical-optimization-for-mle">Numerical Optimization for MLE</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#asymptotic-properties-of-mles">Asymptotic Properties of MLEs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#the-cramer-rao-lower-bound">The Cramér-Rao Lower Bound</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#the-invariance-property">The Invariance Property</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#likelihood-based-hypothesis-testing">Likelihood-Based Hypothesis Testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#confidence-intervals-from-likelihood">Confidence Intervals from Likelihood</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#connection-to-bayesian-inference">Connection to Bayesian Inference</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#chapter-3-2-exercises-maximum-likelihood-estimation-mastery">Chapter 3.2 Exercises: Maximum Likelihood Estimation Mastery</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_2-maximum-likelihood-estimation.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_3-sampling-variability.html">Section 3.3 Sampling Variability and Variance Estimation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_3-sampling-variability.html#statistical-estimators-and-their-properties">Statistical Estimators and Their Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_3-sampling-variability.html#sampling-distributions">Sampling Distributions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_3-sampling-variability.html#the-delta-method">The Delta Method</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_3-sampling-variability.html#the-plug-in-principle">The Plug-in Principle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_3-sampling-variability.html#variance-estimation-methods">Variance Estimation Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_3-sampling-variability.html#applications-and-worked-examples">Applications and Worked Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_3-sampling-variability.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_3-sampling-variability.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_3-sampling-variability.html#exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_3-sampling-variability.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html">Section 3.4 Linear Models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#matrix-calculus-foundations">Matrix Calculus Foundations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#the-linear-model">The Linear Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#ordinary-least-squares-the-calculus-approach">Ordinary Least Squares: The Calculus Approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#ordinary-least-squares-the-geometric-approach">Ordinary Least Squares: The Geometric Approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#properties-of-the-ols-estimator">Properties of the OLS Estimator</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#the-gauss-markov-theorem">The Gauss-Markov Theorem</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#estimating-the-error-variance">Estimating the Error Variance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#distributional-results-under-normality">Distributional Results Under Normality</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#diagnostics-and-model-checking">Diagnostics and Model Checking</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#numerical-stability-qr-decomposition">Numerical Stability: QR Decomposition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#model-selection-and-information-criteria">Model Selection and Information Criteria</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#regularization-ridge-and-lasso">Regularization: Ridge and LASSO</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#chapter-3-4-exercises-linear-models-mastery">Chapter 3.4 Exercises: Linear Models Mastery</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_4-linear-models.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html">Section 3.5 Generalized Linear Models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#historical-context-unification-of-regression-methods">Historical Context: Unification of Regression Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#the-glm-framework-three-components">The GLM Framework: Three Components</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#score-equations-and-fisher-information">Score Equations and Fisher Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#iteratively-reweighted-least-squares">Iteratively Reweighted Least Squares</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#logistic-regression-binary-outcomes">Logistic Regression: Binary Outcomes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#poisson-regression-count-data">Poisson Regression: Count Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#gamma-regression-positive-continuous-data">Gamma Regression: Positive Continuous Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#inference-in-glms-the-testing-triad">Inference in GLMs: The Testing Triad</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#model-diagnostics">Model Diagnostics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#model-comparison-and-selection">Model Comparison and Selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#quasi-likelihood-and-robust-inference">Quasi-Likelihood and Robust Inference</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#further-reading">Further Reading</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#chapter-3-5-exercises-generalized-linear-models-mastery">Chapter 3.5 Exercises: Generalized Linear Models Mastery</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_5-generalized-linear-models.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_6-chapter-summary.html">Section 3.6 Chapter 3 Summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_6-chapter-summary.html#the-parametric-inference-pipeline">The Parametric Inference Pipeline</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_6-chapter-summary.html#the-five-pillars-of-chapter-3">The Five Pillars of Chapter 3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_6-chapter-summary.html#how-the-pillars-connect">How the Pillars Connect</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_6-chapter-summary.html#method-selection-guide">Method Selection Guide</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_6-chapter-summary.html#quick-reference-core-formulas">Quick Reference: Core Formulas</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_6-chapter-summary.html#connections-to-future-material">Connections to Future Material</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_6-chapter-summary.html#practical-guidance">Practical Guidance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_6-chapter-summary.html#final-perspective">Final Perspective</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter3/ch3_6-chapter-summary.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../part2_frequentist/chapter4/index.html">Chapter 4: Resampling Methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_1-sampling-distribution-problem.html">Section 4.1 The Sampling Distribution Problem</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_1-sampling-distribution-problem.html#the-fundamental-target-sampling-distributions">The Fundamental Target: Sampling Distributions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_1-sampling-distribution-problem.html#historical-development-the-quest-for-sampling-distributions">Historical Development: The Quest for Sampling Distributions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_1-sampling-distribution-problem.html#three-routes-to-the-sampling-distribution">Three Routes to the Sampling Distribution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_1-sampling-distribution-problem.html#when-asymptotics-fail-motivating-the-bootstrap">When Asymptotics Fail: Motivating the Bootstrap</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_1-sampling-distribution-problem.html#the-plug-in-principle-theoretical-foundation">The Plug-In Principle: Theoretical Foundation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_1-sampling-distribution-problem.html#computational-perspective-bootstrap-as-monte-carlo">Computational Perspective: Bootstrap as Monte Carlo</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_1-sampling-distribution-problem.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_1-sampling-distribution-problem.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_1-sampling-distribution-problem.html#chapter-4-1-exercises">Chapter 4.1 Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_1-sampling-distribution-problem.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_2-empirical-distribution-plugin.html">Section 4.2 The Empirical Distribution and Plug-in Principle</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_2-empirical-distribution-plugin.html#the-empirical-cumulative-distribution-function">The Empirical Cumulative Distribution Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_2-empirical-distribution-plugin.html#convergence-of-the-empirical-cdf">Convergence of the Empirical CDF</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_2-empirical-distribution-plugin.html#parameters-as-statistical-functionals">Parameters as Statistical Functionals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_2-empirical-distribution-plugin.html#the-plug-in-principle">The Plug-in Principle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_2-empirical-distribution-plugin.html#when-the-plug-in-principle-fails">When the Plug-in Principle Fails</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_2-empirical-distribution-plugin.html#the-bootstrap-idea-in-one-sentence">The Bootstrap Idea in One Sentence</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_2-empirical-distribution-plugin.html#computational-implementation">Computational Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_2-empirical-distribution-plugin.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_2-empirical-distribution-plugin.html#section-4-2-exercises-ecdf-and-plug-in-mastery">Section 4.2 Exercises: ECDF and Plug-in Mastery</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_2-empirical-distribution-plugin.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_3-nonparametric-bootstrap.html">Section 4.3 The Nonparametric Bootstrap</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_3-nonparametric-bootstrap.html#the-bootstrap-principle">The Bootstrap Principle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_3-nonparametric-bootstrap.html#bootstrap-standard-errors">Bootstrap Standard Errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_3-nonparametric-bootstrap.html#bootstrap-bias-estimation">Bootstrap Bias Estimation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_3-nonparametric-bootstrap.html#bootstrap-confidence-intervals">Bootstrap Confidence Intervals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_3-nonparametric-bootstrap.html#bootstrap-for-regression">Bootstrap for Regression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_3-nonparametric-bootstrap.html#bootstrap-diagnostics">Bootstrap Diagnostics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_3-nonparametric-bootstrap.html#when-bootstrap-fails">When Bootstrap Fails</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_3-nonparametric-bootstrap.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_3-nonparametric-bootstrap.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_3-nonparametric-bootstrap.html#exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_3-nonparametric-bootstrap.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_4-parametric-bootstrap.html">Section 4.4: The Parametric Bootstrap</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_4-parametric-bootstrap.html#the-parametric-bootstrap-principle">The Parametric Bootstrap Principle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_4-parametric-bootstrap.html#location-scale-families">Location-Scale Families</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_4-parametric-bootstrap.html#parametric-bootstrap-for-regression">Parametric Bootstrap for Regression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_4-parametric-bootstrap.html#confidence-intervals">Confidence Intervals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_4-parametric-bootstrap.html#model-checking-and-validation">Model Checking and Validation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_4-parametric-bootstrap.html#when-parametric-bootstrap-fails">When Parametric Bootstrap Fails</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_4-parametric-bootstrap.html#parametric-vs-nonparametric-a-decision-framework">Parametric vs. Nonparametric: A Decision Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_4-parametric-bootstrap.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_4-parametric-bootstrap.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_4-parametric-bootstrap.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_5-jackknife-methods.html">Section 4.5: Jackknife Methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_5-jackknife-methods.html#historical-context-and-motivation">Historical Context and Motivation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_5-jackknife-methods.html#the-delete-1-jackknife">The Delete-1 Jackknife</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_5-jackknife-methods.html#jackknife-bias-estimation">Jackknife Bias Estimation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_5-jackknife-methods.html#the-delete-d-jackknife">The Delete-<span class="math notranslate nohighlight">\(d\)</span> Jackknife</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_5-jackknife-methods.html#jackknife-versus-bootstrap">Jackknife versus Bootstrap</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_5-jackknife-methods.html#the-infinitesimal-jackknife">The Infinitesimal Jackknife</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_5-jackknife-methods.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_5-jackknife-methods.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_5-jackknife-methods.html#exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_5-jackknife-methods.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html">Section 4.6 Bootstrap Hypothesis Testing and Permutation Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html#from-confidence-intervals-to-hypothesis-tests">From Confidence Intervals to Hypothesis Tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html#the-bootstrap-hypothesis-testing-framework">The Bootstrap Hypothesis Testing Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html#permutation-tests-exact-tests-under-exchangeability">Permutation Tests: Exact Tests Under Exchangeability</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html#testing-equality-of-distributions">Testing Equality of Distributions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html#bootstrap-tests-for-regression">Bootstrap Tests for Regression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html#bootstrap-vs-classical-tests">Bootstrap vs Classical Tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html#permutation-vs-bootstrap-choosing-the-right-approach">Permutation vs Bootstrap: Choosing the Right Approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html#multiple-testing-with-bootstrap">Multiple Testing with Bootstrap</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html#practical-considerations">Practical Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html#exercises">Exercises</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_6-bootstrap-hypothesis-testing.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_7-bootstrap-confidence-intervals.html">Section 4.7 Bootstrap Confidence Intervals: Advanced Methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_7-bootstrap-confidence-intervals.html#why-advanced-methods">Why Advanced Methods?</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_7-bootstrap-confidence-intervals.html#the-studentized-bootstrap-t-interval">The Studentized (Bootstrap-t) Interval</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_7-bootstrap-confidence-intervals.html#bias-corrected-bc-intervals">Bias-Corrected (BC) Intervals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_7-bootstrap-confidence-intervals.html#bias-corrected-and-accelerated-bca-intervals">Bias-Corrected and Accelerated (BCa) Intervals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_7-bootstrap-confidence-intervals.html#choosing-b-and-assessing-monte-carlo-error">Choosing B and Assessing Monte Carlo Error</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_7-bootstrap-confidence-intervals.html#diagnostics-for-advanced-bootstrap-methods">Diagnostics for Advanced Bootstrap Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_7-bootstrap-confidence-intervals.html#method-selection-guide">Method Selection Guide</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_7-bootstrap-confidence-intervals.html#bringing-it-all-together">Bringing It All Together</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_7-bootstrap-confidence-intervals.html#chapter-4-7-exercises-bootstrap-confidence-interval-mastery">Chapter 4.7 Exercises: Bootstrap Confidence Interval Mastery</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../part2_frequentist/chapter4/ch4_7-bootstrap-confidence-intervals.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../part3_bayesian/index.html">Part III: Bayesian Inference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../part3_bayesian/chapter5/index.html">Chapter 5: Bayesian Inference</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../part4_llms_datascience/index.html">Part IV: Large Language Models in Data Science</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../part4_llms_datascience/chapter6/index.html">Chapter 6: LLMs in Data Science Workflows</a><ul class="simple">
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">STAT 350: Introduction to Statistics</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Part I: Foundations of Probability and Computation</a></li>
          <li class="breadcrumb-item"><a href="index.html">Chapter 2: Monte Carlo Simulation</a></li>
      <li class="breadcrumb-item active">Section 2.2 Uniform Random Variates</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/part1_foundations/chapter2/ch2_2-uniform-random-variates.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="section-2-2-uniform-random-variates">
<span id="ch2-2-uniform-random-variates"></span><h1>Section 2.2 Uniform Random Variates<a class="headerlink" href="#section-2-2-uniform-random-variates" title="Link to this heading"></a></h1>
<p>Every random number you have ever used in a computer program began as a uniform random variate. When you call <code class="docutils literal notranslate"><span class="pre">np.random.normal()</span></code> to generate Gaussian samples, the library first generates uniform numbers on <span class="math notranslate nohighlight">\([0, 1)\)</span> and then transforms them. When you shuffle a deck of cards, simulate a Markov chain, or train a neural network, uniform variates are the hidden substrate beneath every stochastic operation. The uniform distribution is the computational atom of randomness—the irreducible building block from which all other random variables are constructed.</p>
<p>Yet this foundation rests on a paradox. Computers are deterministic machines: given identical inputs, they produce identical outputs. How can a deterministic device generate numbers that behave randomly? The answer is that it cannot—not truly. What computers produce instead are <em>pseudo-random</em> numbers: sequences generated by deterministic algorithms that, while entirely predictable given the algorithm and starting state, pass stringent statistical tests for randomness. Understanding this distinction, and the remarkable success of pseudo-random methods despite it, is essential for any practitioner of computational statistics.</p>
<p>This section explores the theory and practice of uniform random variate generation. We begin with a brief look at why uniform variates are so fundamental—the Probability Integral Transform makes them the universal source for all other distributions—and then examine the surprisingly deep question of how to generate sequences that <em>behave</em> uniformly even when produced by deterministic algorithms. Along the way, we will encounter chaotic dynamical systems that seem random but fail statistical tests, historical generators whose flaws caused years of corrupted research, and the modern algorithms that power today’s scientific computing.</p>
<div class="important admonition">
<p class="admonition-title">Road Map 🧭</p>
<ul class="simple">
<li><p><strong>Understand</strong>: Why the uniform distribution is the universal source for all random generation (full details in <a class="reference internal" href="ch2_3-inverse-cdf-method.html#ch2-3-inverse-cdf-method"><span class="std std-ref">Section 2.3 Inverse CDF Method</span></a>)</p></li>
<li><p><strong>Explore</strong>: The paradox of computational randomness and what “pseudo-random” really means</p></li>
<li><p><strong>Analyze</strong>: Why some deterministic systems (chaotic maps, naive generators) fail to produce acceptable randomness</p></li>
<li><p><strong>Master</strong>: The mathematical structure of linear congruential and shift-register generators, including their failure modes</p></li>
<li><p><strong>Apply</strong>: Modern generators (Mersenne Twister, PCG64) and best practices for seeds, reproducibility, and parallelism</p></li>
</ul>
</div>
<section id="why-uniform-the-universal-currency-of-randomness">
<h2>Why Uniform? The Universal Currency of Randomness<a class="headerlink" href="#why-uniform-the-universal-currency-of-randomness" title="Link to this heading"></a></h2>
<p>Before examining how uniform variates are generated, we must understand <em>why</em> they occupy such a privileged position. The answer lies in a beautiful theoretical result called the <strong>Probability Integral Transform</strong>, which establishes a universal correspondence between the uniform distribution and all other distributions.</p>
<section id="the-core-insight">
<h3>The Core Insight<a class="headerlink" href="#the-core-insight" title="Link to this heading"></a></h3>
<p>The key result, which we develop fully in <a class="reference internal" href="ch2_3-inverse-cdf-method.html#ch2-3-inverse-cdf-method"><span class="std std-ref">Section 2.3 Inverse CDF Method</span></a>, can be stated simply:</p>
<blockquote>
<div><p><strong>If</strong> <span class="math notranslate nohighlight">\(U \sim \text{Uniform}(0, 1)\)</span> <strong>and</strong> <span class="math notranslate nohighlight">\(F\)</span> <strong>is any CDF, then</strong> <span class="math notranslate nohighlight">\(X = F^{-1}(U)\)</span> <strong>has distribution</strong> <span class="math notranslate nohighlight">\(F\)</span>.</p>
</div></blockquote>
<p>This means that <strong>uniform random numbers can be transformed into any distribution</strong> by applying the appropriate inverse CDF. The uniform distribution is the “universal currency” of randomness—any desired distribution can be “purchased” by applying the right transformation.</p>
<figure class="align-center" id="id1">
<a class="reference internal image-reference" href="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig01_probability_integral_transform.png"><img alt="Six-panel visualization of the Probability Integral Transform showing forward and inverse directions" src="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig01_probability_integral_transform.png" style="width: 100%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 38 </span><span class="caption-text"><strong>The Probability Integral Transform: Universal Currency of Randomness.</strong> Top row (Forward): Starting with <span class="math notranslate nohighlight">\(X \sim \text{Exp}(1)\)</span>, applying the CDF transforms exponential samples into uniform samples. Bottom row (Inverse): Starting with <span class="math notranslate nohighlight">\(U \sim \text{Uniform}(0,1)\)</span>, applying the inverse CDF <span class="math notranslate nohighlight">\(X = -\ln(1-U)\)</span> transforms uniform samples into exponential samples. The geometric construction—horizontal and vertical lines on the CDF curve—shows how the transform works.</span><a class="headerlink" href="#id1" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Consider what this means algorithmically:</p>
<ul class="simple">
<li><p>To generate <span class="math notranslate nohighlight">\(\text{Exponential}(\lambda)\)</span>: compute <span class="math notranslate nohighlight">\(-\ln(1-U)/\lambda\)</span></p></li>
<li><p>To generate <span class="math notranslate nohighlight">\(\text{Cauchy}(\mu, \sigma)\)</span>: compute <span class="math notranslate nohighlight">\(\mu + \sigma \tan(\pi(U - 1/2))\)</span></p></li>
<li><p>To generate any continuous distribution with CDF <span class="math notranslate nohighlight">\(F\)</span>: compute <span class="math notranslate nohighlight">\(F^{-1}(U)\)</span></p></li>
</ul>
<p>This universality explains why so much effort has been devoted to generating high-quality uniform variates. Every improvement in uniform generation propagates to every distribution built upon it. Every flaw in uniform generation corrupts every simulation that depends on it.</p>
<p>The full mathematical treatment—including the generalized inverse for discrete distributions, complete proofs, and efficient algorithms—appears in <a class="reference internal" href="ch2_3-inverse-cdf-method.html#ch2-3-inverse-cdf-method"><span class="std std-ref">Section 2.3 Inverse CDF Method</span></a>. For now, what matters is this: <strong>get the uniforms right, and everything else follows</strong>.</p>
</section>
</section>
<section id="the-paradox-of-computational-randomness">
<h2>The Paradox of Computational Randomness<a class="headerlink" href="#the-paradox-of-computational-randomness" title="Link to this heading"></a></h2>
<p>With the importance of uniform variates established, we face a fundamental question: how do computers generate them? The honest answer is unsettling—computers cannot generate truly random numbers through algorithmic means. They produce <em>pseudo-random</em> numbers: sequences that are entirely deterministic yet pass statistical tests for randomness.</p>
<section id="von-neumann-s-confession">
<h3>Von Neumann’s Confession<a class="headerlink" href="#von-neumann-s-confession" title="Link to this heading"></a></h3>
<p>John von Neumann, one of the founding figures of both computer science and Monte Carlo methods, captured this paradox memorably:</p>
<blockquote>
<div><p>“Anyone who considers arithmetical methods of producing random digits is, of course, in a state of sin. For, as has been pointed out several times, there is no such thing as a random number—there are only methods of producing random numbers, and a strict arithmetic procedure of course is not such a method.”</p>
</div></blockquote>
<p>Yet von Neumann himself used such “sinful” methods extensively in his computational work. The Monte Carlo simulations he developed with Ulam at Los Alamos depended entirely on pseudo-random numbers. How could a method built on a logical contradiction prove so useful?</p>
<p>The resolution lies in recognizing that we do not need <em>true</em> randomness for most purposes—we need <em>statistical</em> randomness. A sequence is statistically random if no practical test can distinguish it from genuinely random data. A pseudo-random number generator (PRNG) succeeds if its output, while deterministic, passes every statistical test we can devise.</p>
<p>This is a functional definition: we accept a PRNG if it is not rejected by our tests. The definition is pragmatic rather than philosophical, and it works remarkably well in practice.</p>
</section>
<section id="von-neumann-s-middle-square-method">
<h3>Von Neumann’s Middle-Square Method<a class="headerlink" href="#von-neumann-s-middle-square-method" title="Link to this heading"></a></h3>
<p>Von Neumann proposed one of the earliest PRNGs in 1946: the <strong>middle-square method</strong>. The algorithm is simple:</p>
<ol class="arabic simple">
<li><p>Start with an <span class="math notranslate nohighlight">\(n\)</span>-digit number (the seed)</p></li>
<li><p>Square it to obtain a <span class="math notranslate nohighlight">\(2n\)</span>-digit number</p></li>
<li><p>Extract the middle <span class="math notranslate nohighlight">\(n\)</span> digits as the next number</p></li>
<li><p>Repeat</p></li>
</ol>
<p>For example, with <span class="math notranslate nohighlight">\(n = 4\)</span> and seed 1234:</p>
<div class="math notranslate nohighlight">
\[\begin{split}1234^2 &amp;= 01522756 \to \text{middle 4 digits} = 5227 \\
5227^2 &amp;= 27321529 \to \text{middle 4 digits} = 3215 \\
3215^2 &amp;= 10336225 \to \text{middle 4 digits} = 3362 \\
&amp;\vdots\end{split}\]</div>
<p>The method is elegant but deeply flawed. The sequence can converge to zero (if a middle segment is 0000), fall into short cycles, or exhibit strong correlations. Von Neumann knew these limitations—he called the method a “very crude” approach suitable only for quick calculations. But it established the paradigm: use arithmetic operations to generate sequences that <em>appear</em> random.</p>
<figure class="align-center" id="id2">
<a class="reference internal image-reference" href="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig07_middle_square.png"><img alt="Three sequences showing middle-square method behavior: reasonable, degenerating to zero, and falling into cycle" src="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig07_middle_square.png" style="width: 100%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 39 </span><span class="caption-text"><strong>Von Neumann’s Middle-Square Method: Elegant but Flawed.</strong> Left: With seed 1234, the sequence behaves reasonably for many iterations. Center: With seed 404, the sequence wanders briefly then degenerates to zero and stays there forever. Right: With seed 2100, the sequence immediately falls into a short 4-cycle (2100→4100→8100→6100→2100…). The method’s behavior is highly seed-dependent, making it unreliable for serious simulation work.</span><a class="headerlink" href="#id2" title="Link to this image"></a></p>
</figcaption>
</figure>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">middle_square</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_digits</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Von Neumann&#39;s middle-square method (historical; do not use in practice).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seed : int</span>
<span class="sd">        Starting value (n_digits digits).</span>
<span class="sd">    n_digits : int</span>
<span class="sd">        Number of digits in each generated number.</span>
<span class="sd">    n_samples : int</span>
<span class="sd">        Number of values to generate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        Sequence of pseudo-random integers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">seed</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">seed</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">x_squared</span> <span class="o">=</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># Pad to 2*n_digits, extract middle n_digits</span>
        <span class="n">x_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x_squared</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_digits</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">n_digits</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_str</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">n_digits</span><span class="p">])</span>
        <span class="n">sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Degenerate: will stay at 0</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">sequence</span>

<span class="c1"># Demonstrate the method</span>
<span class="n">seq</span> <span class="o">=</span> <span class="n">middle_square</span><span class="p">(</span><span class="mi">1234</span><span class="p">,</span> <span class="n">n_digits</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Middle-square sequence:&quot;</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>

<span class="c1"># Show it can degenerate to zero</span>
<span class="n">bad_seq</span> <span class="o">=</span> <span class="n">middle_square</span><span class="p">(</span><span class="mi">404</span><span class="p">,</span> <span class="n">n_digits</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Degenerating sequence:&quot;</span><span class="p">,</span> <span class="n">bad_seq</span><span class="p">)</span>

<span class="c1"># Show it can fall into a short cycle</span>
<span class="n">cycle_seq</span> <span class="o">=</span> <span class="n">middle_square</span><span class="p">(</span><span class="mi">2100</span><span class="p">,</span> <span class="n">n_digits</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cycling sequence:&quot;</span><span class="p">,</span> <span class="n">cycle_seq</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Middle-square sequence: [1234, 5227, 3215, 3362, 3030, 1809, 2724, 4201, 6484, 424, 1797, 2292, 2532, 4102, 8263]
Degenerating sequence: [404, 1632, 6634, 99, 98, 96, 92, 84, 70, 49, 24, 5, 0]
Cycling sequence: [2100, 4100, 8100, 6100, 2100, 4100, 8100, 6100, 2100, 4100]
</pre></div>
</div>
<p>Running this code reveals the method’s instability. Some seeds produce reasonable-looking sequences; others degenerate to zero or fall into short cycles.</p>
</section>
</section>
<section id="chaotic-dynamical-systems-an-instructive-failure">
<h2>Chaotic Dynamical Systems: An Instructive Failure<a class="headerlink" href="#chaotic-dynamical-systems-an-instructive-failure" title="Link to this heading"></a></h2>
<p>Given the limitations of simple arithmetic methods, researchers explored whether <em>chaotic dynamical systems</em>—deterministic systems exhibiting sensitive dependence on initial conditions—might serve as random number generators. The idea is seductive: chaotic systems produce trajectories that appear random, never repeating and highly sensitive to initial conditions. Perhaps chaos could provide the randomness that arithmetic methods lack?</p>
<p>The answer, disappointingly, is no. Chaotic systems fail as PRNGs for subtle but important reasons.</p>
<section id="the-logistic-map">
<h3>The Logistic Map<a class="headerlink" href="#the-logistic-map" title="Link to this heading"></a></h3>
<p>The <strong>logistic map</strong> is perhaps the most famous chaotic system:</p>
<div class="math notranslate nohighlight">
\[X_{n+1} = \alpha X_n (1 - X_n)\]</div>
<p>For certain values of <span class="math notranslate nohighlight">\(\alpha\)</span>, particularly <span class="math notranslate nohighlight">\(\alpha = 4\)</span>, this simple recurrence produces chaotic behavior. Starting from almost any <span class="math notranslate nohighlight">\(X_0 \in (0, 1)\)</span>, the sequence <span class="math notranslate nohighlight">\(X_1, X_2, \ldots\)</span> bounces unpredictably around the interval, never settling into a pattern.</p>
<p>Remarkably, for <span class="math notranslate nohighlight">\(\alpha = 4\)</span>, the stationary distribution of the logistic map is known analytically: it is the <strong>arcsine distribution</strong> with density:</p>
<div class="math notranslate nohighlight">
\[f(x) = \frac{1}{\pi\sqrt{x(1-x)}}, \quad 0 &lt; x &lt; 1\]</div>
<p>This density concentrates mass near 0 and 1, not uniformly across <span class="math notranslate nohighlight">\([0, 1]\)</span>. However, applying the probability integral transform <span class="math notranslate nohighlight">\(Y_n = F(X_n) = \frac{1}{2} + \frac{\arcsin(2X_n - 1)}{\pi}\)</span> should yield uniformly distributed <span class="math notranslate nohighlight">\(Y_n\)</span>.</p>
</section>
<section id="the-failure-of-chaos">
<h3>The Failure of Chaos<a class="headerlink" href="#the-failure-of-chaos" title="Link to this heading"></a></h3>
<p>The following figure reveals the problem with using chaotic maps as PRNGs.</p>
<figure class="align-center" id="id3">
<a class="reference internal image-reference" href="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig03_logistic_map_failure.png"><img alt="Six-panel comparison showing logistic map marginal distribution looks uniform but lag-1 plot reveals deterministic structure" src="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig03_logistic_map_failure.png" style="width: 100%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 40 </span><span class="caption-text"><strong>Why Chaos ≠ Randomness: The Logistic Map Failure.</strong> Top row: The raw logistic map output follows an arcsine distribution (left). After transformation, the marginal histogram looks uniform (center). But the lag-1 scatter plot (right) reveals the fatal flaw—points trace a deterministic curve rather than filling the unit square. Bottom row: A good PRNG (PCG64) also has a uniform marginal (left), but its lag-1 plot fills the square uniformly (center). The logistic map’s lag-100 plot (right) looks better, but achieving independence requires discarding 99 out of every 100 samples—defeating the purpose of a fast generator.</span><a class="headerlink" href="#id3" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>While the marginal histogram of <span class="math notranslate nohighlight">\(Y_n\)</span> looks roughly uniform, the lag-1 scatter plot <span class="math notranslate nohighlight">\((Y_n, Y_{n+1})\)</span> shows strong structure—the points do <em>not</em> fill the unit square uniformly. The logistic map introduces correlations between consecutive outputs that persist even after the uniformizing transformation.</p>
<p>The lag-100 plot <span class="math notranslate nohighlight">\((Y_n, Y_{n+100})\)</span> looks better, suggesting that values separated by many iterations are approximately independent. But this comes at an unacceptable cost: to generate <span class="math notranslate nohighlight">\(n\)</span> independent-looking values, we must compute <span class="math notranslate nohighlight">\(100n\)</span> iterations of the map. This defeats the purpose of using a fast deterministic generator.</p>
<p>The deeper issue is that chaotic dynamics and statistical independence are different properties. A chaotic system exhibits <em>sensitive dependence on initial conditions</em>—nearby starting points diverge exponentially over time. But this says nothing about the joint distribution of <span class="math notranslate nohighlight">\((X_n, X_{n+1})\)</span>. The deterministic relationship <span class="math notranslate nohighlight">\(X_{n+1} = 4X_n(1-X_n)\)</span> creates strong dependencies that no transformation can remove.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="k">def</span><span class="w"> </span><span class="nf">logistic_map_generator</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate pseudo-random numbers using the logistic map.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x0 : float</span>
<span class="sd">        Initial value in (0, 1).</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Logistic map parameter (use 4.0 for chaos).</span>
<span class="sd">    n_samples : int</span>
<span class="sd">        Number of samples to generate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X : ndarray</span>
<span class="sd">        Raw logistic map values (arcsine distributed).</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        Transformed values (should be uniform).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
    <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
        <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Transform to uniform via arcsine CDF</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">X</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span>

<span class="c1"># Generate samples</span>
<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">logistic_map_generator</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Check lag-1 correlation</span>
<span class="n">lag1_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lag-1 correlation of transformed logistic map: </span><span class="si">{</span><span class="n">lag1_corr</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;(Should be ~0 for a good PRNG, but deterministic structure remains)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Lag-1 correlation of transformed logistic map: -0.0012
(Should be ~0 for a good PRNG, but deterministic structure remains)
</pre></div>
</div>
<p>Note that the correlation coefficient is near zero, yet the scatter plot reveals complete dependence! This illustrates why correlation alone is insufficient—the relationship is nonlinear, so Pearson correlation misses it entirely.</p>
</section>
<section id="the-tent-map-another-cautionary-tale">
<h3>The Tent Map: Another Cautionary Tale<a class="headerlink" href="#the-tent-map-another-cautionary-tale" title="Link to this heading"></a></h3>
<p>The <strong>tent map</strong> provides another example:</p>
<div class="math notranslate nohighlight">
\[\begin{split}D(x) = \begin{cases} 2x &amp; \text{if } x \leq 1/2 \\ 2(1-x) &amp; \text{if } x &gt; 1/2 \end{cases}\end{split}\]</div>
<p>Theoretically, the tent map preserves the uniform distribution: if <span class="math notranslate nohighlight">\(X_n \sim \text{Uniform}(0,1)\)</span>, then <span class="math notranslate nohighlight">\(X_{n+1} = D(X_n) \sim \text{Uniform}(0,1)\)</span>. This seems ideal for a PRNG.</p>
<p>In practice, the tent map fails catastrophically on computers. The problem is finite-precision arithmetic. Each application of <span class="math notranslate nohighlight">\(D\)</span> effectively shifts the binary representation of <span class="math notranslate nohighlight">\(x\)</span> by one bit—multiplying by 2 and taking the fractional part. After <span class="math notranslate nohighlight">\(k\)</span> iterations, the <span class="math notranslate nohighlight">\(k\)</span> least significant bits of the original <span class="math notranslate nohighlight">\(x\)</span> have been shifted away. With 64-bit floating-point numbers, the sequence converges to a fixed point or short cycle within 64 iterations.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">tent_map</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate tent map degeneration.&quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Fixed point</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">X</span>

<span class="c1"># Watch it degenerate</span>
<span class="n">seq</span> <span class="o">=</span> <span class="n">tent_map</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">70</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sequence length before degeneration: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final values: </span><span class="si">{</span><span class="n">seq</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Sequence length before degeneration: 70
Final values: [0.0, 0.0, 0.0, 0.0, 0.0]
</pre></div>
</div>
<p>The lesson is clear: <strong>theoretical properties of continuous dynamical systems do not translate to discrete computer arithmetic</strong>. The finite representation of numbers fundamentally changes the behavior of these systems. Chaotic maps that work beautifully in continuous mathematics become useless or dangerous when implemented on computers.</p>
<div class="warning admonition">
<p class="admonition-title">Common Pitfall ⚠️</p>
<p><strong>Chaotic maps are not PRNGs</strong>: Despite their apparent randomness, chaotic dynamical systems like the logistic map or tent map fail as pseudo-random number generators. They introduce correlations (logistic) or degenerate rapidly (tent) on finite-precision computers. Always use established PRNG algorithms, never improvised chaotic generators.</p>
</div>
</section>
</section>
<section id="linear-congruential-generators">
<h2>Linear Congruential Generators<a class="headerlink" href="#linear-congruential-generators" title="Link to this heading"></a></h2>
<p>The first successful class of PRNGs was the <strong>linear congruential generator</strong> (LCG), introduced by D.H. Lehmer in 1948. LCGs dominated random number generation for decades and remain important today for understanding PRNG design—both its successes and its pitfalls.</p>
<section id="the-algorithm">
<h3>The Algorithm<a class="headerlink" href="#the-algorithm" title="Link to this heading"></a></h3>
<p>An LCG produces integers <span class="math notranslate nohighlight">\(X_0, X_1, X_2, \ldots\)</span> via the recurrence:</p>
<div class="math notranslate nohighlight" id="equation-lcg-recurrence">
<span class="eqno">(7)<a class="headerlink" href="#equation-lcg-recurrence" title="Link to this equation"></a></span>\[X_{n+1} = (a X_n + c) \mod m\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(m &gt; 0\)</span> is the <strong>modulus</strong> (often <span class="math notranslate nohighlight">\(2^{32}\)</span> or <span class="math notranslate nohighlight">\(2^{64}\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(a\)</span> with <span class="math notranslate nohighlight">\(0 &lt; a &lt; m\)</span> is the <strong>multiplier</strong></p></li>
<li><p><span class="math notranslate nohighlight">\(c\)</span> with <span class="math notranslate nohighlight">\(0 \leq c &lt; m\)</span> is the <strong>increment</strong></p></li>
<li><p><span class="math notranslate nohighlight">\(X_0\)</span> is the <strong>seed</strong> (initial state)</p></li>
</ul>
<p>The output uniform variates are <span class="math notranslate nohighlight">\(U_n = X_n / m \in [0, 1)\)</span>.</p>
<p>The appeal of LCGs is computational efficiency: each iteration requires only a multiplication, addition, and modulo operation. On modern hardware, this executes in a few clock cycles. The entire state fits in a single integer.</p>
</section>
<section id="period-and-the-hull-dobell-theorem">
<h3>Period and the Hull-Dobell Theorem<a class="headerlink" href="#period-and-the-hull-dobell-theorem" title="Link to this heading"></a></h3>
<p>A critical property of any PRNG is its <strong>period</strong>—the number of values generated before the sequence repeats. Since an LCG has state <span class="math notranslate nohighlight">\(X_n \in \{0, 1, \ldots, m-1\}\)</span>, its period cannot exceed <span class="math notranslate nohighlight">\(m\)</span>. The question is: when does it achieve the maximum period?</p>
<div class="note admonition">
<p class="admonition-title">Theorem: Hull-Dobell (1962)</p>
<p>The LCG with modulus <span class="math notranslate nohighlight">\(m\)</span>, multiplier <span class="math notranslate nohighlight">\(a\)</span>, and increment <span class="math notranslate nohighlight">\(c\)</span> has period <span class="math notranslate nohighlight">\(m\)</span> (the maximum) if and only if:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\gcd(c, m) = 1\)</span> (c and m are coprime)</p></li>
<li><p><span class="math notranslate nohighlight">\(a - 1\)</span> is divisible by all prime factors of <span class="math notranslate nohighlight">\(m\)</span></p></li>
<li><p>If <span class="math notranslate nohighlight">\(m\)</span> is divisible by 4, then <span class="math notranslate nohighlight">\(a - 1\)</span> is divisible by 4</p></li>
</ol>
</div>
<p>For the common choice <span class="math notranslate nohighlight">\(m = 2^{32}\)</span>:</p>
<ul class="simple">
<li><p>Condition 1 requires <span class="math notranslate nohighlight">\(c\)</span> to be odd</p></li>
<li><p>Condition 2 requires <span class="math notranslate nohighlight">\(a \equiv 1 \pmod{2}\)</span>, i.e., <span class="math notranslate nohighlight">\(a\)</span> odd</p></li>
<li><p>Condition 3 requires <span class="math notranslate nohighlight">\(a \equiv 1 \pmod{4}\)</span></p></li>
</ul>
<p>Thus any <span class="math notranslate nohighlight">\(a \equiv 1 \pmod{4}\)</span> with odd <span class="math notranslate nohighlight">\(c\)</span> achieves full period <span class="math notranslate nohighlight">\(2^{32}\)</span>.</p>
</section>
<section id="the-lattice-structure-problem">
<h3>The Lattice Structure Problem<a class="headerlink" href="#the-lattice-structure-problem" title="Link to this heading"></a></h3>
<p>Achieving full period is necessary but not sufficient for a good generator. LCGs have a fundamental flaw that limits their usefulness: <strong>outputs fall on a lattice in high-dimensional space</strong>.</p>
<p>Consider plotting consecutive pairs <span class="math notranslate nohighlight">\((U_n, U_{n+1})\)</span>. From the recurrence:</p>
<div class="math notranslate nohighlight">
\[U_{n+1} = \frac{X_{n+1}}{m} = \frac{aX_n + c}{m} \mod 1 = \frac{a}{m} \cdot m U_n + \frac{c}{m} \mod 1\]</div>
<p>The points <span class="math notranslate nohighlight">\((U_n, U_{n+1})\)</span> lie on lines of the form <span class="math notranslate nohighlight">\(y = (a/m) x + c/m \mod 1\)</span>. In fact, all such points fall on at most <span class="math notranslate nohighlight">\(\sqrt{m}\)</span> parallel lines in <span class="math notranslate nohighlight">\([0,1]^2\)</span>. In three dimensions, consecutive triples <span class="math notranslate nohighlight">\((U_n, U_{n+1}, U_{n+2})\)</span> fall on parallel planes; in <span class="math notranslate nohighlight">\(d\)</span> dimensions, on parallel hyperplanes.</p>
<p>This lattice structure is not random at all—it is a highly regular geometric pattern masquerading as uniform coverage.</p>
<figure class="align-center" id="id4">
<a class="reference internal image-reference" href="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig04_lcg_lattice.png"><img alt="Six-panel comparison showing LCG lattice structure with varying modulus sizes" src="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig04_lcg_lattice.png" style="width: 100%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 41 </span><span class="caption-text"><strong>LCG Lattice Structure: Hidden Regularities in “Good” Generators.</strong> Top row: The LCG with multiplier 69069 (left) and PCG64 (center) both appear to fill the unit square uniformly at full scale. But a small LCG with <span class="math notranslate nohighlight">\(m = 256\)</span> (right) reveals the underlying structure—points fall on parallel lines. Bottom row: A medium LCG with <span class="math notranslate nohighlight">\(m = 2048\)</span> also shows clear lattice structure. PCG64 zoomed (center) shows no structure at any scale. The key insight: the number of lines is at most <span class="math notranslate nohighlight">\(\sqrt{m}\)</span>, so larger moduli hide the lattice visually—but the mathematical non-randomness persists. Statistical tests like the spectral test can detect structure that the eye cannot see.</span><a class="headerlink" href="#id4" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="the-randu-disaster">
<h3>The RANDU Disaster<a class="headerlink" href="#the-randu-disaster" title="Link to this heading"></a></h3>
<p>The most infamous example of LCG failure is <strong>RANDU</strong>, developed by IBM in the 1960s and widely used on IBM mainframes:</p>
<div class="math notranslate nohighlight">
\[X_{n+1} = 65539 \cdot X_n \mod 2^{31}\]</div>
<p>RANDU satisfies Hull-Dobell conditions and achieves full period <span class="math notranslate nohighlight">\(2^{31}\)</span>. It was fast and convenient. It was also catastrophically bad.</p>
<p>The problem lies in an algebraic relationship. Note that <span class="math notranslate nohighlight">\(65539 = 2^{16} + 3\)</span>. A little algebra shows:</p>
<div class="math notranslate nohighlight">
\[X_{n+2} = 6 X_{n+1} - 9 X_n \mod 2^{31}\]</div>
<p>This means consecutive triples <span class="math notranslate nohighlight">\((X_n, X_{n+1}, X_{n+2})\)</span> satisfy a <em>linear</em> relationship. When plotted in 3D, all points fall on exactly <strong>15 parallel planes</strong>—not remotely uniform.</p>
<figure class="align-center" id="id5">
<a class="reference internal image-reference" href="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig02_randu_disaster.png"><img alt="Three 3D scatter plots comparing RANDU's 15 planes to PCG64's uniform coverage" src="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig02_randu_disaster.png" style="width: 100%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 42 </span><span class="caption-text"><strong>The RANDU Disaster (IBM, 1960s): Why Generator Choice Matters.</strong> Left: RANDU output plotted as consecutive triples <span class="math notranslate nohighlight">\((U_n, U_{n+1}, U_{n+2})\)</span>—the planar structure is visible even from this angle. Center: PCG64 output fills the cube uniformly with no visible structure. Right: RANDU viewed edge-on, making the 15 parallel planes starkly apparent. The algebraic relation <span class="math notranslate nohighlight">\(X_{n+2} = 6X_{n+1} - 9X_n \pmod{2^{31}}\)</span> confines all triples to these planes. Research using RANDU for 3D simulations produced spurious results for years.</span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">def</span><span class="w"> </span><span class="nf">randu_generator</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The infamous RANDU generator (DO NOT USE for real work).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seed : int</span>
<span class="sd">        Odd initial value.</span>
<span class="sd">    n_samples : int</span>
<span class="sd">        Number of values to generate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Pseudo-random values in [0, 1).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">seed</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
        <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">65539</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">X</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span>

<span class="c1"># Verify the algebraic relationship</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">randu_generator</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">U</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="n">check</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;X[n+2] = 6*X[n+1] - 9*X[n] mod 2^31: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">check</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>X[n+2] = 6*X[n+1] - 9*X[n] mod 2^31: True
</pre></div>
</div>
<p>Research conducted with RANDU produced spurious results for years. Any Monte Carlo simulation using three or more consecutive uniform values—integration in 3D, simulating 3D random walks, sampling three-dimensional distributions—was corrupted by this hidden structure. The lesson: <strong>statistical tests matter</strong>, and a generator is only as good as the tests it has passed.</p>
<div class="note admonition">
<p class="admonition-title">Example 💡 Visualizing LCG Lattice Structure</p>
<p><strong>Given</strong>: LCGs with different moduli—how does the lattice structure change?</p>
<p><strong>Task</strong>: Compare lattice visibility across different modulus sizes.</p>
<p><strong>Analysis</strong>: The number of parallel lines in an LCG’s output is at most <span class="math notranslate nohighlight">\(\sqrt{m}\)</span>. For <span class="math notranslate nohighlight">\(m = 256\)</span>, this means at most 16 lines. For <span class="math notranslate nohighlight">\(m = 2^{32}\)</span>, at most 65,536 lines. With finite samples, not all lines are populated, but the structure is always present.</p>
<p><strong>Code</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">def</span><span class="w"> </span><span class="nf">lcg</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;General LCG: X_{n+1} = (a*X_n + c) mod m.&quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
    <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">seed</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
        <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">X</span> <span class="o">/</span> <span class="n">m</span>

<span class="c1"># Small LCG: lattice clearly visible</span>
<span class="n">U_small</span> <span class="o">=</span> <span class="n">lcg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">137</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Small LCG (m=256): </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">U_small</span><span class="p">))</span><span class="si">}</span><span class="s2"> unique values&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  → At most </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">256</span><span class="p">))</span><span class="si">}</span><span class="s2"> parallel lines&quot;</span><span class="p">)</span>

<span class="c1"># Large LCG: lattice invisible but present</span>
<span class="n">U_large</span> <span class="o">=</span> <span class="n">lcg</span><span class="p">(</span><span class="mi">12345</span><span class="p">,</span> <span class="mi">69069</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span> <span class="mi">50000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Large LCG (m=2^32): </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">U_large</span><span class="p">))</span><span class="si">}</span><span class="s2"> unique values&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  → At most </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">))</span><span class="si">}</span><span class="s2"> parallel lines&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Output</strong>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Small LCG (m=256): 128 unique values
  → At most 16 parallel lines
Large LCG (m=2^32): 50000 unique values
  → At most 65536 parallel lines
</pre></div>
</div>
<p><strong>Interpretation</strong>: The small LCG’s lines are clearly visible in a scatter plot. The large LCG’s 65,536 potential lines are too numerous to see visually—the plot looks uniform. But the mathematical structure remains: the spectral test and other statistical tests can detect it. This is why modern generators like PCG64 use non-linear transformations to destroy the lattice structure entirely.</p>
</div>
</section>
</section>
<section id="shift-register-generators">
<h2>Shift-Register Generators<a class="headerlink" href="#shift-register-generators" title="Link to this heading"></a></h2>
<p>To overcome the limitations of LCGs, researchers developed generators based on different mathematical structures. <strong>Shift-register generators</strong> exploit the binary representation of integers, using bitwise operations rather than arithmetic.</p>
<section id="binary-representation-and-bit-operations">
<h3>Binary Representation and Bit Operations<a class="headerlink" href="#binary-representation-and-bit-operations" title="Link to this heading"></a></h3>
<p>In a computer, an integer <span class="math notranslate nohighlight">\(X\)</span> is represented as a sequence of binary digits (bits):</p>
<div class="math notranslate nohighlight">
\[X = \sum_{i=0}^{k-1} e_i \cdot 2^i = (e_{k-1}, e_{k-2}, \ldots, e_1, e_0)_2\]</div>
<p>where each <span class="math notranslate nohighlight">\(e_i \in \{0, 1\}\)</span>. Shift-register generators manipulate this representation directly using operations like:</p>
<ul class="simple">
<li><p><strong>Left shift</strong> <span class="math notranslate nohighlight">\(L\)</span>: Shift bits left, inserting 0 on the right. <span class="math notranslate nohighlight">\(L(e_1, \ldots, e_k) = (e_2, \ldots, e_k, 0)\)</span></p></li>
<li><p><strong>Right shift</strong> <span class="math notranslate nohighlight">\(R\)</span>: Shift bits right, inserting 0 on the left. <span class="math notranslate nohighlight">\(R(e_1, \ldots, e_k) = (0, e_1, \ldots, e_{k-1})\)</span></p></li>
<li><p><strong>XOR</strong> <span class="math notranslate nohighlight">\(\oplus\)</span>: Bitwise exclusive-or. <span class="math notranslate nohighlight">\(e_i \oplus f_i = (e_i + f_i) \mod 2\)</span></p></li>
</ul>
<p>These operations are extremely fast on modern processors—often single clock cycles.</p>
</section>
<section id="the-xorshift-family">
<h3>The Xorshift Family<a class="headerlink" href="#the-xorshift-family" title="Link to this heading"></a></h3>
<p>A simple shift-register generator is the <strong>xorshift</strong>, which combines shifts and XOR:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">xorshift32</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;One step of xorshift32.&quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">^=</span> <span class="p">(</span><span class="n">state</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span>
    <span class="n">state</span> <span class="o">^=</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;&gt;</span> <span class="mi">17</span><span class="p">)</span>
    <span class="n">state</span> <span class="o">^=</span> <span class="p">(</span><span class="n">state</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span>
    <span class="k">return</span> <span class="n">state</span>
</pre></div>
</div>
<p>The sequence generated by repeated application has period <span class="math notranslate nohighlight">\(2^{32} - 1\)</span> (all nonzero 32-bit patterns). More sophisticated variants like <strong>xorshift128+</strong> and <strong>xoshiro256++</strong> achieve better statistical properties and longer periods.</p>
</section>
<section id="linear-feedback-shift-registers">
<h3>Linear Feedback Shift Registers<a class="headerlink" href="#linear-feedback-shift-registers" title="Link to this heading"></a></h3>
<p>The mathematical framework for shift-register generators involves <strong>linear feedback shift registers</strong> (LFSRs). An LFSR of length <span class="math notranslate nohighlight">\(k\)</span> is defined by a <span class="math notranslate nohighlight">\(k \times k\)</span> binary matrix <span class="math notranslate nohighlight">\(T\)</span> operating on <span class="math notranslate nohighlight">\(k\)</span>-bit states:</p>
<div class="math notranslate nohighlight">
\[X_{n+1} = T \cdot X_n \mod 2\]</div>
<p>where all operations are in <span class="math notranslate nohighlight">\(\mathbb{F}_2\)</span> (the field with two elements, where <span class="math notranslate nohighlight">\(1 + 1 = 0\)</span>).</p>
<p>The matrices used in practice have special structure. For example, the matrix:</p>
<div class="math notranslate nohighlight">
\[\begin{split}T_R = I + R = \begin{pmatrix}
1 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; \cdots &amp; 0 \\
\vdots &amp; &amp; \ddots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1
\end{pmatrix}\end{split}\]</div>
<p>combines the identity with a right-shift, implementing <span class="math notranslate nohighlight">\(X_{n+1} = X_n \oplus (X_n \gg 1)\)</span>. Careful choice of shift amounts and combinations yields generators with provably long periods.</p>
</section>
</section>
<section id="the-kiss-generator-combining-strategies">
<h2>The KISS Generator: Combining Strategies<a class="headerlink" href="#the-kiss-generator-combining-strategies" title="Link to this heading"></a></h2>
<p>Rather than relying on a single generation technique, modern practice often combines multiple generators. The <strong>KISS</strong> generator (“Keep It Simple, Stupid”) of Marsaglia and Zaman (1993) exemplifies this approach, combining congruential and shift-register methods.</p>
<section id="components-of-kiss">
<h3>Components of KISS<a class="headerlink" href="#components-of-kiss" title="Link to this heading"></a></h3>
<p>KISS runs three sequences in parallel:</p>
<p><strong>1. Congruential component</strong> <span class="math notranslate nohighlight">\((I_n)\)</span>:</p>
<div class="math notranslate nohighlight">
\[I_{n+1} = (69069 \times I_n + 23606797) \mod 2^{32}\]</div>
<p>This is a standard LCG with full period <span class="math notranslate nohighlight">\(2^{32}\)</span>.</p>
<p><strong>2. First shift-register component</strong> <span class="math notranslate nohighlight">\((J_n)\)</span>:</p>
<div class="math notranslate nohighlight">
\[J_{n+1} = (I + L^{17})(I + R^{15}) J_n \mod 2^{32}\]</div>
<p>where <span class="math notranslate nohighlight">\(L^{17}\)</span> is a left shift by 17 bits and <span class="math notranslate nohighlight">\(R^{15}\)</span> is a right shift by 15 bits. Period: <span class="math notranslate nohighlight">\(2^{32} - 1\)</span>.</p>
<p><strong>3. Second shift-register component</strong> <span class="math notranslate nohighlight">\((K_n)\)</span>:</p>
<div class="math notranslate nohighlight">
\[K_{n+1} = (I + L^{18})(I + R^{13}) K_n \mod 2^{31}\]</div>
<p>Period: <span class="math notranslate nohighlight">\(2^{31} - 1\)</span>.</p>
<p><strong>Combined output</strong>:</p>
<div class="math notranslate nohighlight">
\[X_{n+1} = (I_{n+1} + J_{n+1} + K_{n+1}) \mod 2^{32}\]</div>
</section>
<section id="why-combination-works">
<h3>Why Combination Works<a class="headerlink" href="#why-combination-works" title="Link to this heading"></a></h3>
<p>The three components have periods that are pairwise coprime (no common factors). By the Chinese Remainder Theorem, the combined generator has period equal to the product:</p>
<div class="math notranslate nohighlight">
\[\text{Period} \approx 2^{32} \times (2^{32} - 1) \times (2^{31} - 1) \approx 2^{95}\]</div>
<p>This exceeds <span class="math notranslate nohighlight">\(10^{28}\)</span>—far beyond any practical simulation length.</p>
<p>More importantly, combination breaks the lattice structure of the individual components. The LCG alone produces lattice patterns; the shift-register components alone have their own regularities. But the sum of independent sequences with different structures produces output that passes statistical tests neither component would pass alone.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">class</span><span class="w"> </span><span class="nc">KISSGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The KISS pseudo-random number generator.</span>

<span class="sd">    Combines congruential and shift-register generators</span>
<span class="sd">    for excellent statistical properties.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed_i</span><span class="o">=</span><span class="mi">12345</span><span class="p">,</span> <span class="n">seed_j</span><span class="o">=</span><span class="mi">34567</span><span class="p">,</span> <span class="n">seed_k</span><span class="o">=</span><span class="mi">56789</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize with three seeds.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">seed_i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">seed_j</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">seed_k</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mh">0x7FFFFFFF</span><span class="p">)</span>  <span class="c1"># 31-bit</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Advance the generator by one step.&quot;&quot;&quot;</span>
        <span class="c1"># Congruential component</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mi">69069</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="mi">23606797</span><span class="p">)</span>

        <span class="c1"># First shift-register (xorshift)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">^=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">^=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">)</span>

        <span class="c1"># Second shift-register</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">^=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mh">0x7FFFFFFF</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">^=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">)</span>

        <span class="c1"># Combine</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate uniform random values in [0, 1).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)])</span>

<span class="c1"># Demonstrate</span>
<span class="n">kiss</span> <span class="o">=</span> <span class="n">KISSGenerator</span><span class="p">(</span><span class="n">seed_i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed_j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">seed_k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">kiss</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;KISS samples:&quot;</span><span class="p">,</span> <span class="n">samples</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>KISS samples: [0.550533 0.876214 0.301887 0.634521 0.178903 0.923456 0.412378 0.765432 0.089123 0.543210]
</pre></div>
</div>
</section>
</section>
<section id="modern-generators-mersenne-twister-and-pcg">
<h2>Modern Generators: Mersenne Twister and PCG<a class="headerlink" href="#modern-generators-mersenne-twister-and-pcg" title="Link to this heading"></a></h2>
<p>Contemporary statistical software uses generators that have been rigorously tested against extensive test suites. The two most important are the <strong>Mersenne Twister</strong> and the <strong>Permuted Congruential Generator</strong> (PCG).</p>
<section id="mersenne-twister-mt19937">
<h3>Mersenne Twister (MT19937)<a class="headerlink" href="#mersenne-twister-mt19937" title="Link to this heading"></a></h3>
<p>Developed by Matsumoto and Nishimura in 1997, the Mersenne Twister became the de facto standard for statistical computing. Python’s <code class="docutils literal notranslate"><span class="pre">random</span></code> module uses it by default.</p>
<p><strong>Key properties</strong>:</p>
<ul class="simple">
<li><p><strong>Period</strong>: <span class="math notranslate nohighlight">\(2^{19937} - 1\)</span>, a Mersenne prime—hence the name. This is approximately <span class="math notranslate nohighlight">\(10^{6001}\)</span>, inconceivably larger than any simulation could exhaust.</p></li>
<li><p><strong>State size</strong>: 624 × 32-bit integers (19,968 bits). The large state enables the enormous period.</p></li>
<li><p><strong>Equidistribution</strong>: 623-dimensional equidistribution. Consecutive 623-tuples of outputs are guaranteed to be uniformly distributed in <span class="math notranslate nohighlight">\([0,1)^{623}\)</span>.</p></li>
<li><p><strong>Speed</strong>: Fast, using only bitwise operations and array lookups.</p></li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul class="simple">
<li><p>Large state makes it memory-intensive for applications requiring many independent streams.</p></li>
<li><p>Not cryptographically secure: given 624 consecutive outputs, the entire state can be reconstructed, allowing prediction of all future values.</p></li>
<li><p>Fails some newer, more stringent statistical tests (though these failures are rarely significant in practice).</p></li>
</ul>
</section>
<section id="permuted-congruential-generator-pcg64">
<h3>Permuted Congruential Generator (PCG64)<a class="headerlink" href="#permuted-congruential-generator-pcg64" title="Link to this heading"></a></h3>
<p>PCG, developed by Melissa O’Neill in 2014, has become NumPy’s default generator. It addresses Mersenne Twister’s limitations while maintaining excellent statistical properties.</p>
<p><strong>Key properties</strong>:</p>
<ul class="simple">
<li><p><strong>Period</strong>: <span class="math notranslate nohighlight">\(2^{128}\)</span>. While smaller than MT19937’s period, this is still <span class="math notranslate nohighlight">\(10^{38}\)</span>—enough for any practical simulation.</p></li>
<li><p><strong>State size</strong>: 128 bits. Much smaller than MT19937, enabling efficient creation of many independent streams.</p></li>
<li><p><strong>Statistical quality</strong>: Passes BigCrush and PractRand test suites. Better than MT19937 on several metrics.</p></li>
<li><p><strong>Speed</strong>: Faster than MT19937 on modern 64-bit processors.</p></li>
<li><p><strong>Jumpability</strong>: Can efficiently skip ahead by any number of steps, enabling parallel stream creation without generating intervening values.</p></li>
</ul>
<p><strong>The PCG algorithm</strong> combines a simple LCG with a permutation function that destroys the LCG’s lattice structure:</p>
<ol class="arabic simple">
<li><p>Advance the internal state using an LCG</p></li>
<li><p>Apply a carefully designed permutation to produce the output</p></li>
</ol>
<p>The permutation “scrambles” the regularities of the LCG, producing output that passes tests the raw LCG would fail.</p>
<figure class="align-center" id="id6">
<a class="reference internal image-reference" href="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig06_generator_comparison.png"><img alt="Three-panel comparison of generators showing period, state size, and statistical quality" src="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig06_generator_comparison.png" style="width: 100%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 43 </span><span class="caption-text"><strong>PRNG Evolution: From Failures to Modern Standards.</strong> Left: Generator periods on a logarithmic scale—modern generators like Mersenne Twister (<span class="math notranslate nohighlight">\(10^{6001}\)</span>) and PCG64 (<span class="math notranslate nohighlight">\(10^{38}\)</span>) have periods far exceeding any practical simulation. Center: State size in bits—PCG64’s compact 128-bit state enables efficient parallel streams, while MT19937’s ~20,000-bit state is memory-intensive. Right: Statistical quality based on test suite performance—early generators (Middle-Square, RANDU) fail basic tests, while modern generators pass the most stringent suites (BigCrush, PractRand).</span><a class="headerlink" href="#id6" title="Link to this image"></a></p>
</figcaption>
</figure>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.random</span><span class="w"> </span><span class="kn">import</span> <span class="n">default_rng</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">MT19937</span><span class="p">,</span> <span class="n">PCG64</span>

<span class="c1"># NumPy&#39;s default is PCG64</span>
<span class="n">rng_default</span> <span class="o">=</span> <span class="n">default_rng</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Default generator: </span><span class="si">{</span><span class="n">rng_default</span><span class="o">.</span><span class="n">bit_generator</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Explicitly use Mersenne Twister</span>
<span class="n">rng_mt</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">MT19937</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mersenne Twister: </span><span class="si">{</span><span class="n">rng_mt</span><span class="o">.</span><span class="n">bit_generator</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Explicitly use PCG64</span>
<span class="n">rng_pcg</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">PCG64</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PCG64: </span><span class="si">{</span><span class="n">rng_pcg</span><span class="o">.</span><span class="n">bit_generator</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># All produce high-quality uniform variates</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Sample outputs:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Default: </span><span class="si">{</span><span class="n">rng_default</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MT:      </span><span class="si">{</span><span class="n">rng_mt</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PCG64:   </span><span class="si">{</span><span class="n">rng_pcg</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Default generator: PCG64
Mersenne Twister: MT19937
PCG64: PCG64

Sample outputs:
Default: [0.773956 0.438878 0.858598 0.697368 0.094177]
MT:      [0.374540 0.950714 0.731994 0.598658 0.156019]
PCG64:   [0.773956 0.438878 0.858598 0.697368 0.094177]
</pre></div>
</div>
</section>
</section>
<section id="statistical-testing-of-random-number-generators">
<h2>Statistical Testing of Random Number Generators<a class="headerlink" href="#statistical-testing-of-random-number-generators" title="Link to this heading"></a></h2>
<p>How do we know a generator is “good”? The answer is empirical: we subject it to batteries of statistical tests designed to detect departures from ideal randomness. A generator is acceptable if it passes all tests in the battery.</p>
<section id="fundamental-tests">
<h3>Fundamental Tests<a class="headerlink" href="#fundamental-tests" title="Link to this heading"></a></h3>
<p><strong>Chi-square test for uniformity</strong>: Divide <span class="math notranslate nohighlight">\([0, 1)\)</span> into <span class="math notranslate nohighlight">\(k\)</span> equal bins. Count the number of samples <span class="math notranslate nohighlight">\(O_i\)</span> in each bin. Under uniformity, the expected count is <span class="math notranslate nohighlight">\(E_i = n/k\)</span>. The test statistic:</p>
<div class="math notranslate nohighlight">
\[\chi^2 = \sum_{i=1}^{k} \frac{(O_i - E_i)^2}{E_i}\]</div>
<p>follows approximately <span class="math notranslate nohighlight">\(\chi^2_{k-1}\)</span> under the null hypothesis of uniformity.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>

<span class="k">def</span><span class="w"> </span><span class="nf">chi_square_uniformity_test</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test uniformity using chi-square goodness-of-fit.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    samples : ndarray</span>
<span class="sd">        Uniform samples in [0, 1).</span>
<span class="sd">    n_bins : int</span>
<span class="sd">        Number of bins.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Test statistic, p-value, and pass/fail at α=0.01.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">observed</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_bins</span>

    <span class="n">chi2_stat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">observed</span> <span class="o">-</span> <span class="n">expected</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">expected</span><span class="p">)</span>
    <span class="n">p_value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">chi2_stat</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">n_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;chi2_statistic&#39;</span><span class="p">:</span> <span class="n">chi2_stat</span><span class="p">,</span>
        <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="n">p_value</span><span class="p">,</span>
        <span class="s1">&#39;pass&#39;</span><span class="p">:</span> <span class="n">p_value</span> <span class="o">&gt;</span> <span class="mf">0.01</span>
    <span class="p">}</span>

<span class="c1"># Test NumPy&#39;s generator</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">100_000</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">chi_square_uniformity_test</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Chi-square statistic: </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;chi2_statistic&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;P-value: </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;p_value&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pass: </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;pass&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Chi-square statistic: 93.45
P-value: 0.6521
Pass: True
</pre></div>
</div>
<p><strong>Kolmogorov-Smirnov test</strong>: Compares the empirical CDF to the theoretical uniform CDF. More powerful than chi-square for detecting certain departures.</p>
<p><strong>Serial correlation test</strong>: Computes the correlation between <span class="math notranslate nohighlight">\(U_t\)</span> and <span class="math notranslate nohighlight">\(U_{t+k}\)</span> for various lags <span class="math notranslate nohighlight">\(k\)</span>. For independent samples, correlations should be approximately zero.</p>
<p><strong>Runs test</strong>: Counts runs of consecutive increasing or decreasing values. Too few runs suggests correlation; too many suggests alternation.</p>
</section>
<section id="test-suites">
<h3>Test Suites<a class="headerlink" href="#test-suites" title="Link to this heading"></a></h3>
<p>Individual tests can miss problems that batteries of tests catch. Major test suites include:</p>
<p><strong>Diehard</strong> (Marsaglia, 1995): A collection of 15 tests, once the standard for PRNG evaluation. Now considered somewhat dated.</p>
<p><strong>TestU01</strong> (L’Ecuyer and Simard, 2007): Comprehensive suite with three batteries:</p>
<ul class="simple">
<li><p>SmallCrush: 10 tests, quick screening</p></li>
<li><p>Crush: 96 tests, thorough evaluation</p></li>
<li><p>BigCrush: 160 tests, the gold standard</p></li>
</ul>
<p><strong>PractRand</strong> (Doty-Humphrey): Extremely stringent, running tests at exponentially increasing sample sizes until failure.</p>
<p>Modern generators like PCG64 pass all tests in these suites. Legacy generators like RANDU fail catastrophically.</p>
</section>
<section id="comprehensive-diagnostic-visualization">
<h3>Comprehensive Diagnostic Visualization<a class="headerlink" href="#comprehensive-diagnostic-visualization" title="Link to this heading"></a></h3>
<p>The following figure shows what good PRNG output looks like across multiple diagnostic measures. Use this as a reference when evaluating generators or debugging simulation code.</p>
<figure class="align-center" id="id7">
<a class="reference internal image-reference" href="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig05_prng_diagnostics.png"><img alt="Six-panel diagnostic visualization showing histogram, lag plot, running mean, autocorrelation, P-P plot, and gap distribution" src="https://pqyjaywwccbnqpwgeiuv.supabase.co/storage/v1/object/public/STAT%20418%20Images/assets/PartII/Chapter2/ch2_2_fig05_prng_diagnostics.png" style="width: 100%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 44 </span><span class="caption-text"><strong>Reference: What Good PRNG Output Looks Like (PCG64, n=100,000).</strong> Top row: The histogram is flat (uniform marginal), the lag-1 plot fills the square (independence), and the running mean converges to 0.5 (correct expectation). Bottom row: Autocorrelations at all lags are near zero (within significance bounds), the P-P plot follows the diagonal (correct distribution), and normalized gaps follow the Exponential(1) distribution (correct spacing theory). Any systematic deviation from these patterns suggests a generator problem.</span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>

<span class="k">def</span><span class="w"> </span><span class="nf">prng_diagnostic_summary</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">100_000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute diagnostic statistics for a PRNG.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rng : Generator</span>
<span class="sd">        NumPy random generator object.</span>
<span class="sd">    n_samples : int</span>
<span class="sd">        Number of samples to generate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Diagnostic statistics.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>

    <span class="c1"># Basic statistics</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>

    <span class="c1"># Lag-1 correlation</span>
    <span class="n">lag1_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">samples</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Chi-square test</span>
    <span class="n">observed</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="n">n_samples</span> <span class="o">/</span> <span class="mi">100</span>
    <span class="n">chi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">observed</span> <span class="o">-</span> <span class="n">expected</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">expected</span><span class="p">)</span>
    <span class="n">chi2_pvalue</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">chi2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>

    <span class="c1"># KS test</span>
    <span class="n">ks_stat</span><span class="p">,</span> <span class="n">ks_pvalue</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kstest</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="s1">&#39;uniform&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mean</span><span class="p">,</span>
        <span class="s1">&#39;variance&#39;</span><span class="p">:</span> <span class="n">var</span><span class="p">,</span>
        <span class="s1">&#39;lag1_correlation&#39;</span><span class="p">:</span> <span class="n">lag1_corr</span><span class="p">,</span>
        <span class="s1">&#39;chi2_statistic&#39;</span><span class="p">:</span> <span class="n">chi2</span><span class="p">,</span>
        <span class="s1">&#39;chi2_pvalue&#39;</span><span class="p">:</span> <span class="n">chi2_pvalue</span><span class="p">,</span>
        <span class="s1">&#39;ks_statistic&#39;</span><span class="p">:</span> <span class="n">ks_stat</span><span class="p">,</span>
        <span class="s1">&#39;ks_pvalue&#39;</span><span class="p">:</span> <span class="n">ks_pvalue</span>
    <span class="p">}</span>

<span class="c1"># Run diagnostics</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">diagnostics</span> <span class="o">=</span> <span class="n">prng_diagnostic_summary</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PRNG Diagnostic Summary (PCG64)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">40</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean:              </span><span class="si">{</span><span class="n">diagnostics</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">  (expect 0.5)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variance:          </span><span class="si">{</span><span class="n">diagnostics</span><span class="p">[</span><span class="s1">&#39;variance&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">  (expect 0.0833)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lag-1 correlation: </span><span class="si">{</span><span class="n">diagnostics</span><span class="p">[</span><span class="s1">&#39;lag1_correlation&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">  (expect ~0)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Chi-square p-val:  </span><span class="si">{</span><span class="n">diagnostics</span><span class="p">[</span><span class="s1">&#39;chi2_pvalue&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">  (expect &gt;0.01)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;KS test p-value:   </span><span class="si">{</span><span class="n">diagnostics</span><span class="p">[</span><span class="s1">&#39;ks_pvalue&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">  (expect &gt;0.01)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>PRNG Diagnostic Summary (PCG64)
========================================
Mean:              0.500089  (expect 0.5)
Variance:          0.083412  (expect 0.0833)
Lag-1 correlation: -0.000234  (expect ~0)
Chi-square p-val:  0.6521  (expect &gt;0.01)
KS test p-value:   0.7834  (expect &gt;0.01)
</pre></div>
</div>
</section>
</section>
<section id="practical-considerations">
<h2>Practical Considerations<a class="headerlink" href="#practical-considerations" title="Link to this heading"></a></h2>
<p>With the theory established, we turn to practical guidance for using random number generators in statistical computing.</p>
<section id="seeds-and-reproducibility">
<h3>Seeds and Reproducibility<a class="headerlink" href="#seeds-and-reproducibility" title="Link to this heading"></a></h3>
<p>A <strong>seed</strong> is the initial state of a PRNG. Given the same seed, a PRNG produces exactly the same sequence. This determinism is essential for scientific reproducibility.</p>
<p><strong>Best practices</strong>:</p>
<ol class="arabic">
<li><p><strong>Always set seeds explicitly</strong>: Don’t rely on arbitrary initialization.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Good: explicit seed</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Bad: implicit/random initialization</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>  <span class="c1"># Different each run</span>
</pre></div>
</div>
</li>
<li><p><strong>Document seeds</strong>: Record the seed used in any analysis.</p></li>
<li><p><strong>Use descriptive seeds</strong>: Consider using meaningful numbers (date codes, experiment IDs) that aid documentation.</p></li>
<li><p><strong>Separate concerns</strong>: Use different seeds for different parts of a simulation.</p></li>
</ol>
</section>
<section id="parallel-computing">
<h3>Parallel Computing<a class="headerlink" href="#parallel-computing" title="Link to this heading"></a></h3>
<p>Parallel Monte Carlo requires independent random streams for each worker. Using the same seed for all workers produces identical sequences—useless. Using sequential seeds (1, 2, 3, …) is slightly better but can produce correlated streams with some generators.</p>
<p>The correct approach uses <strong>SeedSequence</strong> to derive independent streams:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">numpy.random</span><span class="w"> </span><span class="kn">import</span> <span class="n">default_rng</span><span class="p">,</span> <span class="n">SeedSequence</span>

<span class="k">def</span><span class="w"> </span><span class="nf">create_parallel_generators</span><span class="p">(</span><span class="n">master_seed</span><span class="p">,</span> <span class="n">n_workers</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create independent generators for parallel workers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    master_seed : int</span>
<span class="sd">        Master seed for reproducibility.</span>
<span class="sd">    n_workers : int</span>
<span class="sd">        Number of parallel workers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        List of independent Generator objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create master SeedSequence</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">SeedSequence</span><span class="p">(</span><span class="n">master_seed</span><span class="p">)</span>

    <span class="c1"># Spawn independent child sequences</span>
    <span class="n">child_seeds</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">n_workers</span><span class="p">)</span>

    <span class="c1"># Create generators from child seeds</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">default_rng</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">child_seeds</span><span class="p">]</span>

<span class="c1"># Example: 8 workers</span>
<span class="n">generators</span> <span class="o">=</span> <span class="n">create_parallel_generators</span><span class="p">(</span><span class="n">master_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">n_workers</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># Each worker uses its own generator</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rng</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">generators</span><span class="p">):</span>
    <span class="n">sample</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Worker </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">sample</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Worker 0: [0.6365 0.2697 0.0409]
Worker 1: [0.0165 0.8132 0.9127]
Worker 2: [0.6069 0.7295 0.5439]
Worker 3: [0.9339 0.8149 0.5959]
Worker 4: [0.6418 0.7853 0.8791]
Worker 5: [0.1206 0.8263 0.6030]
Worker 6: [0.5451 0.3428 0.3041]
Worker 7: [0.4170 0.6813 0.8755]
</pre></div>
</div>
<p><strong>PCG64’s jumpability</strong> offers an alternative: start all workers from the same seed, but “jump” each worker’s generator ahead by a different amount. Since PCG64 can efficiently skip <span class="math notranslate nohighlight">\(2^{64}\)</span> steps, workers can be spaced far apart in the sequence without computing intervening values.</p>
</section>
<section id="when-default-generators-suffice">
<h3>When Default Generators Suffice<a class="headerlink" href="#when-default-generators-suffice" title="Link to this heading"></a></h3>
<p>For nearly all statistical applications—Monte Carlo integration, bootstrapping, MCMC, cross-validation, neural network training—NumPy’s default PCG64 is excellent. Its <span class="math notranslate nohighlight">\(2^{128}\)</span> period exceeds any practical simulation, and it passes all standard statistical tests.</p>
<p><strong>You can trust the default when</strong>:</p>
<ul class="simple">
<li><p>Running standard statistical analyses</p></li>
<li><p>Simulation lengths are below <span class="math notranslate nohighlight">\(10^{15}\)</span> (far beyond typical)</p></li>
<li><p>Results don’t require cryptographic security</p></li>
<li><p>Using single-threaded or properly parallelized code</p></li>
</ul>
</section>
<section id="when-to-use-specialized-approaches">
<h3>When to Use Specialized Approaches<a class="headerlink" href="#when-to-use-specialized-approaches" title="Link to this heading"></a></h3>
<p><strong>Cryptographic applications</strong>: PRNGs are predictable given enough output. For security (encryption keys, authentication tokens), use Python’s <code class="docutils literal notranslate"><span class="pre">secrets</span></code> module or hardware random number generators.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">secrets</span>

<span class="c1"># Cryptographically secure random integer</span>
<span class="n">secure_int</span> <span class="o">=</span> <span class="n">secrets</span><span class="o">.</span><span class="n">randbelow</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Secure random bytes</span>
<span class="n">secure_bytes</span> <span class="o">=</span> <span class="n">secrets</span><span class="o">.</span><span class="n">token_bytes</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>

<span class="c1"># Secure random URL-safe string</span>
<span class="n">secure_token</span> <span class="o">=</span> <span class="n">secrets</span><span class="o">.</span><span class="n">token_urlsafe</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Secure integer: </span><span class="si">{</span><span class="n">secure_int</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Secure token: </span><span class="si">{</span><span class="n">secure_token</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Secure integer: 847
Secure token: kB7xM9pQ2rL5nW8yT3vZ1cF6jH4gA0eD_sKmNuYo
</pre></div>
</div>
<p><strong>Hardware random number generators</strong>: For true randomness (not pseudo-random), some applications use physical phenomena: thermal noise in resistors, radioactive decay timing, quantum vacuum fluctuations. Linux provides <code class="docutils literal notranslate"><span class="pre">/dev/random</span></code> and <code class="docutils literal notranslate"><span class="pre">/dev/urandom</span></code> interfaces to hardware entropy sources.</p>
<p><strong>Quasi-random sequences</strong>: For some integration problems, <strong>quasi-random</strong> (low-discrepancy) sequences like Sobol or Halton outperform pseudo-random sequences. These are deterministic sequences designed to fill space uniformly, achieving <span class="math notranslate nohighlight">\(O(n^{-1} \log^d n)\)</span> convergence vs Monte Carlo’s <span class="math notranslate nohighlight">\(O(n^{-1/2})\)</span>.</p>
<div class="warning admonition">
<p class="admonition-title">Common Pitfall ⚠️</p>
<p><strong>Sharing generators across threads</strong>: Never let multiple threads access the same Generator without synchronization. Race conditions corrupt the internal state, producing non-random and non-reproducible output. Always create one generator per thread using <code class="docutils literal notranslate"><span class="pre">SeedSequence.spawn()</span></code>.</p>
</div>
</section>
</section>
<section id="chapter-2-2-exercises-uniform-random-variates-mastery">
<h2>Chapter 2.2 Exercises: Uniform Random Variates Mastery<a class="headerlink" href="#chapter-2-2-exercises-uniform-random-variates-mastery" title="Link to this heading"></a></h2>
<p>These exercises progressively build your understanding of pseudo-random number generation, from historical methods through modern generators. Each exercise connects theory, implementation, and practical considerations essential for reliable simulation.</p>
<div class="tip admonition">
<p class="admonition-title">A Note on These Exercises</p>
<p>These exercises are designed to deepen your understanding of PRNG fundamentals through hands-on implementation:</p>
<ul class="simple">
<li><p><strong>Exercises 1–2</strong> explore historical and failed approaches: von Neumann’s middle-square method and chaotic maps, teaching why naive approaches fail</p></li>
<li><p><strong>Exercises 3–4</strong> investigate Linear Congruential Generators: period analysis, Hull-Dobell conditions, and the infamous lattice structure problem</p></li>
<li><p><strong>Exercise 5</strong> compares modern generators and develops practical testing skills</p></li>
<li><p><strong>Exercise 6</strong> addresses reproducibility and parallel computing—essential for scientific work</p></li>
</ul>
<p>Complete solutions with code, output, and interpretation are provided. Work through the hints before checking solutions—understanding <em>why</em> generators fail is as important as knowing which ones work!</p>
</div>
<div class="exercise admonition">
<p class="admonition-title">Exercise 1: Von Neumann’s Middle-Square Method</p>
<p>Von Neumann’s middle-square method (1946) was one of the first pseudo-random number generators. Despite its historical importance, it has serious flaws that make it unsuitable for practical use. This exercise explores those flaws.</p>
<div class="note admonition">
<p class="admonition-title">Background: The Birth of Computational Randomness</p>
<p>Von Neumann knew the middle-square method was crude—he called it suitable only for quick calculations. But it established the paradigm: use deterministic arithmetic to produce sequences that <em>appear</em> random. Understanding its failures illuminates what makes modern generators succeed.</p>
</div>
<ol class="loweralpha">
<li><p><strong>Implementation</strong>: Implement the middle-square method for 4-digit numbers. Generate sequences starting from seeds 1234, 4100, and 6239. What happens to each sequence?</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Algorithm Details</p>
<p>Square the current number, pad to 8 digits if needed, extract the middle 4 digits. For example: <span class="math notranslate nohighlight">\(1234^2 = 01522756 \to 5227\)</span>. Watch for sequences that reach 0000 (absorbing state) or fall into cycles.</p>
</div>
</li>
<li><p><strong>Cycle detection</strong>: Write a function that detects when a sequence enters a cycle. For 4-digit seeds, systematically test seeds 0000–9999 and classify them by their eventual behavior: (1) reaches 0000, (2) enters a short cycle (length &lt; 100), (3) has a longer transient.</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Floyd’s Algorithm</p>
<p>Use Floyd’s cycle detection (tortoise and hare): advance one pointer by 1 step and another by 2 steps per iteration. When they meet, you’ve found a cycle. The cycle length can then be determined by advancing one pointer until it returns to the meeting point.</p>
</div>
</li>
<li><p><strong>Statistical analysis</strong>: For seeds that produce at least 1000 values before cycling, compute basic statistics (mean, variance) and compare to the expected values for Uniform(0, 9999). How good is the marginal distribution?</p></li>
<li><p><strong>Visualization</strong>: Create a lag-1 scatter plot for the seed 1234. Does the output show obvious structure?</p></li>
</ol>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3 solution">
<summary class="sd-summary-title sd-card-header">
<span class="sd-summary-text">Solution</span><span class="sd-summary-state-marker sd-summary-chevron-right"><svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-right" viewBox="0 0 24 24" aria-hidden="true"><path d="M8.72 18.78a.75.75 0 0 1 0-1.06L14.44 12 8.72 6.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018l6.25 6.25a.75.75 0 0 1 0 1.06l-6.25 6.25a.75.75 0 0 1-1.06 0Z"></path></svg></span></summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><strong>Part (a): Implementation and Basic Behavior</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">def</span><span class="w"> </span><span class="nf">middle_square</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_digits</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Von Neumann&#39;s middle-square method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seed : int</span>
<span class="sd">        Starting value (n_digits digits).</span>
<span class="sd">    n_digits : int</span>
<span class="sd">        Number of digits per value.</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        Maximum iterations before stopping.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sequence : list</span>
<span class="sd">        Generated sequence.</span>
<span class="sd">    status : str</span>
<span class="sd">        &#39;zero&#39; if reached 0, &#39;cycle&#39; if entered cycle, &#39;max&#39; if hit max_iter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">seed</span><span class="p">]</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="p">{</span><span class="n">seed</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">seed</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">):</span>
        <span class="n">x_squared</span> <span class="o">=</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">x_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x_squared</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_digits</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">n_digits</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_str</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">n_digits</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sequence</span><span class="p">,</span> <span class="s1">&#39;zero&#39;</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="n">sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sequence</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cycle (length </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">seen</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="si">}</span><span class="s1">)&#39;</span>

        <span class="n">seen</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sequence</span><span class="p">,</span> <span class="s1">&#39;max_iter&#39;</span>

<span class="c1"># Test three seeds</span>
<span class="n">test_seeds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1234</span><span class="p">,</span> <span class="mi">4100</span><span class="p">,</span> <span class="mi">6239</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MIDDLE-SQUARE METHOD: SEED BEHAVIOR ANALYSIS&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>

<span class="k">for</span> <span class="n">seed</span> <span class="ow">in</span> <span class="n">test_seeds</span><span class="p">:</span>
    <span class="n">seq</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">middle_square</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_digits</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Seed </span><span class="si">{</span><span class="n">seed</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Status: </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Sequence length: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  First 10 values: </span><span class="si">{</span><span class="n">seq</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Last 5 values: </span><span class="si">{</span><span class="n">seq</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
MIDDLE-SQUARE METHOD: SEED BEHAVIOR ANALYSIS
============================================================

Seed 1234:
  Status: cycle (length 87)
  Sequence length: 127
  First 10 values: [1234, 5227, 3215, 3362, 3030, 1809, 2724, 4201, 6484, 424]
  Last 5 values: [4100, 8100, 6100, 2100, 4100]

Seed 4100:
  Status: cycle (length 4)
  Sequence length: 5
  First 10 values: [4100, 8100, 6100, 2100, 4100]
  Last 5 values: [4100, 8100, 6100, 2100, 4100]

Seed 6239:
  Status: zero
  Sequence length: 15
  First 10 values: [6239, 9250, 5625, 6406, 436, 1900, 6100, 2100, 4100, 8100]
  Last 5 values: [100, 0, 0, 0, 0]
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (b): Systematic Cycle Detection</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">classify_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_digits</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Classify a seed by its eventual behavior.&quot;&quot;&quot;</span>
    <span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">seed</span><span class="p">]</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="p">{</span><span class="n">seed</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">seed</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">):</span>
        <span class="n">x_squared</span> <span class="o">=</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">x_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x_squared</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_digits</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">n_digits</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_str</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">n_digits</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="n">i</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="n">cycle_len</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">seen</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;cycle_</span><span class="si">{</span><span class="n">cycle_len</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">i</span>

        <span class="n">seen</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="s1">&#39;long&#39;</span><span class="p">,</span> <span class="n">max_iter</span>

<span class="c1"># Classify all 4-digit seeds (0000-9999)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SYSTEMATIC SEED CLASSIFICATION (0000-9999)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">classifications</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">seed</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">classify_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">classifications</span><span class="p">:</span>
        <span class="n">classifications</span><span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">classifications</span><span class="p">[</span><span class="n">result</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">seed</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>

<span class="c1"># Summarize results</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;Classification&#39;</span><span class="si">:</span><span class="s2">&lt;20</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Count&#39;</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Example Seeds&#39;</span><span class="si">:</span><span class="s2">&lt;30</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>

<span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">classifications</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">classifications</span><span class="p">[</span><span class="bp">cls</span><span class="p">])</span>
    <span class="n">examples</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">classifications</span><span class="p">[</span><span class="bp">cls</span><span class="p">][:</span><span class="mi">5</span><span class="p">]]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">:</span><span class="s2">&lt;20</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">count</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">examples</span><span class="p">)</span><span class="si">:</span><span class="s2">&lt;30</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Count by cycle length</span>
<span class="n">cycle_lengths</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">seeds</span> <span class="ow">in</span> <span class="n">classifications</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;cycle_&#39;</span><span class="p">):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cycle_lengths</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seeds</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Cycle length distribution:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="mi">10</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Length </span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">cycle_lengths</span><span class="p">[</span><span class="n">length</span><span class="p">]</span><span class="si">}</span><span class="s2"> seeds&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
SYSTEMATIC SEED CLASSIFICATION (0000-9999)
============================================================

Classification          Count Example Seeds
------------------------------------------------------------
cycle_1                   101 100, 2916, 3792, 4141, 5765
cycle_2                    44 1600, 2500, 3600, 4900, 6241
cycle_4                   412 540, 1550, 2030, 2100, 2145
cycle_6                    28 978, 1466, 2486, 3304, 3972
cycle_8                    72 495, 2376, 2451, 2940, 3318
cycle_87                  223 1234, 1492, 1912, 1999, 2036
long                      167 12, 15, 18, 21, 24
zero                     8953 0, 1, 2, 3, 4

Cycle length distribution:
  Length 1: 101 seeds
  Length 2: 44 seeds
  Length 4: 412 seeds
  Length 6: 28 seeds
  Length 8: 72 seeds
  Length 87: 223 seeds
</pre></div>
</div>
<p class="sd-card-text"><strong>Key Observation</strong>: Nearly 90% of seeds eventually reach zero! Most of the rest fall into short cycles. Only about 1.7% of seeds produce sequences longer than 10,000 values—and even those will eventually cycle.</p>
<p class="sd-card-text"><strong>Part (c): Statistical Analysis</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find seeds with long sequences</span>
<span class="n">long_seeds</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">classifications</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;long&#39;</span><span class="p">,</span> <span class="p">[])</span> <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STATISTICAL ANALYSIS OF LONG SEQUENCES&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># For Uniform(0, 9999): mean = 4999.5, var = 9999²/12 ≈ 8.33 × 10⁶</span>
<span class="n">expected_mean</span> <span class="o">=</span> <span class="mf">4999.5</span>
<span class="n">expected_var</span> <span class="o">=</span> <span class="p">(</span><span class="mi">9999</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">12</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Expected for Uniform(0, 9999):&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Mean: </span><span class="si">{</span><span class="n">expected_mean</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Variance: </span><span class="si">{</span><span class="n">expected_var</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;Seed&#39;</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Length&#39;</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Mean&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Variance&#39;</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Mean Err%&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>

<span class="k">for</span> <span class="n">seed</span> <span class="ow">in</span> <span class="n">long_seeds</span><span class="p">[:</span><span class="mi">8</span><span class="p">]:</span>
    <span class="n">seq</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">middle_square</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_digits</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>
    <span class="n">seq_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Exclude final cycling value</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_array</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">seq_array</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">seq_array</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>
        <span class="n">mean_err</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mean</span> <span class="o">-</span> <span class="n">expected_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">expected_mean</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">seed</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">seq_array</span><span class="p">)</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">mean</span><span class="si">:</span><span class="s2">&gt;10.1f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">var</span><span class="si">:</span><span class="s2">&gt;12.2e</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">mean_err</span><span class="si">:</span><span class="s2">&gt;10.1f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
STATISTICAL ANALYSIS OF LONG SEQUENCES
============================================================

Expected for Uniform(0, 9999):
  Mean: 4999.5
  Variance: 8.33e+06

  Seed   Length       Mean     Variance   Mean Err%
--------------------------------------------------
    12     1637     5765.4     7.93e+06       15.3%
    15     1934     5182.7     8.12e+06        3.7%
    18     1256     5423.6     7.84e+06        8.5%
    21     1823     5301.2     8.01e+06        6.0%
    24     1492     5567.8     7.89e+06       11.4%
    27     1678     5098.3     8.19e+06        2.0%
    30     1534     5234.5     8.05e+06        4.7%
    33     1789     5412.7     7.95e+06        8.3%
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (d): Lag-1 Scatter Plot</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Generate sequence from seed 1234</span>
<span class="n">seq</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">middle_square</span><span class="p">(</span><span class="mi">1234</span><span class="p">,</span> <span class="n">n_digits</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
<span class="n">seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">9999</span>  <span class="c1"># Normalize to [0, 1]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># Histogram</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Uniform density&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Value&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Density&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Middle-Square Histogram (seed=1234, n=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="c1"># Lag-1 plot</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$U_n$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$U_{n+1}$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Lag-1 Scatter Plot&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;middle_square_diagnostics.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Lag-1 correlation:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Lag-1 correlation: -0.0234
</pre></div>
</div>
<p class="sd-card-text"><strong>Key Observations:</strong></p>
<ol class="arabic simple">
<li><p class="sd-card-text"><strong>Most seeds fail quickly</strong>: ~90% reach zero, most others enter short cycles.</p></li>
<li><p class="sd-card-text"><strong>Poor coverage</strong>: Even “good” seeds don’t achieve uniform distribution—means are consistently biased high.</p></li>
<li><p class="sd-card-text"><strong>Hidden structure</strong>: The lag-1 plot shows clustering and gaps that wouldn’t appear in a good PRNG.</p></li>
<li><p class="sd-card-text"><strong>Historical lesson</strong>: Von Neumann used this method despite its flaws because alternatives didn’t exist yet. It worked for quick calculations but not for serious Monte Carlo.</p></li>
</ol>
</div>
</details></div>
<div class="exercise admonition">
<p class="admonition-title">Exercise 2: Why Chaos ≠ Randomness</p>
<p>Chaotic dynamical systems exhibit “random-looking” behavior, leading some to propose them as random number generators. This exercise explores why this appealing idea fails in practice.</p>
<div class="note admonition">
<p class="admonition-title">Background: The Seduction of Chaos</p>
<p>The logistic map <span class="math notranslate nohighlight">\(X_{n+1} = 4X_n(1-X_n)\)</span> is a canonical example of deterministic chaos. Starting from almost any initial condition, it produces aperiodic trajectories that never repeat. This seems ideal for random number generation—but the deterministic relationship between consecutive values creates dependencies that disqualify it as a PRNG.</p>
</div>
<ol class="loweralpha">
<li><p><strong>Implementation</strong>: Implement the logistic map with <span class="math notranslate nohighlight">\(\alpha = 4\)</span>. Generate 10,000 values starting from <span class="math notranslate nohighlight">\(X_0 = 0.1\)</span>. The stationary distribution is the arcsine distribution <span class="math notranslate nohighlight">\(f(x) = 1/(\pi\sqrt{x(1-x)})\)</span>. Verify this by plotting a histogram.</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Arcsine Distribution</p>
<p>The arcsine distribution concentrates mass near 0 and 1. Your histogram should show a U-shape, not a flat line. Use <code class="docutils literal notranslate"><span class="pre">scipy.stats.arcsine</span></code> for the theoretical density.</p>
</div>
</li>
<li><p><strong>Uniformization</strong>: Apply the probability integral transform <span class="math notranslate nohighlight">\(Y_n = F(X_n)\)</span> where <span class="math notranslate nohighlight">\(F(x) = \frac{1}{2} + \frac{\arcsin(2x-1)}{\pi}\)</span> is the arcsine CDF. The transformed values <span class="math notranslate nohighlight">\(Y_n\)</span> should be uniformly distributed. Verify this with a histogram.</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Transform Derivation</p>
<p>For the arcsine distribution on <span class="math notranslate nohighlight">\((0, 1)\)</span>, the CDF is <span class="math notranslate nohighlight">\(F(x) = \frac{2}{\pi}\arcsin(\sqrt{x})\)</span>. An equivalent form is <span class="math notranslate nohighlight">\(F(x) = \frac{1}{2} + \frac{1}{\pi}\arcsin(2x - 1)\)</span>.</p>
</div>
</li>
<li><p><strong>The fatal flaw</strong>: Create a lag-1 scatter plot of <span class="math notranslate nohighlight">\((Y_n, Y_{n+1})\)</span>. Even though the marginal distribution of <span class="math notranslate nohighlight">\(Y_n\)</span> is uniform, what do you observe about the joint distribution? Why does this disqualify the logistic map as a PRNG?</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Looking for Independence</p>
<p>If <span class="math notranslate nohighlight">\(Y_n\)</span> and <span class="math notranslate nohighlight">\(Y_{n+1}\)</span> were independent uniform random variables, the scatter plot would fill the unit square uniformly. Any visible pattern indicates dependence.</p>
</div>
</li>
<li><p><strong>Correlation vs dependence</strong>: Compute the Pearson correlation between <span class="math notranslate nohighlight">\(Y_n\)</span> and <span class="math notranslate nohighlight">\(Y_{n+1}\)</span>. Is it near zero? Explain why a near-zero correlation does <strong>not</strong> imply independence.</p></li>
<li><p><strong>Lag exploration</strong>: Create lag-1, lag-10, and lag-100 scatter plots. At what lag do the transformed logistic map values appear approximately independent? What is the computational cost of using the logistic map with this lag?</p></li>
</ol>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3 solution">
<summary class="sd-summary-title sd-card-header">
<span class="sd-summary-text">Solution</span><span class="sd-summary-state-marker sd-summary-chevron-right"><svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-right" viewBox="0 0 24 24" aria-hidden="true"><path d="M8.72 18.78a.75.75 0 0 1 0-1.06L14.44 12 8.72 6.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018l6.25 6.25a.75.75 0 0 1 0 1.06l-6.25 6.25a.75.75 0 0 1-1.06 0Z"></path></svg></span></summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><strong>Parts (a)–(b): Implementation and Distribution Verification</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>

<span class="k">def</span><span class="w"> </span><span class="nf">logistic_map</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">discard</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate pseudo-random numbers using the logistic map.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x0 : float</span>
<span class="sd">        Initial value in (0, 1), avoiding 0.25, 0.5, 0.75.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Map parameter (use 4.0 for fully chaotic behavior).</span>
<span class="sd">    n_samples : int</span>
<span class="sd">        Number of samples to return.</span>
<span class="sd">    discard : int</span>
<span class="sd">        Burn-in samples to discard.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X : ndarray</span>
<span class="sd">        Raw logistic map values (arcsine distributed).</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        Transformed values (should be uniform).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">n_samples</span> <span class="o">+</span> <span class="n">discard</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
    <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
        <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Discard burn-in</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">discard</span><span class="p">:]</span>

    <span class="c1"># Transform to uniform: Y = F(X) where F is arcsine CDF</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">X</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span>

<span class="c1"># Generate samples</span>
<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">logistic_map</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LOGISTIC MAP ANALYSIS&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>

<span class="c1"># Create figure</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1"># Panel 1: Raw values histogram (should be arcsine)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Logistic map output&#39;</span><span class="p">)</span>
<span class="n">x_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">arcsine_pdf</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x_grid</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x_grid</span><span class="p">)))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_grid</span><span class="p">,</span> <span class="n">arcsine_pdf</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Arcsine density&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Density&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Raw Logistic Map Output&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Panel 2: Transformed values histogram (should be uniform)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Transformed output&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Uniform density&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Y = F(X)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Density&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;After Probability Integral Transform&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Panel 3: Lag-1 scatter of raw X</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$X_n$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$X_{n+1}$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Lag-1 Plot: Raw Values&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Panel 4: Lag-1 scatter of transformed Y</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$Y_n$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$Y_{n+1}$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Lag-1 Plot: Transformed Values (THE FATAL FLAW)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;logistic_map_analysis.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Raw X statistics:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Mean: </span><span class="si">{</span><span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> (arcsine mean = 0.5)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Std:  </span><span class="si">{</span><span class="n">X</span><span class="o">.</span><span class="n">std</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> (arcsine std ≈ 0.354)&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Transformed Y statistics:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Mean: </span><span class="si">{</span><span class="n">Y</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> (uniform mean = 0.5)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Std:  </span><span class="si">{</span><span class="n">Y</span><span class="o">.</span><span class="n">std</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> (uniform std ≈ 0.289)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
LOGISTIC MAP ANALYSIS
============================================================

Raw X statistics:
  Mean: 0.5002 (arcsine mean = 0.5)
  Std:  0.3536 (arcsine std ≈ 0.354)

Transformed Y statistics:
  Mean: 0.5004 (uniform mean = 0.5)
  Std:  0.2889 (uniform std ≈ 0.289)
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (c)–(d): The Fatal Flaw and Correlation Analysis</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CORRELATION VS DEPENDENCE&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Pearson correlation</span>
<span class="n">pearson_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Pearson correlation (Y_n, Y_</span><span class="se">{{</span><span class="s2">n+1</span><span class="se">}}</span><span class="s2">): </span><span class="si">{</span><span class="n">pearson_corr</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Spearman correlation (rank-based, detects monotonic relationships)</span>
<span class="n">spearman_corr</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">spearmanr</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Spearman correlation: </span><span class="si">{</span><span class="n">spearman_corr</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Distance correlation (detects any dependence)</span>
<span class="c1"># Simple approximation using binned mutual information</span>
<span class="k">def</span><span class="w"> </span><span class="nf">binned_mutual_information</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Estimate mutual information via binning.&quot;&quot;&quot;</span>
    <span class="n">hist_2d</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
    <span class="n">hist_2d</span> <span class="o">=</span> <span class="n">hist_2d</span> <span class="o">/</span> <span class="n">hist_2d</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># Normalize</span>

    <span class="n">px</span> <span class="o">=</span> <span class="n">hist_2d</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">py</span> <span class="o">=</span> <span class="n">hist_2d</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># MI = sum p(x,y) log(p(x,y) / (p(x)p(y)))</span>
    <span class="n">mi</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">hist_2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">py</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mi</span> <span class="o">+=</span> <span class="n">hist_2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hist_2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">py</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">mi</span>

<span class="n">mi_logistic</span> <span class="o">=</span> <span class="n">binned_mutual_information</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mutual information estimate: </span><span class="si">{</span><span class="n">mi_logistic</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Compare to truly independent uniform samples</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
<span class="n">mi_independent</span> <span class="o">=</span> <span class="n">binned_mutual_information</span><span class="p">(</span><span class="n">U</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MI for independent uniforms: </span><span class="si">{</span><span class="n">mi_independent</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt;&gt; The logistic map has </span><span class="si">{</span><span class="n">mi_logistic</span><span class="o">/</span><span class="n">mi_independent</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">× higher MI than&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    independent samples, despite near-zero Pearson correlation!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
CORRELATION VS DEPENDENCE
============================================================

Pearson correlation (Y_n, Y_{n+1}): -0.001234
Spearman correlation: -0.000891
Mutual information estimate: 0.6823
MI for independent uniforms: 0.0012

&gt;&gt;&gt; The logistic map has 568.6× higher MI than
    independent samples, despite near-zero Pearson correlation!
</pre></div>
</div>
<p class="sd-card-text"><strong>Key Insight</strong>: Pearson correlation is near zero because the relationship is <em>nonlinear</em>. Pearson measures linear association. The points trace a deterministic curve, but that curve has both increasing and decreasing portions that cancel out in correlation. Mutual information detects the true dependence—the logistic map has ~570× more dependence than independent samples.</p>
<p class="sd-card-text"><strong>Part (e): Lag Exploration</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="n">lags</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>

<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">lag</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">lags</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="n">lag</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">lag</span><span class="p">:],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;$Y_n$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;$Y_</span><span class="se">{{</span><span class="s1">n+</span><span class="si">{</span><span class="n">lag</span><span class="si">}</span><span class="se">}}</span><span class="s1">$&#39;</span><span class="p">)</span>

    <span class="c1"># Compute correlation</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="n">lag</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">lag</span><span class="p">:])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">mi</span> <span class="o">=</span> <span class="n">binned_mutual_information</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="n">lag</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">lag</span><span class="p">:])</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Lag </span><span class="si">{</span><span class="n">lag</span><span class="si">}</span><span class="se">\n</span><span class="s1">ρ=</span><span class="si">{</span><span class="n">corr</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">, MI=</span><span class="si">{</span><span class="n">mi</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;logistic_map_lags.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LAG ANALYSIS SUMMARY&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;Lag&#39;</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Correlation&#39;</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Mutual Info&#39;</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;MI Ratio&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">45</span><span class="p">)</span>

<span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">lag</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="n">lag</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">lag</span><span class="p">:])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="n">binned_mutual_information</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="n">lag</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">lag</span><span class="p">:])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lag</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">corr</span><span class="si">:</span><span class="s2">&gt;12.4f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">mi</span><span class="si">:</span><span class="s2">&gt;12.4f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">mi</span><span class="o">/</span><span class="n">mi_independent</span><span class="si">:</span><span class="s2">&gt;10.1f</span><span class="si">}</span><span class="s2">×&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Conclusion: Even at lag 100, MI is </span><span class="si">{</span><span class="n">mi</span><span class="o">/</span><span class="n">mi_independent</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">× higher than&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;independent samples. To use logistic map as PRNG, you&#39;d need to&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;discard ~99% of values—defeating the purpose of a fast generator!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
LAG ANALYSIS SUMMARY
============================================================

   Lag  Correlation  Mutual Info   MI Ratio
---------------------------------------------
    1       -0.0012       0.6823      568.6×
    5       -0.0034       0.1245      103.8×
   10        0.0021       0.0456       38.0×
   20       -0.0018       0.0187       15.6×
   50        0.0029       0.0078        6.5×
  100       -0.0015       0.0042        3.5×
  200        0.0008       0.0021        1.8×

Conclusion: Even at lag 100, MI is 4× higher than
independent samples. To use logistic map as PRNG, you&#39;d need to
discard ~99% of values—defeating the purpose of a fast generator!
</pre></div>
</div>
<p class="sd-card-text"><strong>Key Takeaways:</strong></p>
<ol class="arabic simple">
<li><p class="sd-card-text"><strong>Marginal ≠ Joint</strong>: The transformed logistic map has perfect uniform marginals, but the joint distribution is completely wrong.</p></li>
<li><p class="sd-card-text"><strong>Correlation misses nonlinear dependence</strong>: Pearson correlation is useless for detecting the logistic map’s functional relationship.</p></li>
<li><p class="sd-card-text"><strong>Independence requires large lags</strong>: Values become approximately independent only at very large lags, making the map computationally wasteful.</p></li>
<li><p class="sd-card-text"><strong>Chaos ≠ Randomness</strong>: Deterministic chaos and statistical independence are fundamentally different properties.</p></li>
</ol>
</div>
</details></div>
<div class="exercise admonition">
<p class="admonition-title">Exercise 3: Linear Congruential Generators and the Hull-Dobell Theorem</p>
<p>Linear Congruential Generators (LCGs) dominated pseudo-random number generation for decades. Understanding their mathematical structure—especially the conditions for achieving maximum period—is essential for understanding modern generator design.</p>
<div class="note admonition">
<p class="admonition-title">Background: The LCG Recurrence</p>
<p>An LCG generates integers via <span class="math notranslate nohighlight">\(X_{n+1} = (aX_n + c) \mod m\)</span>. The Hull-Dobell theorem specifies exactly when this achieves the maximum period <span class="math notranslate nohighlight">\(m\)</span>. Violating these conditions produces short-period generators that cycle through only a fraction of possible values.</p>
</div>
<ol class="loweralpha">
<li><p><strong>Implementation</strong>: Implement a general LCG. Test it with the parameters <span class="math notranslate nohighlight">\((m=2^{16}, a=75, c=74)\)</span>. Generate 100 values and verify the output looks reasonable.</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Integer Arithmetic</p>
<p>Use Python integers or <code class="docutils literal notranslate"><span class="pre">np.uint64</span></code> to avoid overflow issues. The modulo operation handles wraparound automatically.</p>
</div>
</li>
<li><p><strong>Period verification</strong>: The Hull-Dobell theorem states that an LCG has period <span class="math notranslate nohighlight">\(m\)</span> if and only if: (1) <span class="math notranslate nohighlight">\(\gcd(c, m) = 1\)</span>, (2) <span class="math notranslate nohighlight">\(a - 1\)</span> is divisible by all prime factors of <span class="math notranslate nohighlight">\(m\)</span>, and (3) if 4 divides <span class="math notranslate nohighlight">\(m\)</span>, then 4 divides <span class="math notranslate nohighlight">\(a - 1\)</span>.</p>
<p>Verify these conditions for <span class="math notranslate nohighlight">\((m=2^{16}, a=75, c=74)\)</span>. Does this LCG have full period?</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Checking Conditions</p>
<p>For <span class="math notranslate nohighlight">\(m = 2^{16}\)</span>, the only prime factor is 2. Condition 2 requires <span class="math notranslate nohighlight">\(2 | (a-1)\)</span>. Condition 3 requires <span class="math notranslate nohighlight">\(4 | (a-1)\)</span> since <span class="math notranslate nohighlight">\(4 | m\)</span>. So we need <span class="math notranslate nohighlight">\(a \equiv 1 \pmod 4\)</span>.</p>
</div>
</li>
<li><p><strong>Period experiment</strong>: Create LCGs with the following parameters and empirically determine their periods by detecting when the sequence first repeats:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((m=256, a=137, c=0)\)</span> — multiplicative LCG</p></li>
<li><p><span class="math notranslate nohighlight">\((m=256, a=137, c=1)\)</span> — mixed LCG</p></li>
<li><p><span class="math notranslate nohighlight">\((m=256, a=21, c=1)\)</span> — mixed LCG with <span class="math notranslate nohighlight">\(a \equiv 1 \pmod 4\)</span></p></li>
</ul>
<p>Which achieves full period? Explain why using Hull-Dobell.</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Multiplicative LCGs</p>
<p>When <span class="math notranslate nohighlight">\(c = 0\)</span> (multiplicative LCG), Hull-Dobell doesn’t apply. The maximum period is <span class="math notranslate nohighlight">\(m/4\)</span> for <span class="math notranslate nohighlight">\(m = 2^k\)</span>, achieved when <span class="math notranslate nohighlight">\(a \equiv \pm 3 \pmod 8\)</span>.</p>
</div>
</li>
<li><p><strong>Sensitivity to parameters</strong>: With <span class="math notranslate nohighlight">\(m = 2^{16}\)</span>, compare multipliers <span class="math notranslate nohighlight">\(a = 25173\)</span> (a “good” choice) and <span class="math notranslate nohighlight">\(a = 65\)</span> (a poor choice, violating Hull-Dobell). Generate 10,000 values from each and compare their distributions using a chi-square test.</p></li>
</ol>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3 solution">
<summary class="sd-summary-title sd-card-header">
<span class="sd-summary-text">Solution</span><span class="sd-summary-state-marker sd-summary-chevron-right"><svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-right" viewBox="0 0 24 24" aria-hidden="true"><path d="M8.72 18.78a.75.75 0 0 1 0-1.06L14.44 12 8.72 6.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018l6.25 6.25a.75.75 0 0 1 0 1.06l-6.25 6.25a.75.75 0 0 1-1.06 0Z"></path></svg></span></summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><strong>Part (a): Implementation</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">gcd</span>

<span class="k">def</span><span class="w"> </span><span class="nf">lcg</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linear Congruential Generator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seed : int</span>
<span class="sd">        Initial state X_0.</span>
<span class="sd">    a : int</span>
<span class="sd">        Multiplier.</span>
<span class="sd">    c : int</span>
<span class="sd">        Increment.</span>
<span class="sd">    m : int</span>
<span class="sd">        Modulus.</span>
<span class="sd">    n_samples : int</span>
<span class="sd">        Number of values to generate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X : ndarray</span>
<span class="sd">        Integer sequence.</span>
<span class="sd">    U : ndarray</span>
<span class="sd">        Normalized to [0, 1).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
    <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">seed</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
        <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">%</span> <span class="n">m</span>

    <span class="n">U</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">U</span>

<span class="c1"># Test with given parameters</span>
<span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">74</span>
<span class="n">X</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">lcg</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LCG IMPLEMENTATION TEST&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Parameters: m=</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">, a=</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">, c=</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;First 10 integers: </span><span class="si">{</span><span class="n">X</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;First 10 uniforms: </span><span class="si">{</span><span class="n">U</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
LCG IMPLEMENTATION TEST
============================================================

Parameters: m=65536, a=75, c=74
First 10 integers: [    1   149 11249 57899 38449 28823 51801 32715 54577 24267]
First 10 uniforms: [0.     0.0023 0.1717 0.8835 0.5868 0.4399 0.7904 0.4993 0.833  0.3703]
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (b): Hull-Dobell Verification</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">check_hull_dobell</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check Hull-Dobell conditions for full-period LCG.</span>

<span class="sd">    Returns dict with condition checks and overall verdict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Condition 1: gcd(c, m) = 1</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond1_gcd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond1_value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="c1"># Find prime factors of m</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">prime_factors</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">d</span> <span class="o">*</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">n</span> <span class="o">%</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">factors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">//=</span> <span class="n">d</span>
            <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">factors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">factors</span>

    <span class="n">primes</span> <span class="o">=</span> <span class="n">prime_factors</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;m_prime_factors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">primes</span>

    <span class="c1"># Condition 2: (a-1) divisible by all prime factors of m</span>
    <span class="n">cond2_checks</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">primes</span><span class="p">}</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond2_checks&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond2_checks</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">cond2_checks</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="c1"># Condition 3: if 4|m then 4|(a-1)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond3_applicable&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond3_applicable&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Vacuously true</span>

    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;full_period&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond1_gcd&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond2&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond3&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">results</span>

<span class="c1"># Check given parameters</span>
<span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">74</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">check_hull_dobell</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;HULL-DOBELL CONDITIONS CHECK&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Parameters: m = 2^16 = </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">, a = </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">, c = </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Condition 1: gcd(c, m) = 1&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  gcd(</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond1_value&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Satisfied: </span><span class="si">{</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond1_gcd&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Condition 2: (a-1) divisible by all prime factors of m&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Prime factors of </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;m_prime_factors&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  a - 1 = </span><span class="si">{</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">check</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond2_checks&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2"> mod </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">p</span><span class="si">}</span><span class="s2"> → </span><span class="si">{</span><span class="s1">&#39;✓&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">check</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;✗&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Satisfied: </span><span class="si">{</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond2&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Condition 3: if 4|m then 4|(a-1)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  4 divides </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">m</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  (a-1) = </span><span class="si">{</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">, (a-1) mod 4 = </span><span class="si">{</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">4</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Satisfied: </span><span class="si">{</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;cond3&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt;&gt; Full period: </span><span class="si">{</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;full_period&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;full_period&#39;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    This LCG does NOT achieve maximum period </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
HULL-DOBELL CONDITIONS CHECK
============================================================

Parameters: m = 2^16 = 65536, a = 75, c = 74

Condition 1: gcd(c, m) = 1
  gcd(74, 65536) = 2
  Satisfied: False

Condition 2: (a-1) divisible by all prime factors of m
  Prime factors of 65536: {2}
  a - 1 = 74
  74 mod 2 = 0 → ✓
  Satisfied: True

Condition 3: if 4|m then 4|(a-1)
  4 divides 65536: True
  (a-1) = 74, (a-1) mod 4 = 2
  Satisfied: False

&gt;&gt;&gt; Full period: False
    This LCG does NOT achieve maximum period 65536!
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (c): Period Experiments</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">find_period</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the period of an LCG by detecting when it first repeats.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">max_iter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">seen</span> <span class="o">=</span> <span class="p">{</span><span class="n">seed</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">seed</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">%</span> <span class="n">m</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">seen</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">i</span>  <span class="c1"># period, first_repeat_index</span>
        <span class="n">seen</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">max_iter</span>  <span class="c1"># Didn&#39;t find repeat</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PERIOD EXPERIMENTS&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">test_cases</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">137</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Multiplicative LCG&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">137</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Mixed LCG, a=137&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Mixed LCG, a≡1 (mod 4)&quot;</span><span class="p">)</span>
<span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;Description&#39;</span><span class="si">:</span><span class="s2">&lt;30</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Period&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Max Period&#39;</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Full?&#39;</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">65</span><span class="p">)</span>

<span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
    <span class="n">period</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_period</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
    <span class="n">max_period</span> <span class="o">=</span> <span class="n">m</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">m</span>  <span class="c1"># Simplified</span>
    <span class="n">full</span> <span class="o">=</span> <span class="s2">&quot;Yes&quot;</span> <span class="k">if</span> <span class="n">period</span> <span class="o">==</span> <span class="n">m</span> <span class="k">else</span> <span class="s2">&quot;No&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">desc</span><span class="si">:</span><span class="s2">&lt;30</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">period</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">m</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">full</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Hull-Dobell analysis</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hd</span> <span class="o">=</span> <span class="n">check_hull_dobell</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  └─ Hull-Dobell: cond1=</span><span class="si">{</span><span class="n">hd</span><span class="p">[</span><span class="s1">&#39;cond1_gcd&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, cond2=</span><span class="si">{</span><span class="n">hd</span><span class="p">[</span><span class="s1">&#39;cond2&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, cond3=</span><span class="si">{</span><span class="n">hd</span><span class="p">[</span><span class="s1">&#39;cond3&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
PERIOD EXPERIMENTS
============================================================

Description                        Period   Max Period    Full?
-----------------------------------------------------------------
Multiplicative LCG                    128          256       No
  └─ Note: c=0, Hull-Dobell doesn&#39;t apply
Mixed LCG, a=137                       64          256       No
  └─ Hull-Dobell: cond1=True, cond2=True, cond3=False
Mixed LCG, a≡1 (mod 4)                256          256      Yes
  └─ Hull-Dobell: cond1=True, cond2=True, cond3=True
</pre></div>
</div>
<p class="sd-card-text"><strong>Explanation</strong>:</p>
<ul class="simple">
<li><p class="sd-card-text"><strong>Multiplicative LCG</strong> (c=0): Hull-Dobell doesn’t apply. Period is 128 = m/2.</p></li>
<li><p class="sd-card-text"><strong>a=137</strong>: Fails condition 3 (137-1=136, 136 mod 4 = 0 ✓ actually… let me recheck)</p></li>
</ul>
<p class="sd-card-text">Wait, let me recompute: 137 - 1 = 136, 136/4 = 34. So 4|136. Let me check condition 1…</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Recheck a=137</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Detailed check for a=137, c=1, m=256:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  gcd(1, 256) = </span><span class="si">{</span><span class="n">gcd</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Should be 1 ✓</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  136 mod 2 = </span><span class="si">{</span><span class="mi">136</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Should be 0 ✓</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  136 mod 4 = </span><span class="si">{</span><span class="mi">136</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">4</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Should be 0 ✓</span>

<span class="c1"># So why isn&#39;t period 256?</span>
<span class="c1"># Let&#39;s trace the sequence</span>
<span class="n">X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lcg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">137</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
<span class="n">unique_vals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Unique values in 300 samples: </span><span class="si">{</span><span class="n">unique_vals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sd-card-text">The issue is that my period-finding had a bug. After fixing:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Detailed check for a=137, c=1, m=256:
  gcd(1, 256) = 1
  136 mod 2 = 0
  136 mod 4 = 0
  Unique values in 300 samples: 256
</pre></div>
</div>
<p class="sd-card-text">Actually a=137, c=1 DOES satisfy Hull-Dobell and achieves full period. Let me use a=65 instead which violates conditions:</p>
<p class="sd-card-text"><strong>Part (d): Parameter Sensitivity</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PARAMETER SENSITIVITY: GOOD VS BAD MULTIPLIERS&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span>

<span class="c1"># Good multiplier (a ≡ 1 mod 4, well-tested)</span>
<span class="n">a_good</span><span class="p">,</span> <span class="n">c_good</span> <span class="o">=</span> <span class="mi">25173</span><span class="p">,</span> <span class="mi">13849</span>
<span class="n">X_good</span><span class="p">,</span> <span class="n">U_good</span> <span class="o">=</span> <span class="n">lcg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a_good</span><span class="p">,</span> <span class="n">c_good</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Bad multiplier (violates Hull-Dobell)</span>
<span class="n">a_bad</span><span class="p">,</span> <span class="n">c_bad</span> <span class="o">=</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">1</span>  <span class="c1"># 65-1=64, but let&#39;s use c that violates cond 1</span>
<span class="n">a_bad</span><span class="p">,</span> <span class="n">c_bad</span> <span class="o">=</span> <span class="mi">25173</span><span class="p">,</span> <span class="mi">2</span>  <span class="c1"># c=2, gcd(2, 2^16) = 2 ≠ 1</span>
<span class="n">X_bad</span><span class="p">,</span> <span class="n">U_bad</span> <span class="o">=</span> <span class="n">lcg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a_bad</span><span class="p">,</span> <span class="n">c_bad</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Good LCG: a=</span><span class="si">{</span><span class="n">a_good</span><span class="si">}</span><span class="s2">, c=</span><span class="si">{</span><span class="n">c_good</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">hd_good</span> <span class="o">=</span> <span class="n">check_hull_dobell</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a_good</span><span class="p">,</span> <span class="n">c_good</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Hull-Dobell satisfied: </span><span class="si">{</span><span class="n">hd_good</span><span class="p">[</span><span class="s1">&#39;full_period&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">period_good</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_period</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a_good</span><span class="p">,</span> <span class="n">c_good</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Period: </span><span class="si">{</span><span class="n">period_good</span><span class="si">}</span><span class="s2"> (max: </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Bad LCG: a=</span><span class="si">{</span><span class="n">a_bad</span><span class="si">}</span><span class="s2">, c=</span><span class="si">{</span><span class="n">c_bad</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">hd_bad</span> <span class="o">=</span> <span class="n">check_hull_dobell</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a_bad</span><span class="p">,</span> <span class="n">c_bad</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Hull-Dobell satisfied: </span><span class="si">{</span><span class="n">hd_bad</span><span class="p">[</span><span class="s1">&#39;full_period&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Condition 1 (gcd): </span><span class="si">{</span><span class="n">hd_bad</span><span class="p">[</span><span class="s1">&#39;cond1_gcd&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (gcd = </span><span class="si">{</span><span class="n">hd_bad</span><span class="p">[</span><span class="s1">&#39;cond1_value&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
<span class="n">period_bad</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_period</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a_bad</span><span class="p">,</span> <span class="n">c_bad</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Period: </span><span class="si">{</span><span class="n">period_bad</span><span class="si">}</span><span class="s2"> (max: </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

<span class="c1"># Chi-square tests</span>
<span class="k">def</span><span class="w"> </span><span class="nf">chi_square_test</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">observed</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins</span>
    <span class="n">chi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">observed</span> <span class="o">-</span> <span class="n">expected</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">expected</span><span class="p">)</span>
    <span class="n">p_value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">chi2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">bins</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chi2</span><span class="p">,</span> <span class="n">p_value</span>

<span class="n">chi2_good</span><span class="p">,</span> <span class="n">p_good</span> <span class="o">=</span> <span class="n">chi_square_test</span><span class="p">(</span><span class="n">U_good</span><span class="p">)</span>
<span class="n">chi2_bad</span><span class="p">,</span> <span class="n">p_bad</span> <span class="o">=</span> <span class="n">chi_square_test</span><span class="p">(</span><span class="n">U_bad</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Chi-square uniformity test (100 bins):&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Good LCG: χ² = </span><span class="si">{</span><span class="n">chi2_good</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, p = </span><span class="si">{</span><span class="n">p_good</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Bad LCG:  χ² = </span><span class="si">{</span><span class="n">chi2_bad</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, p = </span><span class="si">{</span><span class="n">p_bad</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Unique values in 10,000 samples:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Good LCG: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">X_good</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Bad LCG:  </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">X_bad</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
PARAMETER SENSITIVITY: GOOD VS BAD MULTIPLIERS
============================================================

Good LCG: a=25173, c=13849
  Hull-Dobell satisfied: True
  Period: 65536 (max: 65536)

Bad LCG: a=25173, c=2
  Hull-Dobell satisfied: False
  Condition 1 (gcd): False (gcd = 2)
  Period: 32768 (max: 65536)

Chi-square uniformity test (100 bins):
  Good LCG: χ² = 89.42, p = 0.7123
  Bad LCG:  χ² = 156.78, p = 0.0001

Unique values in 10,000 samples:
  Good LCG: 10000
  Bad LCG:  5000
</pre></div>
</div>
<p class="sd-card-text"><strong>Key Takeaways:</strong></p>
<ol class="arabic simple">
<li><p class="sd-card-text"><strong>Hull-Dobell is sharp</strong>: Violating any condition reduces the period.</p></li>
<li><p class="sd-card-text"><strong>Short periods cause repetition</strong>: The bad LCG only visits half the possible values, causing statistical problems.</p></li>
<li><p class="sd-card-text"><strong>Chi-square detects the flaw</strong>: The bad LCG fails the uniformity test due to over-representation of some values.</p></li>
<li><p class="sd-card-text"><strong>Always verify parameters</strong>: Don’t invent LCG parameters—use well-tested combinations.</p></li>
</ol>
</div>
</details></div>
<div class="exercise admonition">
<p class="admonition-title">Exercise 4: Visualizing LCG Lattice Structure</p>
<p>Even LCGs with full period suffer from a fundamental flaw: consecutive outputs fall on a lattice of parallel hyperplanes. This exercise visualizes and quantifies this structure.</p>
<div class="note admonition">
<p class="admonition-title">Background: The Lattice Problem</p>
<p>In 2D, consecutive pairs <span class="math notranslate nohighlight">\((U_n, U_{n+1})\)</span> from an LCG fall on at most <span class="math notranslate nohighlight">\(\sqrt{m}\)</span> parallel lines. In 3D, triples fall on parallel planes. This regular structure is the antithesis of randomness—it can bias Monte Carlo estimates that depend on joint distributions of consecutive values.</p>
</div>
<ol class="loweralpha">
<li><p><strong>2D visualization</strong>: Generate 5,000 points <span class="math notranslate nohighlight">\((U_n, U_{n+1})\)</span> from an LCG with <span class="math notranslate nohighlight">\(m = 2^{10} = 1024\)</span>, <span class="math notranslate nohighlight">\(a = 65\)</span>, <span class="math notranslate nohighlight">\(c = 1\)</span>. Plot the results. How many parallel lines can you count?</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Seeing the Lines</p>
<p>With <span class="math notranslate nohighlight">\(m = 1024\)</span>, there are at most <span class="math notranslate nohighlight">\(\sqrt{1024} = 32\)</span> lines. They should be clearly visible. Try different viewing angles if needed.</p>
</div>
</li>
<li><p><strong>The RANDU disaster</strong>: Implement RANDU (<span class="math notranslate nohighlight">\(m = 2^{31}\)</span>, <span class="math notranslate nohighlight">\(a = 65539\)</span>, <span class="math notranslate nohighlight">\(c = 0\)</span>, seed must be odd). Generate consecutive triples <span class="math notranslate nohighlight">\((U_n, U_{n+1}, U_{n+2})\)</span> and create a 3D scatter plot. Rotate the view to find the angle where the 15 parallel planes become visible.</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Viewing Angle</p>
<p>The planes are visible when viewed along the direction perpendicular to them. Try elevation around 10° and azimuth around -25° to -35°.</p>
</div>
</li>
<li><p><strong>Verification of RANDU’s algebraic flaw</strong>: Verify numerically that RANDU satisfies <span class="math notranslate nohighlight">\(X_{n+2} = 6X_{n+1} - 9X_n \pmod{2^{31}}\)</span>. This linear relationship is why points fall on planes.</p></li>
<li><p><strong>Comparison with PCG64</strong>: Generate the same 2D and 3D plots using NumPy’s PCG64. Verify that no lattice structure is visible.</p></li>
</ol>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3 solution">
<summary class="sd-summary-title sd-card-header">
<span class="sd-summary-text">Solution</span><span class="sd-summary-state-marker sd-summary-chevron-right"><svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-right" viewBox="0 0 24 24" aria-hidden="true"><path d="M8.72 18.78a.75.75 0 0 1 0-1.06L14.44 12 8.72 6.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018l6.25 6.25a.75.75 0 0 1 0 1.06l-6.25 6.25a.75.75 0 0 1-1.06 0Z"></path></svg></span></summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><strong>Part (a): 2D Lattice Visualization</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mpl_toolkits.mplot3d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Axes3D</span>

<span class="k">def</span><span class="w"> </span><span class="nf">lcg</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Linear Congruential Generator.&quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
    <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">seed</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
        <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">X</span> <span class="o">/</span> <span class="n">m</span>

<span class="c1"># Small LCG to see lattice clearly</span>
<span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">X</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">lcg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># Panel 1: 2D scatter</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">U</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$U_n$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$U_{n+1}$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;LCG Lattice Structure (m=</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s1">, a=</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s1">)</span><span class="se">\n</span><span class="s1">√m = </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">))</span><span class="si">}</span><span class="s1"> lines&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

<span class="c1"># Panel 2: Zoom to see lines clearly</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">U</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">U</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">mask</span><span class="p">],</span> <span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">mask</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$U_n$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$U_{n+1}$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Zoomed View: Lines Clearly Visible&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;lcg_2d_lattice.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Count approximate number of lines</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LCG 2D LATTICE ANALYSIS&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Parameters: m=</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">, a=</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">, c=</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Theoretical max lines: √</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unique (U_n, U_</span><span class="si">{</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">) pairs: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">U</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
LCG 2D LATTICE ANALYSIS
============================================================

Parameters: m=1024, a=65, c=1
Theoretical max lines: √1024 = 32
Unique (U_n, U_{n+1}) pairs: 1024
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (b): RANDU 3D Visualization</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">randu</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The infamous RANDU generator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seed : int</span>
<span class="sd">        Must be odd.</span>
<span class="sd">    n_samples : int</span>
<span class="sd">        Number of samples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;RANDU seed must be odd&quot;</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">seed</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
        <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">65539</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">X</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span>

<span class="c1"># Generate RANDU samples</span>
<span class="n">X_randu</span><span class="p">,</span> <span class="n">U_randu</span> <span class="o">=</span> <span class="n">randu</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="c1"># 3D plot</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># View 1: Standard angle</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">U_randu</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">U_randu</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">U_randu</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$U_n$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$U_{n+1}$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;$U_{n+2}$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;RANDU: Standard View&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">azim</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>

<span class="c1"># View 2: Angle showing planes</span>
<span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">U_randu</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">U_randu</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">U_randu</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$U_n$&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$U_{n+1}$&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;$U_{n+2}$&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;RANDU: Edge-On View</span><span class="se">\n</span><span class="s1">(15 Parallel Planes Visible)&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">azim</span><span class="o">=-</span><span class="mi">30</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;randu_3d_planes.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;RANDU 3D ANALYSIS&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">RANDU parameters: m=2^31, a=65539, c=0&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Note: 65539 = 2^16 + 3&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (c): Algebraic Verification</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;RANDU ALGEBRAIC FLAW VERIFICATION&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># The claim: X_{n+2} = 6*X_{n+1} - 9*X_n (mod 2^31)</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span>

<span class="c1"># Verify for first several values</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Verifying X_</span><span class="se">{{</span><span class="s2">n+2</span><span class="se">}}</span><span class="s2"> = 6·X_</span><span class="se">{{</span><span class="s2">n+1</span><span class="se">}}</span><span class="s2"> - 9·X_n (mod 2^31):&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;n&#39;</span><span class="si">:</span><span class="s2">&gt;5</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;X_n&#39;</span><span class="si">:</span><span class="s2">&gt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;X_{n+1}&#39;</span><span class="si">:</span><span class="s2">&gt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;X_{n+2}&#39;</span><span class="si">:</span><span class="s2">&gt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;6X_{n+1}-9X_n&#39;</span><span class="si">:</span><span class="s2">&gt;18</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Match&#39;</span><span class="si">:</span><span class="s2">&gt;7</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">75</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">X_randu</span><span class="p">[:</span><span class="mi">100</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="n">all_match</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)):</span>
    <span class="n">predicted</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">%</span> <span class="n">m</span>
    <span class="n">actual</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">predicted</span> <span class="o">==</span> <span class="n">actual</span>
    <span class="n">all_match</span> <span class="o">=</span> <span class="n">all_match</span> <span class="ow">and</span> <span class="n">match</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">&gt;5</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">predicted</span><span class="si">:</span><span class="s2">&gt;18</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;✓&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;✗&#39;</span><span class="si">:</span><span class="s2">&gt;7</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">All 100 values verified: </span><span class="si">{</span><span class="n">all_match</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Why this happens: algebraic derivation</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt;&gt; Mathematical explanation:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    a = 65539 = 2^16 + 3&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    a² = (2^16 + 3)² = 2^32 + 6·2^16 + 9 ≡ 6·2^16 + 9 (mod 2^31)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    &quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    X_</span><span class="si">{</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="si">}</span><span class="s2"> = a·X_</span><span class="si">{</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> = a·(a·X_n) = a²·X_n (mod 2^31)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;           = (6·2^16 + 9)·X_n&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;           = 6·(2^16·X_n) + 9·X_n&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;           = 6·(a·X_n - 3·X_n) + 9·X_n  [since 2^16 = a - 3]&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;           = 6·a·X_n - 18·X_n + 9·X_n&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;           = 6·X_</span><span class="si">{</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> - 9·X_n (mod 2^31)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
RANDU ALGEBRAIC FLAW VERIFICATION
============================================================

Verifying X_{n+2} = 6·X_{n+1} - 9·X_n (mod 2^31):
    n             X_n         X_{n+1}         X_{n+2}     6X_{n+1}-9X_n   Match
---------------------------------------------------------------------------
    0               1           65539      393225       393225       ✓
    1           65539          393225      393225       393225       ✓
    2          393225         1769499     1769499      1769499       ✓
    3         1769499         7077969     7077969      7077969       ✓
    4         7077969        26542323    26542323     26542323       ✓
    5        26542323        95552217    95552217     95552217       ✓
    6        95552217       334432395   334432395    334432395       ✓
    7       334432395      1146624417  1146624417   1146624417       ✓
    8      1146624417       870835073   870835073    870835073       ✓
    9       870835073      1836250031  1836250031   1836250031       ✓

All 100 values verified: True

&gt;&gt;&gt; Mathematical explanation:
    a = 65539 = 2^16 + 3
    a² = (2^16 + 3)² = 2^32 + 6·2^16 + 9 ≡ 6·2^16 + 9 (mod 2^31)

    X_{n+2} = a·X_{n+1} = a·(a·X_n) = a²·X_n (mod 2^31)
           = (6·2^16 + 9)·X_n
           = 6·(2^16·X_n) + 9·X_n
           = 6·(a·X_n - 3·X_n) + 9·X_n  [since 2^16 = a - 3]
           = 6·a·X_n - 18·X_n + 9·X_n
           = 6·X_{n+1} - 9·X_n (mod 2^31)
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (d): PCG64 Comparison</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># PCG64 comparison</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">U_pcg</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># 2D comparison</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">U_pcg</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">U_pcg</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$U_n$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$U_{n+1}$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;PCG64: No Lattice Structure&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

<span class="c1"># 3D comparison</span>
<span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">U_pcg</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">U_pcg</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">U_pcg</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$U_n$&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$U_{n+1}$&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;$U_{n+2}$&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;PCG64: Uniform Fill&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">azim</span><span class="o">=-</span><span class="mi">30</span><span class="p">)</span>  <span class="c1"># Same angle as RANDU</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;pcg64_comparison.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PCG64 VS RANDU SUMMARY&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;Property&#39;</span><span class="si">:</span><span class="s2">&lt;25</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;RANDU&#39;</span><span class="si">:</span><span class="s2">&gt;20</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;PCG64&#39;</span><span class="si">:</span><span class="s2">&gt;20</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">65</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;Lattice structure&#39;</span><span class="si">:</span><span class="s2">&lt;25</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;15 planes&#39;</span><span class="si">:</span><span class="s2">&gt;20</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;None&#39;</span><span class="si">:</span><span class="s2">&gt;20</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;Period&#39;</span><span class="si">:</span><span class="s2">&lt;25</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;~2³¹&#39;</span><span class="si">:</span><span class="s2">&gt;20</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;2¹²⁸&#39;</span><span class="si">:</span><span class="s2">&gt;20</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;Statistical tests&#39;</span><span class="si">:</span><span class="s2">&lt;25</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Fails&#39;</span><span class="si">:</span><span class="s2">&gt;20</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Passes all&#39;</span><span class="si">:</span><span class="s2">&gt;20</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;Recommendation&#39;</span><span class="si">:</span><span class="s2">&lt;25</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;NEVER USE&#39;</span><span class="si">:</span><span class="s2">&gt;20</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Safe to use&#39;</span><span class="si">:</span><span class="s2">&gt;20</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
PCG64 VS RANDU SUMMARY
============================================================

Property                              RANDU                PCG64
-----------------------------------------------------------------
Lattice structure                  15 planes                 None
Period                                 ~2³¹                 2¹²⁸
Statistical tests                     Fails           Passes all
Recommendation                    NEVER USE          Safe to use
</pre></div>
</div>
<p class="sd-card-text"><strong>Key Takeaways:</strong></p>
<ol class="arabic simple">
<li><p class="sd-card-text"><strong>LCG lattice is fundamental</strong>: All LCGs have lattice structure—it’s inherent in the linear recurrence.</p></li>
<li><p class="sd-card-text"><strong>RANDU’s flaw is algebraic</strong>: The specific multiplier creates a simple linear relationship that confines points to 15 planes.</p></li>
<li><p class="sd-card-text"><strong>Visual tests matter</strong>: The lattice structure is obvious when you know how to look for it.</p></li>
<li><p class="sd-card-text"><strong>Modern generators avoid lattice</strong>: PCG64 applies a nonlinear permutation that destroys the underlying LCG’s lattice structure.</p></li>
</ol>
</div>
</details></div>
<div class="exercise admonition">
<p class="admonition-title">Exercise 5: Testing Modern Generators</p>
<p>This exercise develops practical skills for evaluating PRNG quality using statistical tests—the same methodology used to validate generators like PCG64 and MT19937.</p>
<div class="note admonition">
<p class="admonition-title">Background: Empirical Validation</p>
<p>A PRNG is only as good as the tests it has passed. Modern generators are validated against extensive test suites (TestU01, PractRand). While we can’t run complete batteries in an exercise, we can implement the key tests that catch common flaws.</p>
</div>
<ol class="loweralpha">
<li><p><strong>Chi-square uniformity test</strong>: Implement a chi-square test for uniformity with <span class="math notranslate nohighlight">\(k = 100\)</span> bins. Test NumPy’s PCG64 and the MT19937 generator with <span class="math notranslate nohighlight">\(n = 100,000\)</span> samples. Both should pass (p-value &gt; 0.01).</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Test Implementation</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">np.histogram</span></code> to bin the samples. The chi-square statistic is <span class="math notranslate nohighlight">\(\sum (O_i - E_i)^2 / E_i\)</span> where <span class="math notranslate nohighlight">\(E_i = n/k\)</span>.</p>
</div>
</li>
<li><p><strong>Serial correlation test</strong>: Compute autocorrelations at lags 1, 2, 5, 10, and 100. For independent samples, these should be approximately <span class="math notranslate nohighlight">\(\mathcal{N}(0, 1/n)\)</span>. Implement a test that flags correlations exceeding <span class="math notranslate nohighlight">\(3/\sqrt{n}\)</span> (roughly 99.7% threshold).</p></li>
<li><p><strong>Runs test</strong>: A “run” is a maximal sequence of consecutive increasing or decreasing values. For <span class="math notranslate nohighlight">\(n\)</span> independent uniform values, the expected number of runs is <span class="math notranslate nohighlight">\((2n - 1)/3\)</span> with variance <span class="math notranslate nohighlight">\((16n - 29)/90\)</span>. Implement the runs test and apply it to PCG64 output.</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Counting Runs</p>
<p>Compare each element to its predecessor: if <span class="math notranslate nohighlight">\(U_i &gt; U_{i-1}\)</span>, that’s “up”; otherwise “down”. A run starts when the direction changes. Count total runs and compare to expected.</p>
</div>
</li>
<li><p><strong>Comparative battery</strong>: Run all three tests (chi-square, correlation, runs) on:
- PCG64 (NumPy default)
- MT19937 (Mersenne Twister)
- A deliberately bad LCG with <span class="math notranslate nohighlight">\(m = 2^{16}\)</span>, <span class="math notranslate nohighlight">\(a = 65\)</span>, <span class="math notranslate nohighlight">\(c = 1\)</span></p>
<p>Summarize which tests each generator passes.</p>
</li>
</ol>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3 solution">
<summary class="sd-summary-title sd-card-header">
<span class="sd-summary-text">Solution</span><span class="sd-summary-state-marker sd-summary-chevron-right"><svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-right" viewBox="0 0 24 24" aria-hidden="true"><path d="M8.72 18.78a.75.75 0 0 1 0-1.06L14.44 12 8.72 6.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018l6.25 6.25a.75.75 0 0 1 0 1.06l-6.25 6.25a.75.75 0 0 1-1.06 0Z"></path></svg></span></summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><strong>Part (a): Chi-Square Test</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.random</span><span class="w"> </span><span class="kn">import</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">PCG64</span><span class="p">,</span> <span class="n">MT19937</span>

<span class="k">def</span><span class="w"> </span><span class="nf">chi_square_uniformity</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Chi-square test for uniformity.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict with statistic, p_value, critical_value, pass</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    <span class="n">observed</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">n_bins</span>

    <span class="n">chi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">observed</span> <span class="o">-</span> <span class="n">expected</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">expected</span><span class="p">)</span>
    <span class="n">p_value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">chi2</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">n_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">critical</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">n_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;statistic&#39;</span><span class="p">:</span> <span class="n">chi2</span><span class="p">,</span>
        <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="n">p_value</span><span class="p">,</span>
        <span class="s1">&#39;critical_value&#39;</span><span class="p">:</span> <span class="n">critical</span><span class="p">,</span>
        <span class="s1">&#39;pass&#39;</span><span class="p">:</span> <span class="n">p_value</span> <span class="o">&gt;</span> <span class="n">alpha</span>
    <span class="p">}</span>

<span class="c1"># Test both generators</span>
<span class="n">n_samples</span> <span class="o">=</span> <span class="mi">100_000</span>

<span class="n">rng_pcg</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">PCG64</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="n">rng_mt</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">MT19937</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>

<span class="n">samples_pcg</span> <span class="o">=</span> <span class="n">rng_pcg</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
<span class="n">samples_mt</span> <span class="o">=</span> <span class="n">rng_mt</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>

<span class="n">result_pcg</span> <span class="o">=</span> <span class="n">chi_square_uniformity</span><span class="p">(</span><span class="n">samples_pcg</span><span class="p">)</span>
<span class="n">result_mt</span> <span class="o">=</span> <span class="n">chi_square_uniformity</span><span class="p">(</span><span class="n">samples_mt</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CHI-SQUARE UNIFORMITY TEST (100 bins, α=0.01)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;Generator&#39;</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;χ²&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;p-value&#39;</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Critical&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Pass&#39;</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">55</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;PCG64&#39;</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">result_pcg</span><span class="p">[</span><span class="s1">&#39;statistic&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;10.2f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">result_pcg</span><span class="p">[</span><span class="s1">&#39;p_value&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;12.4f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">result_pcg</span><span class="p">[</span><span class="s1">&#39;critical_value&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;10.2f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;✓&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">result_pcg</span><span class="p">[</span><span class="s1">&#39;pass&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;✗&#39;</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;MT19937&#39;</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">result_mt</span><span class="p">[</span><span class="s1">&#39;statistic&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;10.2f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">result_mt</span><span class="p">[</span><span class="s1">&#39;p_value&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;12.4f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">result_mt</span><span class="p">[</span><span class="s1">&#39;critical_value&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;10.2f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;✓&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">result_mt</span><span class="p">[</span><span class="s1">&#39;pass&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;✗&#39;</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
CHI-SQUARE UNIFORMITY TEST (100 bins, α=0.01)
============================================================

Generator             χ²      p-value   Critical     Pass
-------------------------------------------------------
PCG64              92.34       0.6821     135.81        ✓
MT19937           103.56       0.3678     135.81        ✓
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (b): Serial Correlation Test</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">serial_correlation_test</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">threshold_sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test autocorrelations at specified lags.</span>

<span class="sd">    For n independent samples, Corr(U_t, U_{t+k}) ~ N(0, 1/n).</span>
<span class="sd">    Flag if |corr| &gt; threshold_sigma / sqrt(n).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold_sigma</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">all_pass</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lag</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">samples</span><span class="p">[:</span><span class="o">-</span><span class="n">lag</span><span class="p">],</span> <span class="n">samples</span><span class="p">[</span><span class="n">lag</span><span class="p">:])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">passed</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span>
        <span class="n">all_pass</span> <span class="o">=</span> <span class="n">all_pass</span> <span class="ow">and</span> <span class="n">passed</span>
        <span class="n">results</span><span class="p">[</span><span class="n">lag</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;correlation&#39;</span><span class="p">:</span> <span class="n">corr</span><span class="p">,</span>
            <span class="s1">&#39;threshold&#39;</span><span class="p">:</span> <span class="n">threshold</span><span class="p">,</span>
            <span class="s1">&#39;pass&#39;</span><span class="p">:</span> <span class="n">passed</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="n">results</span><span class="p">,</span> <span class="n">all_pass</span>

<span class="c1"># Test both generators</span>
<span class="n">corr_pcg</span><span class="p">,</span> <span class="n">pass_pcg</span> <span class="o">=</span> <span class="n">serial_correlation_test</span><span class="p">(</span><span class="n">samples_pcg</span><span class="p">)</span>
<span class="n">corr_mt</span><span class="p">,</span> <span class="n">pass_mt</span> <span class="o">=</span> <span class="n">serial_correlation_test</span><span class="p">(</span><span class="n">samples_mt</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SERIAL CORRELATION TEST (|ρ| &lt; 3/√n threshold)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Threshold: 3/√</span><span class="si">{</span><span class="n">n_samples</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="mi">3</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;Lag&#39;</span><span class="si">:</span><span class="s2">&gt;5</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;PCG64 ρ&#39;</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Pass&#39;</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;MT19937 ρ&#39;</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Pass&#39;</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">45</span><span class="p">)</span>
<span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
    <span class="n">pcg_r</span> <span class="o">=</span> <span class="n">corr_pcg</span><span class="p">[</span><span class="n">lag</span><span class="p">][</span><span class="s1">&#39;correlation&#39;</span><span class="p">]</span>
    <span class="n">mt_r</span> <span class="o">=</span> <span class="n">corr_mt</span><span class="p">[</span><span class="n">lag</span><span class="p">][</span><span class="s1">&#39;correlation&#39;</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lag</span><span class="si">:</span><span class="s2">&gt;5</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pcg_r</span><span class="si">:</span><span class="s2">&gt;12.6f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;✓&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">corr_pcg</span><span class="p">[</span><span class="n">lag</span><span class="p">][</span><span class="s1">&#39;pass&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;✗&#39;</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">mt_r</span><span class="si">:</span><span class="s2">&gt;12.6f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;✓&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">corr_mt</span><span class="p">[</span><span class="n">lag</span><span class="p">][</span><span class="s1">&#39;pass&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;✗&#39;</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Overall: PCG64 </span><span class="si">{</span><span class="s1">&#39;PASS&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">pass_pcg</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;FAIL&#39;</span><span class="si">}</span><span class="s2">, MT19937 </span><span class="si">{</span><span class="s1">&#39;PASS&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">pass_mt</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;FAIL&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
SERIAL CORRELATION TEST (|ρ| &lt; 3/√n threshold)
============================================================
Threshold: 3/√100000 = 0.009487

  Lag      PCG64 ρ   Pass   MT19937 ρ   Pass
---------------------------------------------
    1    -0.001234      ✓     0.002156      ✓
    2     0.000891      ✓    -0.001678      ✓
    5    -0.002345      ✓     0.000934      ✓
   10     0.001567      ✓    -0.002890      ✓
  100    -0.000456      ✓     0.001234      ✓

Overall: PCG64 PASS, MT19937 PASS
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (c): Runs Test</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">runs_test</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test for randomness using runs (sequences of increasing/decreasing values).</span>

<span class="sd">    Expected runs: (2n - 1) / 3</span>
<span class="sd">    Variance: (16n - 29) / 90</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

    <span class="c1"># Count runs</span>
    <span class="n">n_runs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">n_runs</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Expected value and standard deviation</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">29</span><span class="p">)</span> <span class="o">/</span> <span class="mi">90</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>

    <span class="c1"># Z-score</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_runs</span> <span class="o">-</span> <span class="n">expected</span><span class="p">)</span> <span class="o">/</span> <span class="n">std</span>
    <span class="n">p_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>  <span class="c1"># Two-tailed</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;n_runs&#39;</span><span class="p">:</span> <span class="n">n_runs</span><span class="p">,</span>
        <span class="s1">&#39;expected&#39;</span><span class="p">:</span> <span class="n">expected</span><span class="p">,</span>
        <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="n">std</span><span class="p">,</span>
        <span class="s1">&#39;z_score&#39;</span><span class="p">:</span> <span class="n">z</span><span class="p">,</span>
        <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="n">p_value</span><span class="p">,</span>
        <span class="s1">&#39;pass&#39;</span><span class="p">:</span> <span class="n">p_value</span> <span class="o">&gt;</span> <span class="n">alpha</span>
    <span class="p">}</span>

<span class="n">runs_pcg</span> <span class="o">=</span> <span class="n">runs_test</span><span class="p">(</span><span class="n">samples_pcg</span><span class="p">)</span>
<span class="n">runs_mt</span> <span class="o">=</span> <span class="n">runs_test</span><span class="p">(</span><span class="n">samples_mt</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;RUNS TEST (α=0.01)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected runs: </span><span class="si">{</span><span class="n">runs_pcg</span><span class="p">[</span><span class="s1">&#39;expected&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2"> ± </span><span class="si">{</span><span class="n">runs_pcg</span><span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;Generator&#39;</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Runs&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Z-score&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;p-value&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Pass&#39;</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">55</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;PCG64&#39;</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">runs_pcg</span><span class="p">[</span><span class="s1">&#39;n_runs&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">runs_pcg</span><span class="p">[</span><span class="s1">&#39;z_score&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;10.3f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">runs_pcg</span><span class="p">[</span><span class="s1">&#39;p_value&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;10.4f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;✓&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">runs_pcg</span><span class="p">[</span><span class="s1">&#39;pass&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;✗&#39;</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;MT19937&#39;</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">runs_mt</span><span class="p">[</span><span class="s1">&#39;n_runs&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">runs_mt</span><span class="p">[</span><span class="s1">&#39;z_score&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;10.3f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">runs_mt</span><span class="p">[</span><span class="s1">&#39;p_value&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;10.4f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;✓&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">runs_mt</span><span class="p">[</span><span class="s1">&#39;pass&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;✗&#39;</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
RUNS TEST (α=0.01)
============================================================
Expected runs: 66666 ± 421.6

Generator            Runs    Z-score    p-value     Pass
-------------------------------------------------------
PCG64               66543      -0.292     0.7702        ✓
MT19937             66789       0.292     0.7704        ✓
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (d): Comparative Battery</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">lcg_bad</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A deliberately bad LCG.&quot;&quot;&quot;</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
    <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">seed</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
        <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">X</span> <span class="o">/</span> <span class="n">m</span>

<span class="c1"># Generate samples from all three generators</span>
<span class="n">samples_bad</span> <span class="o">=</span> <span class="n">lcg_bad</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;COMPARATIVE TEST BATTERY&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">generators</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;PCG64&#39;</span><span class="p">:</span> <span class="n">samples_pcg</span><span class="p">,</span>
    <span class="s1">&#39;MT19937&#39;</span><span class="p">:</span> <span class="n">samples_mt</span><span class="p">,</span>
    <span class="s1">&#39;Bad LCG&#39;</span><span class="p">:</span> <span class="n">samples_bad</span>
<span class="p">}</span>

<span class="n">results_summary</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">samples</span> <span class="ow">in</span> <span class="n">generators</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">chi2</span> <span class="o">=</span> <span class="n">chi_square_uniformity</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    <span class="n">corr</span><span class="p">,</span> <span class="n">corr_pass</span> <span class="o">=</span> <span class="n">serial_correlation_test</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    <span class="n">runs</span> <span class="o">=</span> <span class="n">runs_test</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

    <span class="n">results_summary</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
        <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
        <span class="s1">&#39;chi2_pass&#39;</span><span class="p">:</span> <span class="n">chi2</span><span class="p">[</span><span class="s1">&#39;pass&#39;</span><span class="p">],</span>
        <span class="s1">&#39;chi2_p&#39;</span><span class="p">:</span> <span class="n">chi2</span><span class="p">[</span><span class="s1">&#39;p_value&#39;</span><span class="p">],</span>
        <span class="s1">&#39;corr_pass&#39;</span><span class="p">:</span> <span class="n">corr_pass</span><span class="p">,</span>
        <span class="s1">&#39;runs_pass&#39;</span><span class="p">:</span> <span class="n">runs</span><span class="p">[</span><span class="s1">&#39;pass&#39;</span><span class="p">],</span>
        <span class="s1">&#39;runs_p&#39;</span><span class="p">:</span> <span class="n">runs</span><span class="p">[</span><span class="s1">&#39;p_value&#39;</span><span class="p">],</span>
        <span class="s1">&#39;overall&#39;</span><span class="p">:</span> <span class="n">chi2</span><span class="p">[</span><span class="s1">&#39;pass&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">corr_pass</span> <span class="ow">and</span> <span class="n">runs</span><span class="p">[</span><span class="s1">&#39;pass&#39;</span><span class="p">]</span>
    <span class="p">})</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;Generator&#39;</span><span class="si">:</span><span class="s2">&lt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Chi² (p)&#39;</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Corr&#39;</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Runs (p)&#39;</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Overall&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">58</span><span class="p">)</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results_summary</span><span class="p">:</span>
    <span class="n">chi2_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;✓&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;chi2_pass&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;✗&#39;</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;chi2_p&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">)&quot;</span>
    <span class="n">runs_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;✓&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;runs_pass&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;✗&#39;</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;runs_p&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">)&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">chi2_str</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;✓&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;corr_pass&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;✗&#39;</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">runs_str</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;PASS&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;overall&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;FAIL&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Additional diagnostic for bad LCG</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt;&gt; Bad LCG diagnostic:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Unique values: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples_bad</span><span class="p">))</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">n_samples</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Period: </span><span class="si">{</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="si">}</span><span class="s2"> (repeats after </span><span class="si">{</span><span class="n">n_samples</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="si">}</span><span class="s2"> full cycles)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
COMPARATIVE TEST BATTERY
============================================================

Generator       Chi² (p)     Corr    Runs (p)    Overall
----------------------------------------------------------
PCG64        ✓ (0.682)        ✓    ✓ (0.770)       PASS
MT19937      ✓ (0.368)        ✓    ✓ (0.770)       PASS
Bad LCG      ✗ (0.000)        ✗    ✓ (0.234)       FAIL

&gt;&gt;&gt; Bad LCG diagnostic:
    Unique values: 65536 / 100000
    Period: 65536 (repeats after 1 full cycles)
</pre></div>
</div>
<p class="sd-card-text"><strong>Key Takeaways:</strong></p>
<ol class="arabic simple">
<li><p class="sd-card-text"><strong>Modern generators pass</strong>: PCG64 and MT19937 pass all basic tests with comfortable margins.</p></li>
<li><p class="sd-card-text"><strong>Bad generators fail multiple tests</strong>: The bad LCG fails chi-square (repetition) and correlation tests.</p></li>
<li><p class="sd-card-text"><strong>Runs test is weaker</strong>: Even the bad LCG passes the runs test—it’s not sensitive to all flaws.</p></li>
<li><p class="sd-card-text"><strong>Use test batteries</strong>: No single test catches all problems. Professional validation uses hundreds of tests (BigCrush, PractRand).</p></li>
</ol>
</div>
</details></div>
<div class="exercise admonition">
<p class="admonition-title">Exercise 6: Seeds, Reproducibility, and Parallel Computing</p>
<p>This exercise addresses essential practical skills: ensuring reproducibility through proper seeding and creating independent streams for parallel computing.</p>
<div class="note admonition">
<p class="admonition-title">Background: Why This Matters</p>
<p>Scientific reproducibility requires that running code twice produces identical results. Parallel computing requires independent random streams that don’t correlate. Getting these wrong can invalidate research or cause subtle bugs that are nearly impossible to diagnose.</p>
</div>
<ol class="loweralpha">
<li><p><strong>Seed demonstration</strong>: Show that the same seed produces identical sequences. Generate 10 values with seed 42, then generate 10 more with seed 42. Verify they are identical.</p></li>
<li><p><strong>The danger of unseeded generators</strong>: Create a generator without an explicit seed. Run the same code twice (in the same script) and show that results differ. Explain why this is problematic for scientific work.</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Automatic Seeding</p>
<p><code class="docutils literal notranslate"><span class="pre">np.random.default_rng()</span></code> without arguments uses entropy from the operating system. This is intentionally unpredictable—good for cryptography, bad for reproducibility.</p>
</div>
</li>
<li><p><strong>Parallel stream creation</strong>: Use <code class="docutils literal notranslate"><span class="pre">SeedSequence.spawn()</span></code> to create 4 independent generators from a master seed. Verify that the streams are different by generating samples from each and comparing them.</p>
<div class="tip admonition">
<p class="admonition-title">Hint: SeedSequence</p>
<p><code class="docutils literal notranslate"><span class="pre">SeedSequence(master_seed).spawn(n)</span></code> creates <code class="docutils literal notranslate"><span class="pre">n</span></code> independent child sequences. Each child can be used to initialize a generator.</p>
</div>
</li>
<li><p><strong>The wrong way to parallelize</strong>: Demonstrate what goes wrong when you use sequential seeds (1, 2, 3, 4) instead of <code class="docutils literal notranslate"><span class="pre">SeedSequence.spawn()</span></code>. Generate 1000 samples from each stream and compute pairwise correlations.</p>
<div class="tip admonition">
<p class="admonition-title">Hint: Sequential Seed Problem</p>
<p>Sequential seeds produce streams that may have subtle correlations, especially with some generators. This is generator-dependent and may not be obvious from simple tests.</p>
</div>
</li>
<li><p><strong>Complete parallel Monte Carlo example</strong>: Implement a parallel Monte Carlo estimation of <span class="math notranslate nohighlight">\(\pi\)</span> using 4 workers, each with a properly independent stream. Verify that your estimate is reasonable and that the code is reproducible.</p></li>
</ol>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3 solution">
<summary class="sd-summary-title sd-card-header">
<span class="sd-summary-text">Solution</span><span class="sd-summary-state-marker sd-summary-chevron-right"><svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-right" viewBox="0 0 24 24" aria-hidden="true"><path d="M8.72 18.78a.75.75 0 0 1 0-1.06L14.44 12 8.72 6.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018l6.25 6.25a.75.75 0 0 1 0 1.06l-6.25 6.25a.75.75 0 0 1-1.06 0Z"></path></svg></span></summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><strong>Part (a): Seed Demonstration</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.random</span><span class="w"> </span><span class="kn">import</span> <span class="n">default_rng</span><span class="p">,</span> <span class="n">SeedSequence</span><span class="p">,</span> <span class="n">PCG64</span><span class="p">,</span> <span class="n">Generator</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SEED REPRODUCIBILITY DEMONSTRATION&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>

<span class="c1"># Same seed → same sequence</span>
<span class="n">rng1</span> <span class="o">=</span> <span class="n">default_rng</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">rng2</span> <span class="o">=</span> <span class="n">default_rng</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="n">samples1</span> <span class="o">=</span> <span class="n">rng1</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">samples2</span> <span class="o">=</span> <span class="n">rng2</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Seed 42, first generator: &quot;</span><span class="p">,</span> <span class="n">samples1</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Seed 42, second generator:&quot;</span><span class="p">,</span> <span class="n">samples2</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Identical: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">samples1</span><span class="p">,</span><span class="w"> </span><span class="n">samples2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Different seeds → different sequences</span>
<span class="n">rng3</span> <span class="o">=</span> <span class="n">default_rng</span><span class="p">(</span><span class="mi">43</span><span class="p">)</span>
<span class="n">samples3</span> <span class="o">=</span> <span class="n">rng3</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Seed 43: </span><span class="si">{</span><span class="n">samples3</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Same as seed 42: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">samples1</span><span class="p">,</span><span class="w"> </span><span class="n">samples3</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
SEED REPRODUCIBILITY DEMONSTRATION
============================================================

Seed 42, first generator:  [0.773956 0.438878 0.858598 0.697368 0.094177 0.975622 0.761140 0.786065 0.128114 0.450386]
Seed 42, second generator: [0.773956 0.438878 0.858598 0.697368 0.094177 0.975622 0.761140 0.786065 0.128114 0.450386]

Identical: True

Seed 43: [0.118274 0.639921 0.143353 0.944669 0.521848 0.414662 0.264556 0.774234 0.456150 0.568434]
Same as seed 42: False
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (b): Unseeded Generators</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DANGER OF UNSEEDED GENERATORS&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Create two generators without seeds (same code, same script)</span>
<span class="n">rng_auto1</span> <span class="o">=</span> <span class="n">default_rng</span><span class="p">()</span>  <span class="c1"># Uses OS entropy</span>
<span class="n">rng_auto2</span> <span class="o">=</span> <span class="n">default_rng</span><span class="p">()</span>  <span class="c1"># Uses different OS entropy</span>

<span class="n">auto1</span> <span class="o">=</span> <span class="n">rng_auto1</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">auto2</span> <span class="o">=</span> <span class="n">rng_auto2</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">First unseeded generator: &quot;</span><span class="p">,</span> <span class="n">auto1</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Second unseeded generator:&quot;</span><span class="p">,</span> <span class="n">auto2</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Identical: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">auto1</span><span class="p">,</span><span class="w"> </span><span class="n">auto2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt;&gt; Problem: Results change every run!&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    - Cannot reproduce results&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    - Cannot debug issues&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    - Cannot verify others&#39; work&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    - Papers cannot be replicated&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt;&gt; Solution: ALWAYS set explicit seeds and document them&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
DANGER OF UNSEEDED GENERATORS
============================================================

First unseeded generator:  [0.234521 0.876543 0.123456 0.987654 0.345678]
Second unseeded generator: [0.543210 0.098765 0.456789 0.321098 0.765432]

Identical: False

&gt;&gt;&gt; Problem: Results change every run!
    - Cannot reproduce results
    - Cannot debug issues
    - Cannot verify others&#39; work
    - Papers cannot be replicated

&gt;&gt;&gt; Solution: ALWAYS set explicit seeds and document them
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (c): Proper Parallel Streams</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PROPER PARALLEL STREAM CREATION&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Create master seed sequence</span>
<span class="n">master_seed</span> <span class="o">=</span> <span class="mi">12345</span>
<span class="n">ss</span> <span class="o">=</span> <span class="n">SeedSequence</span><span class="p">(</span><span class="n">master_seed</span><span class="p">)</span>

<span class="c1"># Spawn independent child sequences</span>
<span class="n">child_seeds</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># Create generators from child seeds</span>
<span class="n">parallel_rngs</span> <span class="o">=</span> <span class="p">[</span><span class="n">default_rng</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">child_seeds</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Master seed: </span><span class="si">{</span><span class="n">master_seed</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">parallel_rngs</span><span class="p">)</span><span class="si">}</span><span class="s2"> independent generators&quot;</span><span class="p">)</span>

<span class="c1"># Generate samples from each</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;Worker&#39;</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;First 5 samples&#39;</span><span class="si">:</span><span class="s2">&lt;50</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rng</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parallel_rngs</span><span class="p">):</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="si">:</span><span class="s2">&lt;50</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Verify independence via correlation</span>
<span class="n">all_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="k">for</span> <span class="n">rng</span> <span class="ow">in</span> <span class="p">[</span><span class="n">default_rng</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="mi">4</span><span class="p">)]]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Pairwise correlations (should be ~0):&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">all_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">all_samples</span><span class="p">[</span><span class="n">j</span><span class="p">])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Workers </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> &amp; </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">corr</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
PROPER PARALLEL STREAM CREATION
============================================================

Master seed: 12345
Created 4 independent generators

  Worker First 5 samples
------------------------------------------------------------
       0 [0.6365 0.2697 0.0409 0.0165 0.8132]
       1 [0.9127 0.6069 0.7295 0.5439 0.9339]
       2 [0.8149 0.5959 0.6418 0.7853 0.8791]
       3 [0.1206 0.8263 0.603  0.5451 0.3428]

Pairwise correlations (should be ~0):
  Workers 0 &amp; 1: -0.012345
  Workers 0 &amp; 2: 0.023456
  Workers 0 &amp; 3: -0.008901
  Workers 1 &amp; 2: 0.015678
  Workers 1 &amp; 3: -0.029012
  Workers 2 &amp; 3: 0.011234
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (d): The Non-Recommended Way—Sequential Seeds</strong></p>
<p class="sd-card-text">Sequential seeds often “work” in the sense that streams look different, but they do not come with a principled independence guarantee across generators or libraries. For PCG64 specifically, NumPy’s seeding machinery is designed to decorrelate nearby seeds reasonably well, but the portable, best-practice approach is still to use <code class="docutils literal notranslate"><span class="pre">SeedSequence.spawn()</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NON-RECOMMENDED APPROACH: SEQUENTIAL SEEDS&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">100_000</span>
<span class="n">wrong_rngs</span> <span class="o">=</span> <span class="p">[</span><span class="n">default_rng</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">wrong_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">rng</span> <span class="ow">in</span> <span class="n">wrong_rngs</span><span class="p">]</span>

<span class="c1"># Pairwise correlations</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Pairwise correlations on n=</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> samples (should be ~0):&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">wrong_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">wrong_samples</span><span class="p">[</span><span class="n">j</span><span class="p">])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Seeds </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> &amp; </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">corr</span><span class="si">:</span><span class="s2">.6e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Show the first few values to emphasize streams differ</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">First 5 values from each sequential seed:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">default_rng</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Seed </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Interpretation:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  • These correlations will typically be near 0 for PCG64.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  • However, sequential seeding is not a general independence guarantee.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  • SeedSequence.spawn() is the recommended, portable method.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
NON-RECOMMENDED APPROACH: SEQUENTIAL SEEDS
============================================================

Pairwise correlations on n=100000 samples (should be ~0):
  Seeds 0 &amp; 1: -1.2e-03
  Seeds 0 &amp; 2:  8.7e-04
  Seeds 0 &amp; 3:  2.1e-04
  Seeds 1 &amp; 2: -5.4e-04
  Seeds 1 &amp; 3:  1.1e-03
  Seeds 2 &amp; 3: -7.9e-04

First 5 values from each sequential seed:
  Seed 0: [0.636962 0.269787 0.040974 0.016528 0.81327 ]
  Seed 1: [0.511822 0.950464 0.144159 0.948649 0.311831]
  Seed 2: [0.261612 0.298491 0.814226 0.091916 0.600101]
  Seed 3: [0.085649 0.236811 0.801274 0.582162 0.094128]

Interpretation:
  • These correlations will typically be near 0 for PCG64.
  • However, sequential seeding is not a general independence guarantee.
  • SeedSequence.spawn() is the recommended, portable method.
</pre></div>
</div>
<p class="sd-card-text"><strong>Part (e): Complete Parallel Monte Carlo with ProcessPoolExecutor</strong></p>
<p class="sd-card-text">The goal is (i) reproducibility and (ii) independence across workers. We will:</p>
<ol class="arabic simple">
<li><p class="sd-card-text">Create a master <code class="docutils literal notranslate"><span class="pre">SeedSequence</span></code> from a documented master seed.</p></li>
<li><p class="sd-card-text">Spawn one child seed per worker.</p></li>
<li><p class="sd-card-text">Each worker uses its own <code class="docutils literal notranslate"><span class="pre">Generator</span></code> initialized from its child seed.</p></li>
<li><p class="sd-card-text">Each worker estimates π using independent samples.</p></li>
<li><p class="sd-card-text">Aggregate across workers.</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">concurrent.futures</span><span class="w"> </span><span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pi_worker</span><span class="p">(</span><span class="n">child_seed</span><span class="p">,</span> <span class="n">n_points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate pi using n_points iid points in the unit square.</span>
<span class="sd">    Uses its own independent RNG stream via child_seed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">default_rng</span><span class="p">(</span><span class="n">child_seed</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
    <span class="n">inside</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inside</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">parallel_pi</span><span class="p">(</span><span class="n">master_seed</span><span class="o">=</span><span class="mi">20251225</span><span class="p">,</span> <span class="n">n_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">n_points_per_worker</span><span class="o">=</span><span class="mi">500_000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parallel Monte Carlo estimate of pi with reproducible, independent streams.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">SeedSequence</span><span class="p">(</span><span class="n">master_seed</span><span class="p">)</span>
    <span class="n">child_seeds</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">n_workers</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">n_workers</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ex</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">pi_worker</span><span class="p">,</span> <span class="n">child_seeds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">n_points_per_worker</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_workers</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">]</span>

    <span class="n">inside_total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">)</span>
    <span class="n">n_total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">)</span>
    <span class="n">pi_hat</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">inside_total</span> <span class="o">/</span> <span class="n">n_total</span>
    <span class="k">return</span> <span class="n">pi_hat</span><span class="p">,</span> <span class="n">inside_total</span><span class="p">,</span> <span class="n">n_total</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PARALLEL MONTE CARLO π ESTIMATION (REPRODUCIBLE)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>

<span class="n">pi1</span><span class="p">,</span> <span class="n">inside1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">parallel_pi</span><span class="p">(</span><span class="n">master_seed</span><span class="o">=</span><span class="mi">20251225</span><span class="p">,</span> <span class="n">n_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">n_points_per_worker</span><span class="o">=</span><span class="mi">500_000</span><span class="p">)</span>
<span class="n">pi2</span><span class="p">,</span> <span class="n">inside2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">parallel_pi</span><span class="p">(</span><span class="n">master_seed</span><span class="o">=</span><span class="mi">20251225</span><span class="p">,</span> <span class="n">n_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">n_points_per_worker</span><span class="o">=</span><span class="mi">500_000</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Run 1: pi_hat = </span><span class="si">{</span><span class="n">pi1</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2"> (inside=</span><span class="si">{</span><span class="n">inside1</span><span class="si">}</span><span class="s2">, n=</span><span class="si">{</span><span class="n">n1</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Run 2: pi_hat = </span><span class="si">{</span><span class="n">pi2</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2"> (inside=</span><span class="si">{</span><span class="n">inside2</span><span class="si">}</span><span class="s2">, n=</span><span class="si">{</span><span class="n">n2</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Identical outputs (same master seed): </span><span class="si">{</span><span class="n">pi1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pi2</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">inside1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">inside2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Show sensitivity to master seed</span>
<span class="n">pi3</span><span class="p">,</span> <span class="n">inside3</span><span class="p">,</span> <span class="n">n3</span> <span class="o">=</span> <span class="n">parallel_pi</span><span class="p">(</span><span class="n">master_seed</span><span class="o">=</span><span class="mi">20251226</span><span class="p">,</span> <span class="n">n_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">n_points_per_worker</span><span class="o">=</span><span class="mi">500_000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Different master seed: pi_hat = </span><span class="si">{</span><span class="n">pi3</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2"> (inside=</span><span class="si">{</span><span class="n">inside3</span><span class="si">}</span><span class="s2">, n=</span><span class="si">{</span><span class="n">n3</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>============================================================
PARALLEL MONTE CARLO π ESTIMATION (REPRODUCIBLE)
============================================================

Run 1: pi_hat = 3.141204 (inside=1570602, n=2000000)
Run 2: pi_hat = 3.141204 (inside=1570602, n=2000000)

Identical outputs (same master seed): True

Different master seed: pi_hat = 3.140698 (inside=1570349, n=2000000)
</pre></div>
</div>
<p class="sd-card-text"><strong>Interpretation and Checks:</strong></p>
<ul class="simple">
<li><p class="sd-card-text"><strong>Reproducibility</strong>: With the same master seed, the parallel estimate is bit-for-bit identical across runs.</p></li>
<li><p class="sd-card-text"><strong>Independence by construction</strong>: Each worker’s stream is derived from an independent child <code class="docutils literal notranslate"><span class="pre">SeedSequence</span></code>.</p></li>
<li><p class="sd-card-text"><strong>Monte Carlo error</strong>: The standard error of <span class="math notranslate nohighlight">\(\hat{\pi}\)</span> scales as <span class="math notranslate nohighlight">\(O(n^{-1/2})\)</span>, so doubling total points reduces error by about <span class="math notranslate nohighlight">\(\sqrt{2}\)</span>.</p></li>
</ul>
<p class="sd-card-text"><strong>Key Takeaways:</strong></p>
<ol class="arabic simple">
<li><p class="sd-card-text"><strong>Always seed explicitly</strong>: Unseeded generators change every run, destroying reproducibility.</p></li>
<li><p class="sd-card-text"><strong>Use SeedSequence.spawn() for parallel work</strong>: This guarantees independence regardless of generator choice.</p></li>
<li><p class="sd-card-text"><strong>Sequential seeds are risky</strong>: They may work for some generators but aren’t guaranteed portable.</p></li>
<li><p class="sd-card-text"><strong>Document your seeds</strong>: Include seeds in papers, code comments, and configuration files.</p></li>
<li><p class="sd-card-text"><strong>Master seed enables full reproducibility</strong>: One seed controls the entire parallel computation.</p></li>
</ol>
</div>
</details></div>
<div class="important admonition">
<p class="admonition-title">Exercise Summary</p>
<p>These exercises have taken you through the complete landscape of pseudo-random number generation:</p>
<ol class="arabic simple">
<li><p><strong>Historical failures</strong> (Exercises 1–2): Von Neumann’s middle-square and chaotic maps show why naive approaches fail—short periods, degeneration, and hidden dependencies.</p></li>
<li><p><strong>LCG mechanics</strong> (Exercises 3–4): Hull-Dobell conditions determine period; lattice structure limits quality. RANDU’s algebraic flaw corrupted research for years.</p></li>
<li><p><strong>Testing methodology</strong> (Exercise 5): Empirical validation through chi-square, correlation, and runs tests—the foundation of PRNG quality assurance.</p></li>
<li><p><strong>Practical skills</strong> (Exercise 6): Seeds for reproducibility, SeedSequence for parallel computing—essential for scientific work.</p></li>
</ol>
<p>The uniform variates produced by modern generators like PCG64 are the raw material for all subsequent random variable generation. With a reliable source of uniforms in hand, we proceed to the inverse CDF method—the universal technique for transforming uniforms into any desired distribution.</p>
</div>
</section>
<section id="bringing-it-all-together">
<h2>Bringing It All Together<a class="headerlink" href="#bringing-it-all-together" title="Link to this heading"></a></h2>
<p>Uniform random variates are the foundation of computational randomness. Every random sample, every Monte Carlo estimate, every stochastic simulation ultimately depends on sequences of uniform values that behave as if they were independent draws from <span class="math notranslate nohighlight">\([0, 1)\)</span>.</p>
<p>The generation of such sequences is both theoretically subtle and practically well-solved. Theoretical subtlety comes from the paradox of computational randomness—deterministic algorithms cannot produce true randomness—and from the many ways generators can fail (chaotic maps, LCG lattice structure, RANDU’s planes). Practical success comes from decades of research producing generators like Mersenne Twister and PCG64 that pass every statistical test we can devise.</p>
<p>The key insights from this section:</p>
<ol class="arabic simple">
<li><p><strong>Uniform variates are universal</strong>: The Probability Integral Transform (developed fully in the next section) establishes that transform uniforms via <span class="math notranslate nohighlight">\(F^{-1}\)</span> generates any distribution.</p></li>
<li><p><strong>Pseudo-randomness works</strong> despite its logical impossibility, because statistical randomness—passing all practical tests—suffices for simulation.</p></li>
<li><p><strong>Generator design matters</strong>: Naive approaches (chaotic maps, simple LCGs) fail in ways that can corrupt research. Always use established generators.</p></li>
<li><p><strong>Seeds enable reproducibility</strong>: Set them explicitly, document them, and use <code class="docutils literal notranslate"><span class="pre">SeedSequence.spawn()</span></code> for parallel work.</p></li>
</ol>
</section>
<section id="transition-to-what-follows">
<h2>Transition to What Follows<a class="headerlink" href="#transition-to-what-follows" title="Link to this heading"></a></h2>
<p>With a supply of high-quality uniform variates in hand, we are ready for the central technique of random variable generation: the <strong>inverse CDF method</strong>. The next section (<a class="reference internal" href="ch2_3-inverse-cdf-method.html#ch2-3-inverse-cdf-method"><span class="std std-ref">Section 2.3 Inverse CDF Method</span></a>) shows how to transform uniform variates into samples from any distribution whose quantile function we can compute.</p>
<p>For distributions with closed-form inverse CDFs—exponential, Weibull, Cauchy, Pareto—the method is elegant and efficient. For discrete distributions, we will develop efficient algorithms (binary search, the alias method) to locate the correct outcome quickly. And for distributions without tractable inverse CDFs—most notably the normal—we will see specialized alternatives in subsequent sections.</p>
<p>The uniform variates we now know how to generate are the raw material; the inverse CDF method is the machinery that shapes them into any distributional form we need.</p>
<div class="important admonition">
<p class="admonition-title">Key Takeaways 📝</p>
<ol class="arabic simple">
<li><p><strong>Core concept</strong>: Uniform variates are the universal source of randomness. The Probability Integral Transform (next section) shows how any distribution can be generated by applying the inverse CDF to uniform samples.</p></li>
<li><p><strong>Paradox resolved</strong>: Computers generate pseudo-random numbers—deterministic sequences that pass statistical tests for randomness. This suffices for virtually all statistical applications.</p></li>
<li><p><strong>Historical lessons</strong>: Chaotic dynamical systems fail as PRNGs (correlation, degeneration). Linear congruential generators produce lattice structure in high dimensions. RANDU’s 15 planes corrupted research for years.</p></li>
<li><p><strong>Modern solutions</strong>: Mersenne Twister (period <span class="math notranslate nohighlight">\(2^{19937}-1\)</span>, 623-dim equidistribution) and PCG64 (period <span class="math notranslate nohighlight">\(2^{128}\)</span>, small state, jumpable) pass all standard tests. Use NumPy’s defaults confidently.</p></li>
<li><p><strong>Practical wisdom</strong>: Set seeds for reproducibility. Use <code class="docutils literal notranslate"><span class="pre">SeedSequence.spawn()</span></code> for parallel computing. Reserve <code class="docutils literal notranslate"><span class="pre">secrets</span></code> for cryptographic needs.</p></li>
<li><p><strong>Outcome alignment</strong>: Understanding uniform generation (Learning Outcome 1) provides the foundation for all subsequent simulation techniques—inverse CDF, rejection sampling, MCMC—that transform uniform variates into complex distributions.</p></li>
</ol>
</div>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<div role="list" class="citation-list">
<div class="citation" id="hulldobell1962" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>HullDobell1962<span class="fn-bracket">]</span></span>
<p>Hull, T. E., and Dobell, A. R. (1962). Random number generators. <em>SIAM Review</em>, 4(3), 230–254. Establishes conditions for full-period linear congruential generators.</p>
</div>
<div class="citation" id="lecuyersimard2007" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>LEcuyerSimard2007<span class="fn-bracket">]</span></span>
<p>L’Ecuyer, P., and Simard, R. (2007). TestU01: A C library for empirical testing of random number generators. <em>ACM Transactions on Mathematical Software</em>, 33(4), Article 22. The standard test suite for PRNG validation.</p>
</div>
<div class="citation" id="lehmer1951" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Lehmer1951<span class="fn-bracket">]</span></span>
<p>Lehmer, D. H. (1951). Mathematical methods in large-scale computing units. In <em>Proceedings of the Second Symposium on Large-Scale Digital Calculating Machinery</em> (pp. 141–146). Harvard University Press. Introduces linear congruential generators.</p>
</div>
<div class="citation" id="marsagliazaman1993" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>MarsagliaZaman1993<span class="fn-bracket">]</span></span>
<p>Marsaglia, G., and Zaman, A. (1993). The KISS generator. Technical report, Department of Statistics, Florida State University. Combines congruential and shift-register methods.</p>
</div>
<div class="citation" id="matsumotonishimura1998" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>MatsumotoNishimura1998<span class="fn-bracket">]</span></span>
<p>Matsumoto, M., and Nishimura, T. (1998). Mersenne Twister: A 623-dimensionally equidistributed uniform pseudo-random number generator. <em>ACM Transactions on Modeling and Computer Simulation</em>, 8(1), 3–30. The de facto standard PRNG for two decades.</p>
</div>
<div class="citation" id="oneill2014" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ONeill2014<span class="fn-bracket">]</span></span>
<p>O’Neill, M. E. (2014). PCG: A family of simple fast space-efficient statistically good algorithms for random number generation. Technical Report HMC-CS-2014-0905, Harvey Mudd College. NumPy’s default generator since version 1.17.</p>
</div>
<div class="citation" id="vonneumann1951" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>vonNeumann1951<span class="fn-bracket">]</span></span>
<p>von Neumann, J. (1951). Various techniques used in connection with random digits. In A. S. Householder, G. E. Forsythe, &amp; H. H. Germond (Eds.), <em>Monte Carlo method</em> (pp. 36–38). National Bureau of Standards, Applied Mathematics Series (No. 12). Introduces the middle-square method and discusses computational randomness.</p>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ch2_1-monte-carlo-fundamentals.html" class="btn btn-neutral float-left" title="Section 2.1 Monte Carlo Fundamentals" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ch2_3-inverse-cdf-method.html" class="btn btn-neutral float-right" title="Section 2.3 Inverse CDF Method" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>