<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Alias Method - Interactive Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1500px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 5px;
            font-size: 1.9em;
            background: linear-gradient(90deg, #f59e0b, #ef4444, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #94a3b8;
            margin-bottom: 15px;
            font-size: 0.95em;
        }

        /* Tab Navigation */
        .tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1em;
            transition: all 0.3s;
            background: rgba(255,255,255,0.1);
            color: #94a3b8;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #f59e0b, #ef4444);
            color: white;
        }

        .tab-btn:hover:not(.active) {
            background: rgba(255,255,255,0.2);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Panels */
        .panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
            margin-bottom: 15px;
        }

        .panel-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #fbbf24;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }

        /* Setup Phase Styles */
        .setup-grid {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 20px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.85em;
            color: #94a3b8;
        }

        select {
            padding: 10px 14px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.4);
            color: white;
            font-size: 0.95em;
        }

        .dist-description {
            font-size: 0.8em;
            color: #fbbf24;
            padding: 8px 10px;
            background: rgba(251, 191, 36, 0.1);
            border-radius: 4px;
            border-left: 3px solid #f59e0b;
            margin-top: 5px;
            line-height: 1.4;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #f59e0b, #ef4444);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }

        .btn-secondary {
            background: #6366f1;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #4f46e5;
        }

        .btn-success {
            background: #22c55e;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #16a34a;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            background: #d97706;
        }

        /* Cups Visualization */
        .cups-container {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
            min-height: 400px;
        }

        .cups-title {
            text-align: center;
            color: #fbbf24;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .cups-row {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 8px;
            height: 300px;
            padding-bottom: 40px;
            position: relative;
        }

        .cup {
            width: 55px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.2s;
        }

        .cup:hover {
            transform: scale(1.05);
        }

        .cup-body {
            width: 100%;
            border: 2px solid #64748b;
            border-top: none;
            border-radius: 0 0 8px 8px;
            position: relative;
            overflow: hidden;
            background: rgba(0,0,0,0.3);
        }

        .cup-fill-native {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            transition: height 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .native-prob-label {
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .cup-fill-alias {
            position: absolute;
            left: 0;
            right: 0;
            transition: all 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .cup-label {
            text-align: center;
            margin-top: 5px;
            font-size: 12px;
            color: #94a3b8;
        }

        .cup-value {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #fbbf24;
            white-space: nowrap;
            font-weight: bold;
        }

        .cup-prob {
            font-size: 9px;
            color: #94a3b8;
        }

        .average-line {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 2px dashed #ef4444;
            z-index: 10;
        }

        .average-label {
            position: absolute;
            right: 10px;
            color: #ef4444;
            font-size: 12px;
            font-weight: bold;
        }

        /* Queue Displays */
        .queues-panel {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .queue-box {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 12px;
        }

        .queue-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .queue-title.small {
            color: #60a5fa;
        }

        .queue-title.large {
            color: #f97316;
        }

        .queue-items {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 30px;
        }

        .queue-item {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
            transition: all 0.3s;
        }

        .queue-item.small {
            background: rgba(96, 165, 250, 0.3);
            color: #60a5fa;
        }

        .queue-item.large {
            background: rgba(249, 115, 22, 0.3);
            color: #f97316;
        }

        .queue-item.active {
            transform: scale(1.1);
            box-shadow: 0 0 10px currentColor;
        }

        /* Step explanation */
        .step-explanation {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.15), rgba(245, 158, 11, 0.15));
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .step-explanation-title {
            font-weight: bold;
            color: #fbbf24;
            margin-bottom: 8px;
        }

        .step-explanation-text {
            font-size: 0.9em;
            line-height: 1.6;
            color: #fef3c7;
        }

        /* Alias Table */
        .alias-table-container {
            margin-top: 15px;
            max-height: 280px;
            overflow-y: auto;
        }

        .alias-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }

        .alias-table th, .alias-table td {
            padding: 8px;
            text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .alias-table th {
            background: rgba(0,0,0,0.4);
            color: #fbbf24;
            position: sticky;
            top: 0;
        }

        .alias-table tr.highlight {
            background: rgba(34, 197, 94, 0.3);
        }

        .alias-table tr.processing {
            background: rgba(251, 191, 36, 0.3);
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.6em;
            font-weight: bold;
            color: #fbbf24;
        }

        .stat-label {
            font-size: 0.75em;
            color: #94a3b8;
        }

        /* Sampling Phase Styles */
        .sampling-grid {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        .sampling-viz {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
        }

        .sample-result {
            text-align: center;
            padding: 20px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .sample-result-label {
            color: #94a3b8;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .sample-result-value {
            font-size: 3em;
            font-weight: bold;
            color: #22c55e;
        }

        .sample-step {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid #6b7280;
            transition: all 0.3s;
        }

        .sample-step.active {
            border-left-color: #fbbf24;
            background: rgba(251, 191, 36, 0.15);
        }

        .sample-step.complete {
            border-left-color: #22c55e;
        }

        .sample-step-number {
            font-size: 0.8em;
            color: #94a3b8;
            margin-bottom: 4px;
        }

        .sample-step-content {
            font-size: 1em;
        }

        .sample-step-formula {
            font-family: 'Monaco', 'Consolas', monospace;
            color: #fbbf24;
            margin-top: 5px;
        }

        /* Histogram */
        .histogram-container {
            margin-top: 20px;
        }

        .histogram-title {
            text-align: center;
            color: #94a3b8;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        /* Complexity boxes */
        .complexity-box {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(16, 185, 129, 0.15));
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .complexity-title {
            font-weight: bold;
            color: #4ade80;
            margin-bottom: 10px;
        }

        .complexity-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 0.9em;
        }

        .complexity-method {
            color: #e2e8f0;
        }

        .complexity-value {
            font-weight: bold;
            font-family: monospace;
        }

        /* Method comparison */
        .comparison-box {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .comparison-title {
            font-weight: bold;
            color: #a78bfa;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .comparison-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            padding: 4px 0;
            color: #e2e8f0;
        }

        .comparison-value {
            font-weight: bold;
            font-family: monospace;
        }

        .comparison-verdict {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85em;
            text-align: center;
        }

        /* Insight/Warning boxes */
        .insight-box {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(16, 185, 129, 0.15));
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }

        .insight-title {
            font-weight: bold;
            color: #4ade80;
            font-size: 0.9em;
            margin-bottom: 6px;
        }

        .insight-text {
            font-size: 0.85em;
            color: #a7f3d0;
            line-height: 1.5;
        }

        .warning-box {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.15));
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }

        .warning-title {
            font-weight: bold;
            color: #f87171;
            font-size: 0.9em;
            margin-bottom: 6px;
        }

        .warning-text {
            font-size: 0.85em;
            color: #fecaca;
            line-height: 1.5;
        }

        /* Color palette for cups */
        .color-1 { background: #ef4444; }
        .color-2 { background: #f97316; }
        .color-3 { background: #eab308; }
        .color-4 { background: #22c55e; }
        .color-5 { background: #14b8a6; }
        .color-6 { background: #3b82f6; }
        .color-7 { background: #8b5cf6; }
        .color-8 { background: #ec4899; }

        .alias-color-1 { background: repeating-linear-gradient(45deg, #ef4444, #ef4444 4px, #fca5a5 4px, #fca5a5 8px); }
        .alias-color-2 { background: repeating-linear-gradient(45deg, #f97316, #f97316 4px, #fdba74 4px, #fdba74 8px); }
        .alias-color-3 { background: repeating-linear-gradient(45deg, #eab308, #eab308 4px, #fde047 4px, #fde047 8px); }
        .alias-color-4 { background: repeating-linear-gradient(45deg, #22c55e, #22c55e 4px, #86efac 4px, #86efac 8px); }
        .alias-color-5 { background: repeating-linear-gradient(45deg, #14b8a6, #14b8a6 4px, #5eead4 4px, #5eead4 8px); }
        .alias-color-6 { background: repeating-linear-gradient(45deg, #3b82f6, #3b82f6 4px, #93c5fd 4px, #93c5fd 8px); }
        .alias-color-7 { background: repeating-linear-gradient(45deg, #8b5cf6, #8b5cf6 4px, #c4b5fd 4px, #c4b5fd 8px); }
        .alias-color-8 { background: repeating-linear-gradient(45deg, #ec4899, #ec4899 4px, #f9a8d4 4px, #f9a8d4 8px); }

        /* Selected cup highlight */
        .cup.selected .cup-body {
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.8);
            border-color: #fbbf24;
        }

        .cup.sampled .cup-body {
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.8);
            border-color: #22c55e;
        }

        .cup.processing .cup-body {
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.6);
            border-color: #fbbf24;
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Benchmark results */
        .benchmark-box {
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid rgba(96, 165, 250, 0.3);
        }

        .benchmark-title {
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .benchmark-row {
            display: grid;
            grid-template-columns: 1fr 80px 80px;
            gap: 10px;
            padding: 6px 0;
            font-size: 0.85em;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .benchmark-row.header {
            color: #94a3b8;
            font-weight: bold;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .benchmark-winner {
            color: #4ade80;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .setup-grid, .sampling-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèÜ The Alias Method</h1>
        <p class="subtitle">O(1) sampling after O(K) setup ‚Äî restructuring probability into equal-height cups</p>

        <!-- Tab Navigation -->
        <div class="tabs" role="tablist">
            <button class="tab-btn active" data-tab="setup" role="tab" aria-selected="true">üì¶ Setup Phase</button>
            <button class="tab-btn" data-tab="sampling" role="tab" aria-selected="false">üé≤ Sampling Phase</button>
            <button class="tab-btn" data-tab="benchmark" role="tab" aria-selected="false">‚ö° Benchmark</button>
        </div>

        <!-- Setup Phase Tab -->
        <div id="setup" class="tab-content active" role="tabpanel">
            <div class="setup-grid">
                <!-- Left: Controls -->
                <div class="panel">
                    <div class="panel-title">‚öôÔ∏è Controls</div>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label>Distribution (K=8)</label>
                            <select id="distribution" aria-label="Select distribution">
                                <optgroup label="Textbook Examples">
                                    <option value="example" selected>Standard [0.1, 0.2, 0.05, 0.15, 0.05, 0.25, 0.1, 0.1]</option>
                                    <option value="uniform">Uniform (all equal)</option>
                                </optgroup>
                                <optgroup label="Skewed Distributions">
                                    <option value="geometric">Geometric (Head-heavy)</option>
                                    <option value="reversed">Reversed Geometric (Tail-heavy)</option>
                                </optgroup>
                                <optgroup label="Complex Shapes">
                                    <option value="bimodal">Bimodal (Two peaks)</option>
                                    <option value="single">Single Dominant (80% at k=3)</option>
                                    <option value="ushape">U-shaped (Ends heavy)</option>
                                </optgroup>
                            </select>
                            <div class="dist-description" id="distDescription">
                                Classic textbook example showing varied probabilities. Watch how underfilled cups get topped up by overfilled ones.
                            </div>
                        </div>

                        <div class="btn-group">
                            <button class="btn-primary" id="resetSetupBtn">üîÑ Reset</button>
                            <button class="btn-secondary" id="stepSetupBtn">Step ‚Üí</button>
                        </div>
                        
                        <div class="btn-group">
                            <button class="btn-warning" id="autoSetupBtn">‚ñ∂ Auto Play</button>
                            <button class="btn-success" id="completeSetupBtn">‚è≠ Complete All</button>
                        </div>
                    </div>

                    <!-- Queues -->
                    <div class="queues-panel" style="margin-top: 20px;">
                        <div class="queue-box">
                            <div class="queue-title small">üì• Small Queue (underfilled: q &lt; 1)</div>
                            <div class="queue-items" id="smallQueue" role="list" aria-label="Small queue items"></div>
                        </div>
                        <div class="queue-box">
                            <div class="queue-title large">üì§ Large Queue (overfilled: q ‚â• 1)</div>
                            <div class="queue-items" id="largeQueue" role="list" aria-label="Large queue items"></div>
                        </div>
                    </div>

                    <!-- Step Explanation -->
                    <div class="step-explanation" role="status" aria-live="polite">
                        <div class="step-explanation-title">üí° Current Step</div>
                        <div class="step-explanation-text" id="stepExplanation">
                            Click "Reset" to initialize, then "Step" to walk through the setup algorithm, or "Auto Play" to watch it unfold.
                        </div>
                    </div>
                </div>

                <!-- Center: Cups Visualization -->
                <div class="panel">
                    <div class="panel-title">ü•§ Probability Cups</div>
                    <div class="cups-container">
                        <div class="cups-title" id="cupsTitle">Original Probabilities (scaled by K=8)</div>
                        <div class="cups-row" id="cupsRow" role="img" aria-label="Visualization of probability cups">
                            <!-- Cups will be generated here -->
                        </div>
                    </div>
                    
                    <div class="insight-box">
                        <div class="insight-title">üéØ The Core Insight</div>
                        <div class="insight-text">
                            After scaling by K, we restructure into K cups of height 1. Each cup holds probability from <strong>at most two</strong> original outcomes, enabling constant-time sampling.
                        </div>
                    </div>
                    
                    <div class="insight-box" style="border-color: rgba(96, 165, 250, 0.3); background: linear-gradient(135deg, rgba(96, 165, 250, 0.15), rgba(59, 130, 246, 0.15));">
                        <div class="insight-title" style="color: #60a5fa;">üìê The Invariant</div>
                        <div class="insight-text" style="color: #bfdbfe;">
                            Let q[i] = K¬∑p[i]. Each step transfers exactly <em>(1 ‚àí q[j])</em> from a large cup <em>‚Ñì</em> to fill a small cup <em>j</em>, preserving Œ£q[i] = K and ensuring each cup ends at height 1 with at most two labels.
                        </div>
                    </div>
                </div>

                <!-- Right: Alias Table & Stats -->
                <div class="panel">
                    <div class="panel-title">üìã Alias Table</div>
                    <div class="alias-table-container">
                        <table class="alias-table" aria-label="Alias method probability and alias tables">
                            <thead>
                                <tr>
                                    <th>Cup i</th>
                                    <th>prob[i]</th>
                                    <th>alias[i]</th>
                                </tr>
                            </thead>
                            <tbody id="aliasTableBody">
                                <!-- Table rows will be generated -->
                            </tbody>
                        </table>
                    </div>

                    <div class="stats-grid" role="region" aria-label="Setup statistics">
                        <div class="stat-box">
                            <div class="stat-value" id="statSetupSteps" role="status">0</div>
                            <div class="stat-label">Pairings</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="statSmallLeft">-</div>
                            <div class="stat-label">Small Left</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="statLargeLeft">-</div>
                            <div class="stat-label">Large Left</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="statProgress">0%</div>
                            <div class="stat-label">Progress</div>
                        </div>
                    </div>

                    <div class="complexity-box">
                        <div class="complexity-title">üéØ Alias Method Complexity</div>
                        <div class="complexity-row">
                            <span class="complexity-method">Setup:</span>
                            <span class="complexity-value" style="color: #fbbf24;">O(K)</span>
                        </div>
                        <div class="complexity-row">
                            <span class="complexity-method">Per sample:</span>
                            <span class="complexity-value" style="color: #4ade80;">O(1)</span>
                        </div>
                        <div class="complexity-row">
                            <span class="complexity-method">Space:</span>
                            <span class="complexity-value" style="color: #60a5fa;">O(K)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sampling Phase Tab -->
        <div id="sampling" class="tab-content" role="tabpanel">
            <div class="sampling-grid">
                <!-- Left: Visualization -->
                <div class="panel">
                    <div class="panel-title">ü•§ Sampling from Balanced Cups</div>
                    
                    <div class="sample-result">
                        <div class="sample-result-label">Sampled Outcome</div>
                        <div class="sample-result-value" id="sampledValue" role="status" aria-live="polite">‚Äî</div>
                    </div>

                    <!-- Original PMF for comparison - STATIC, drawn once -->
                    <div style="margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="color: #94a3b8; font-size: 0.85em;">Original Distribution (target)</span>
                            <span style="color: #94a3b8; font-size: 0.75em;">What we want to sample</span>
                        </div>
                        <div style="height: 60px;">
                            <canvas id="originalPmfCanvas" style="width: 100%; height: 100%; background: rgba(0,0,0,0.2); border-radius: 6px;"></canvas>
                        </div>
                    </div>

                    <div class="cups-container" style="min-height: 280px;">
                        <div class="cups-title">Restructured Cups (each has total height = 1)</div>
                        <div class="cups-row" id="samplingCupsRow" style="height: 210px;">
                            <!-- Cups will be generated here -->
                        </div>
                    </div>

                    <div class="btn-group" style="justify-content: center; margin-top: 15px;">
                        <button class="btn-primary" id="sampleOnceBtn">üé≤ Sample Once</button>
                        <button class="btn-warning" id="autoSampleBtn">‚ñ∂ Auto Sample</button>
                        <button class="btn-secondary" id="sample100Btn">+100</button>
                        <button class="btn-success" id="sample1000Btn">+1000</button>
                        <button class="btn-secondary" id="clearSamplesBtn">üóëÔ∏è Clear</button>
                    </div>

                    <!-- Histogram - fixed height container to prevent layout shift -->
                    <div class="histogram-container">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span class="histogram-title" style="margin: 0;">Sampled Distribution (n = <span id="sampleCount" aria-live="polite">0</span>)</span>
                            <span style="color: #94a3b8; font-size: 0.75em;">Bars: observed | Gold lines: true P</span>
                        </div>
                        <div style="height: 120px;">
                            <canvas id="histogramCanvas" style="width: 100%; height: 100%;"></canvas>
                        </div>
                    </div>
                    
                    <div class="insight-box" style="margin-top: 10px;">
                        <div class="insight-title">üîç Compare the Three Views</div>
                        <div class="insight-text">
                            <strong>Top:</strong> Original PMF ‚Äî the distribution we want.<br>
                            <strong>Middle:</strong> Restructured cups ‚Äî all height 1, but same colors show where probability came from.<br>
                            <strong>Bottom:</strong> Sample histogram ‚Äî should converge to the original PMF!
                        </div>
                    </div>
                </div>

                <!-- Right: Sampling Steps -->
                <div class="panel">
                    <div class="panel-title">üîç O(1) Sampling Process</div>

                    <div class="sample-step" id="sampleStep1">
                        <div class="sample-step-number">Step 1: Generate U ~ Uniform(0, K)</div>
                        <div class="sample-step-content">One random number gives us everything</div>
                        <div class="sample-step-formula" id="step1Formula">U = ?</div>
                    </div>

                    <div class="sample-step" id="sampleStep2">
                        <div class="sample-step-number">Step 2: Select Cup</div>
                        <div class="sample-step-content">Index i = ‚åäU‚åã ‚àà {0,1,...,K‚àí1} ‚Üí Cup (i+1)</div>
                        <div class="sample-step-formula" id="step2Formula">i = ?</div>
                    </div>

                    <div class="sample-step" id="sampleStep3">
                        <div class="sample-step-number">Step 3: Position in Cup (V = U ‚àí i)</div>
                        <div class="sample-step-content">Fractional part V ‚àà [0,1) is our "coin flip"</div>
                        <div class="sample-step-formula" id="step3Formula">V = ?</div>
                    </div>

                    <div class="sample-step" id="sampleStep4">
                        <div class="sample-step-number">Step 4: Compare V with prob[i]</div>
                        <div class="sample-step-content">V < prob[i] ‚Üí native, else ‚Üí alias</div>
                        <div class="sample-step-formula" id="step4Formula">V ? prob[i]</div>
                    </div>

                    <div class="sample-step" id="sampleStep5">
                        <div class="sample-step-number">Step 5: Return Result</div>
                        <div class="sample-step-content">Output k ‚àà {1,...,K} in constant time!</div>
                        <div class="sample-step-formula" id="step5Formula">Result = ?</div>
                    </div>

                    <div class="stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="stat-box">
                            <div class="stat-value" id="statTotalSamples">0</div>
                            <div class="stat-label">Total Samples</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="statNativeHits">0</div>
                            <div class="stat-label">Native Hits</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="statAliasHits">0</div>
                            <div class="stat-label">Alias Hits</div>
                        </div>
                    </div>

                    <!-- Method Comparison -->
                    <div class="comparison-box" id="comparisonBox">
                        <div class="comparison-title">‚öñÔ∏è Comparison: Steps per Sample</div>
                        <div class="comparison-row">
                            <span>Alias Method:</span>
                            <span class="comparison-value" style="color: #4ade80;">1 lookup + 1 compare</span>
                        </div>
                        <div class="comparison-row">
                            <span>Binary Search:</span>
                            <span class="comparison-value">‚åàlog‚ÇÇ 8‚åâ = 3 comparisons</span>
                        </div>
                        <div class="comparison-row">
                            <span>Linear Search:</span>
                            <span class="comparison-value">1‚Äì8 comparisons</span>
                        </div>
                        <div class="comparison-verdict" id="comparisonVerdict">
                            For K=8, methods are similar. Alias shines when K is large!
                        </div>
                    </div>

                    <div class="warning-box">
                        <div class="warning-title">üìù Index vs Cup Number</div>
                        <div class="warning-text">
                            Arrays use 0-based index: i ‚àà {0, 1, ..., 7}<br>
                            Cups use 1-based labels: Cup k ‚àà {1, 2, ..., 8}<br>
                            Conversion: Cup k = i + 1
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Benchmark Tab -->
        <div id="benchmark" class="tab-content" role="tabpanel">
            <div class="panel">
                <div class="panel-title">‚ö° Performance Benchmark: Alias vs Binary vs Linear</div>
                
                <p style="color: #94a3b8; margin-bottom: 20px; line-height: 1.6;">
                    Compare setup cost (one-time) vs sampling cost (per sample). The alias method has O(K) setup but O(1) sampling ‚Äî watch it win as sample count grows!
                </p>

                <div style="display: grid; grid-template-columns: 320px 1fr; gap: 20px;">
                    <div>
                        <div class="control-group" style="margin-bottom: 12px;">
                            <label>Distribution Size (K)</label>
                            <select id="benchmarkK">
                                <option value="8">K = 8 (tiny)</option>
                                <option value="100">K = 100 (small)</option>
                                <option value="1000" selected>K = 1,000 (medium)</option>
                                <option value="10000">K = 10,000 (large)</option>
                                <option value="100000">K = 100,000 (very large)</option>
                            </select>
                        </div>

                        <div class="control-group" style="margin-bottom: 12px;">
                            <label>Number of Samples (N)</label>
                            <select id="benchmarkN">
                                <option value="1000">1,000 samples</option>
                                <option value="10000">10,000 samples</option>
                                <option value="100000" selected>100,000 samples</option>
                                <option value="1000000">1,000,000 samples</option>
                            </select>
                        </div>

                        <div class="control-group" style="margin-bottom: 12px;">
                            <label>Distribution Shape</label>
                            <select id="benchmarkDist">
                                <option value="uniform">Uniform</option>
                                <option value="geometric" selected>Geometric (head-heavy)</option>
                                <option value="zipf">Zipf's Law (power law)</option>
                            </select>
                        </div>

                        <button class="btn-primary" id="runBenchmarkBtn" style="width: 100%; margin-bottom: 15px;">
                            üöÄ Run Benchmark
                        </button>

                        <!-- Distribution Preview -->
                        <div style="background: rgba(0,0,0,0.3); border-radius: 8px; padding: 12px;">
                            <div style="color: #94a3b8; font-size: 0.85em; margin-bottom: 8px;">
                                Distribution Preview (first 50 of K)
                            </div>
                            <canvas id="benchmarkPmfCanvas" style="width: 100%; height: 80px;"></canvas>
                            <canvas id="benchmarkCdfCanvas" style="width: 100%; height: 60px; margin-top: 8px;"></canvas>
                            <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.75em; color: #64748b;">
                                <span>PMF (top) / CDF (bottom)</span>
                                <span id="benchmarkDistInfo">‚Äî</span>
                            </div>
                        </div>

                        <div class="warning-box" style="margin-top: 12px;">
                            <div class="warning-title">‚ö†Ô∏è Browser Note</div>
                            <div class="warning-text">
                                JavaScript has overhead. Real compiled code shows even larger alias method wins.
                            </div>
                        </div>
                    </div>

                    <div>
                        <!-- Setup vs Sampling Breakdown -->
                        <div class="benchmark-box" id="benchmarkBreakdown" style="margin-bottom: 15px;">
                            <div class="benchmark-title">üîß Setup vs Sampling Breakdown</div>
                            <div class="benchmark-row header">
                                <span>Method</span>
                                <span>Setup</span>
                                <span>Sampling</span>
                                <span>Total</span>
                            </div>
                            <div id="benchmarkBreakdownRows">
                                <p style="color: #94a3b8; text-align: center; padding: 15px; font-size: 0.9em;">
                                    Click "Run Benchmark" to see timing breakdown
                                </p>
                            </div>
                        </div>

                        <!-- Per-sample cost -->
                        <div class="benchmark-box" id="benchmarkPerSample" style="margin-bottom: 15px; display: none;">
                            <div class="benchmark-title">‚è±Ô∏è Per-Sample Cost (total √∑ N)</div>
                            <div class="benchmark-row header">
                                <span>Method</span>
                                <span>Œºs/sample</span>
                                <span>Relative</span>
                            </div>
                            <div id="benchmarkPerSampleRows"></div>
                        </div>

                        <!-- Break-even analysis -->
                        <div class="insight-box" id="benchmarkInsight" style="display: none;">
                            <div class="insight-title">üí° Break-Even Analysis</div>
                            <div class="insight-text" id="benchmarkInsightText"></div>
                        </div>

                        <!-- Complexity Chart -->
                        <div style="margin-top: 15px;">
                            <div style="color: #94a3b8; font-size: 0.85em; margin-bottom: 8px;">
                                Theoretical Complexity: Comparisons per Sample
                            </div>
                            <canvas id="complexityCanvas" style="width: 100%; height: 180px; background: rgba(0,0,0,0.3); border-radius: 8px;"></canvas>
                        </div>

                        <!-- Amortization Chart -->
                        <div style="margin-top: 15px;">
                            <div style="color: #94a3b8; font-size: 0.85em; margin-bottom: 8px;">
                                Amortized Cost: Setup + Sampling over N samples
                            </div>
                            <canvas id="amortizationCanvas" style="width: 100%; height: 160px; background: rgba(0,0,0,0.3); border-radius: 8px;"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // GLOBAL STATE
        // ============================================================
        const K = 8;
        const colors = ['color-1', 'color-2', 'color-3', 'color-4', 'color-5', 'color-6', 'color-7', 'color-8'];
        const aliasColors = ['alias-color-1', 'alias-color-2', 'alias-color-3', 'alias-color-4', 'alias-color-5', 'alias-color-6', 'alias-color-7', 'alias-color-8'];
        const colorHex = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#14b8a6', '#3b82f6', '#8b5cf6', '#ec4899'];
        
        let pmf = [];
        let q = [];  // Scaled probabilities (sum to K)
        let prob = [];  // Final prob table
        let alias = [];  // Final alias table
        let small = [];  // Small queue
        let large = [];  // Large queue
        let setupStep = 0;
        let setupComplete = false;
        let cupStates = [];  // Track each cup's state
        let isAutoPlaying = false;
        let autoPlayInterval = null;
        
        // Sampling state
        let samples = [];
        let sampleCounts = [];
        let nativeHits = 0;
        let aliasHits = 0;
        let isAutoSampling = false;
        let autoSampleInterval = null;
        let originalPmfDrawn = false;  // Track if PMF has been drawn for current distribution

        // ============================================================
        // NUMERICAL HELPERS
        // ============================================================
        // Clamp to [0, 1] to handle FP drift (tiny negatives or 1+Œµ)
        const clamp01 = x => x <= 0 ? 0 : x >= 1 ? 1 : x;

        // Mulberry32 PRNG for reproducible results
        function mulberry32(a) {
            return function() {
                let t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }
        let rng = Math.random;
        function setSeed(seedInt) { rng = mulberry32(seedInt >>> 0); }
        function clearSeed() { rng = Math.random; }

        // Distributions
        const distributions = {
            example: {
                pmf: [0.1, 0.2, 0.05, 0.15, 0.05, 0.25, 0.1, 0.1],
                description: "Classic textbook example showing varied probabilities. Watch how underfilled cups get topped up by overfilled ones."
            },
            uniform: {
                pmf: Array(8).fill(1/8),
                description: "All outcomes equally likely. Every cup starts at exactly 1 ‚Äî no pairings needed! Setup completes instantly."
            },
            geometric: {
                pmf: (() => {
                    const raw = Array.from({length: 8}, (_, i) => Math.pow(0.5, i));
                    const sum = raw.reduce((a, b) => a + b, 0);
                    return raw.map(x => x / sum);
                })(),
                description: "Head-heavy: ~50% in first bin, decaying. Many small cups, few large ones. Linear search L‚ÜíR would excel here."
            },
            reversed: {
                pmf: (() => {
                    const raw = Array.from({length: 8}, (_, i) => Math.pow(0.5, 7-i));
                    const sum = raw.reduce((a, b) => a + b, 0);
                    return raw.map(x => x / sum);
                })(),
                description: "Tail-heavy: mass concentrated at the end. Linear search L‚ÜíR would struggle; alias method doesn't care!"
            },
            bimodal: {
                pmf: (() => {
                    const raw = [0.2, 0.25, 0.1, 0.05, 0.05, 0.1, 0.2, 0.05];
                    const sum = raw.reduce((a, b) => a + b, 0);
                    return raw.map(x => x / sum);
                })(),
                description: "Two peaks: probability concentrated at both ends. Complex structure, but alias method handles it the same."
            },
            single: {
                pmf: (() => {
                    const raw = [0.03, 0.03, 0.8, 0.03, 0.03, 0.03, 0.03, 0.02];
                    const sum = raw.reduce((a, b) => a + b, 0);
                    return raw.map(x => x / sum);
                })(),
                description: "80% at k=3: One dominant outcome. Cup 3 is very tall and will donate to all others."
            },
            ushape: {
                pmf: (() => {
                    const raw = [0.25, 0.1, 0.05, 0.05, 0.05, 0.05, 0.15, 0.3];
                    const sum = raw.reduce((a, b) => a + b, 0);
                    return raw.map(x => x / sum);
                })(),
                description: "U-shaped: Heavy at extremes, light in middle. Ends will donate to middle cups."
            }
        };

        // ============================================================
        // TAB NAVIGATION
        // ============================================================
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => {
                    b.classList.remove('active');
                    b.setAttribute('aria-selected', 'false');
                });
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                btn.classList.add('active');
                btn.setAttribute('aria-selected', 'true');
                document.getElementById(btn.dataset.tab).classList.add('active');
                
                if (btn.dataset.tab === 'sampling') {
                    if (!setupComplete) {
                        completeSetup();
                    }
                    renderSamplingCups();
                    // Only draw PMF once per distribution (it's static)
                    if (!originalPmfDrawn) {
                        drawOriginalPmf();
                        originalPmfDrawn = true;
                    }
                    drawHistogram();
                }
                
                if (btn.dataset.tab === 'benchmark') {
                    drawComplexityChart();
                }
            });
        });

        // ============================================================
        // INITIALIZATION
        // ============================================================
        function init() {
            loadDistribution('example');
            setupEventListeners();
        }

        function loadDistribution(key) {
            const dist = distributions[key];
            pmf = dist.pmf.slice();
            
            // Normalize defensively
            const sum = pmf.reduce((a, b) => a + b, 0);
            pmf = pmf.map(x => x / sum);
            
            document.getElementById('distDescription').textContent = dist.description;
            
            resetSetup();  // This resets sampling state and originalPmfDrawn flag
        }

        function setupEventListeners() {
            document.getElementById('distribution').addEventListener('change', (e) => {
                stopAutoPlay();
                loadDistribution(e.target.value);
            });

            document.getElementById('resetSetupBtn').addEventListener('click', () => {
                stopAutoPlay();
                resetSetup();
            });
            document.getElementById('stepSetupBtn').addEventListener('click', doSetupStep);
            document.getElementById('autoSetupBtn').addEventListener('click', toggleAutoPlay);
            document.getElementById('completeSetupBtn').addEventListener('click', () => {
                stopAutoPlay();
                completeSetup();
            });

            document.getElementById('sampleOnceBtn').addEventListener('click', () => sampleN(1));
            document.getElementById('autoSampleBtn').addEventListener('click', toggleAutoSample);
            document.getElementById('sample100Btn').addEventListener('click', () => sampleN(100));
            document.getElementById('sample1000Btn').addEventListener('click', () => sampleN(1000));
            document.getElementById('clearSamplesBtn').addEventListener('click', clearSamples);

            document.getElementById('runBenchmarkBtn').addEventListener('click', runBenchmark);
        }

        // ============================================================
        // SETUP PHASE
        // ============================================================
        function resetSetup() {
            // Scale probabilities to sum to K
            q = pmf.map(p => p * K);
            
            // Short-circuit for uniform: if all q[i] ‚âà 1, no pairings needed
            const allOne = q.every(v => Math.abs(v - 1) < 1e-12);
            
            // Initialize cup states - don't clamp here, we want to show actual heights
            cupStates = q.map((qi, i) => ({
                native: qi,  // Keep original scaled value (can be > 1 for large cups)
                alias: null,
                finalized: false
            }));
            
            // Initialize tables
            prob = Array(K).fill(null);
            alias = Array(K).fill(null);
            
            // Reset sampling state when distribution changes
            samples = [];
            sampleCounts = [];
            nativeHits = 0;
            aliasHits = 0;
            originalPmfDrawn = false;  // Will need to redraw PMF
            
            if (allOne) {
                // Uniform distribution: all cups already at exactly 1
                for (let i = 0; i < K; i++) {
                    prob[i] = 1;
                    alias[i] = i;
                    cupStates[i].finalized = true;
                    cupStates[i].native = 1;
                }
                small = [];
                large = [];
                setupStep = 0;
                setupComplete = true;
                
                updateQueuesDisplay();
                renderCups();
                renderAliasTable();
                updateSetupStats();
                updateStepExplanation('uniform');
                
                document.getElementById('stepSetupBtn').disabled = true;
                document.getElementById('autoSetupBtn').disabled = true;
                return;
            }
            
            // Partition into small and large
            small = [];
            large = [];
            for (let i = 0; i < K; i++) {
                if (q[i] < 1 - 1e-10) {
                    small.push(i);
                } else {
                    large.push(i);
                }
            }
            
            setupStep = 0;
            setupComplete = false;
            
            updateQueuesDisplay();
            renderCups();
            renderAliasTable();
            updateSetupStats();
            updateStepExplanation('init');
            
            document.getElementById('stepSetupBtn').disabled = false;
            document.getElementById('autoSetupBtn').disabled = false;
        }

        function doSetupStep() {
            if (setupComplete) return;
            
            if (small.length > 0 && large.length > 0) {
                const j = small.shift();
                const l = large.shift();
                
                setupStep++;
                
                prob[j] = clamp01(q[j]);
                alias[j] = l;
                cupStates[j].finalized = true;
                cupStates[j].native = prob[j];  // Update to final value
                cupStates[j].alias = {
                    idx: l,
                    amount: 1 - prob[j]
                };
                
                // Clamp to avoid tiny negatives from FP subtraction
                q[l] = Math.max(0, q[l] - (1 - prob[j]));
                cupStates[l].native = q[l];  // Don't clamp - cup might still be > 1
                
                if (q[l] < 1 - 1e-10) {
                    small.push(l);
                } else {
                    large.push(l);
                }
                
                updateQueuesDisplay(j, l);
                renderCups(j, l);
                renderAliasTable(j);
                updateSetupStats();
                updateStepExplanation('pair', j, l);
            } else {
                // Finalize remaining
                while (small.length > 0) {
                    const i = small.shift();
                    prob[i] = 1;
                    alias[i] = i;
                }
                while (large.length > 0) {
                    const i = large.shift();
                    prob[i] = 1;
                    alias[i] = i;
                }
                
                // CRITICAL: Synchronize cupStates with final prob/alias tables
                // This ensures visual representation matches the mathematical result
                for (let i = 0; i < K; i++) {
                    cupStates[i].finalized = true;
                    cupStates[i].native = prob[i];
                    if (alias[i] !== i) {
                        cupStates[i].alias = { idx: alias[i], amount: 1 - prob[i] };
                    } else {
                        cupStates[i].alias = null;
                    }
                }
                
                setupComplete = true;
                stopAutoPlay();
                
                document.getElementById('stepSetupBtn').disabled = true;
                document.getElementById('autoSetupBtn').disabled = true;
                
                updateQueuesDisplay();
                renderCups();
                renderAliasTable();
                updateSetupStats();
                updateStepExplanation('complete');
            }
        }

        function completeSetup() {
            while (!setupComplete) {
                doSetupStep();
            }
        }

        function toggleAutoPlay() {
            if (isAutoPlaying) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }

        function startAutoPlay() {
            if (setupComplete) return;
            isAutoPlaying = true;
            document.getElementById('autoSetupBtn').textContent = '‚è∏ Pause';
            autoPlayInterval = setInterval(() => {
                if (!setupComplete) {
                    doSetupStep();
                } else {
                    stopAutoPlay();
                }
            }, 800);
        }

        function stopAutoPlay() {
            isAutoPlaying = false;
            document.getElementById('autoSetupBtn').textContent = '‚ñ∂ Auto Play';
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
        }

        function updateQueuesDisplay(activeSmall = null, activeLarge = null) {
            const smallDiv = document.getElementById('smallQueue');
            const largeDiv = document.getElementById('largeQueue');
            
            smallDiv.innerHTML = small.map(i => 
                `<span class="queue-item small" role="listitem">${i + 1} (${q[i].toFixed(2)})</span>`
            ).join('');
            
            largeDiv.innerHTML = large.map(i => 
                `<span class="queue-item large" role="listitem">${i + 1} (${q[i].toFixed(2)})</span>`
            ).join('');
        }

        function updateSetupStats() {
            document.getElementById('statSetupSteps').textContent = setupStep;
            document.getElementById('statSmallLeft').textContent = small.length;
            document.getElementById('statLargeLeft').textContent = large.length;
            
            const finalized = cupStates.filter(c => c.finalized).length;
            const progress = Math.round((finalized / K) * 100);
            document.getElementById('statProgress').textContent = progress + '%';
        }

        function updateStepExplanation(type, j, l) {
            const div = document.getElementById('stepExplanation');
            
            switch(type) {
                case 'init':
                    div.innerHTML = `
                        <strong>Initialized!</strong><br><br>
                        Probabilities scaled by K=${K}. Target: each cup holds exactly 1 unit.<br><br>
                        <strong style="color: #60a5fa;">Small:</strong> ${small.length} cups underfilled (need topping up)<br>
                        <strong style="color: #f97316;">Large:</strong> ${large.length} cups overfilled (have extra to give)<br><br>
                        Click "Step" or "Auto Play" to watch the pairing process!
                    `;
                    break;
                case 'uniform':
                    div.innerHTML = `
                        <strong style="color: #4ade80;">‚úÖ Uniform Distribution ‚Äî No Pairings Needed!</strong><br><br>
                        All probabilities are equal (1/K), so after scaling by K, every cup has exactly q[i] = 1.<br><br>
                        <strong>No small cups.</strong> No large cups. Nothing to transfer!<br><br>
                        Each cup contains only its native outcome with prob[i] = 1.<br><br>
                        üéâ Switch to <strong>Sampling Phase</strong> ‚Äî it works the same way!
                    `;
                    break;
                case 'pair':
                    const donated = (1 - prob[j]).toFixed(3);
                    const remaining = clamp01(q[l]).toFixed(3);
                    div.innerHTML = `
                        <strong>Step ${setupStep}: Cup ${j + 1} ‚Üê Cup ${l + 1}</strong><br><br>
                        Cup ${j + 1} was underfilled (q = ${prob[j].toFixed(3)}).<br>
                        Cup ${l + 1} donated <strong style="color: #f97316;">${donated}</strong> to fill it up.<br><br>
                        Cup ${l + 1} now has <strong>${remaining}</strong> remaining.<br>
                        ${q[l] < 1 ? `‚Üí Moved to <span style="color: #60a5fa;">Small</span> queue` : `‚Üí Stays in <span style="color: #f97316;">Large</span> queue`}
                    `;
                    break;
                case 'complete':
                    div.innerHTML = `
                        <strong style="color: #4ade80;">‚úÖ Setup Complete!</strong><br><br>
                        All ${K} cups now hold exactly 1 unit of probability.<br>
                        Each cup contains at most 2 outcomes.<br><br>
                        <strong>Pairings made:</strong> ${setupStep}<br>
                        <strong>Setup complexity:</strong> O(K) = O(${K})<br><br>
                        üéâ Switch to <strong>Sampling Phase</strong> to draw samples in O(1) time!
                    `;
                    break;
            }
        }

        // ============================================================
        // CUP RENDERING
        // ============================================================
        function renderCups(highlightJ = null, highlightL = null) {
            const container = document.getElementById('cupsRow');
            const cupHeight = 200;
            
            // After setup, all cups have total = 1.0, so use maxQ = 1.0 for correct scaling
            // During setup, we need headroom for tall cups (q > 1)
            let maxQ;
            if (setupComplete) {
                maxQ = 1.0;  // All cups are exactly full
            } else {
                maxQ = Math.max(...cupStates.map(c => c.native + (c.alias ? c.alias.amount : 0)), 1.0);
            }
            
            let html = '';
            
            // Average line at height = 1
            // cups-row has padding-bottom: 40px
            // cup-label is ~38px (12px font * 2 lines + margins + line-height spacing)
            const paddingBottom = 40;
            const labelHeight = 38;
            const avgLineBottom = paddingBottom + labelHeight + (1 / maxQ) * cupHeight;
            html += `
                <div class="average-line" style="bottom: ${avgLineBottom}px;">
                    <span class="average-label" style="top: -20px;">‚Üê target = 1</span>
                </div>
            `;
            
            cupStates.forEach((cup, i) => {
                const nativeHeight = (cup.native / maxQ) * cupHeight;
                const aliasHeight = cup.alias ? (cup.alias.amount / maxQ) * cupHeight : 0;
                const total = cup.native + (cup.alias ? cup.alias.amount : 0);
                
                const nativeColor = colors[i];
                const aliasColor = cup.alias ? aliasColors[cup.alias.idx] : '';
                
                let cupClass = 'cup';
                if (i === highlightJ || i === highlightL) cupClass += ' processing';
                if (cup.finalized) cupClass += ' finalized';
                
                // Show prob value inside native portion when finalized
                const showProbLabel = cup.finalized && nativeHeight > 20;
                const probLabel = showProbLabel ? `<span class="native-prob-label">${cup.native.toFixed(2)}</span>` : '';
                
                // Show alias label if there's room
                const aliasLabel = cup.alias && cup.alias.amount > 0.08 ? '‚Üê' + (cup.alias.idx + 1) : '';
                
                html += `
                    <div class="${cupClass}">
                        <div class="cup-value">${total.toFixed(2)}</div>
                        <div class="cup-body" style="height: ${cupHeight}px;">
                            <div class="cup-fill-native ${nativeColor}" 
                                 style="height: ${nativeHeight}px;">
                                ${probLabel}
                            </div>
                            ${cup.alias ? `
                                <div class="cup-fill-alias ${aliasColor}" 
                                     style="height: ${aliasHeight}px; bottom: ${nativeHeight}px;">
                                    ${aliasLabel}
                                </div>
                            ` : ''}
                        </div>
                        <div class="cup-label">
                            Cup ${i + 1}<br>
                            <span class="cup-prob">p=${pmf[i].toFixed(2)}</span>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function renderSamplingCups() {
            if (!setupComplete) return;
            
            const container = document.getElementById('samplingCupsRow');
            const cupHeight = 180;
            
            let html = '';
            
            cupStates.forEach((cup, i) => {
                const clampedProb = clamp01(prob[i]);
                const nativeHeight = clampedProb * cupHeight;
                const aliasHeight = (1 - clampedProb) * cupHeight;
                
                const nativeColor = colors[i];
                const aliasIdx = alias[i];
                const aliasColor = aliasIdx !== i ? aliasColors[aliasIdx] : '';
                
                // Show prob value inside native portion
                const showProbLabel = nativeHeight > 25;
                const probLabel = showProbLabel ? `<span class="native-prob-label">${clampedProb.toFixed(2)}</span>` : '';
                
                html += `
                    <div class="cup" id="samplingCup${i}" style="cursor: pointer;">
                        <div class="cup-body" style="height: ${cupHeight}px;">
                            <div class="cup-fill-native ${nativeColor}" 
                                 style="height: ${nativeHeight}px;">
                                ${probLabel}
                            </div>
                            ${aliasIdx !== i ? `
                                <div class="cup-fill-alias ${aliasColor}" 
                                     style="height: ${aliasHeight}px; bottom: ${nativeHeight}px;">
                                    ‚Üê${aliasIdx + 1}
                                </div>
                            ` : ''}
                        </div>
                        <div class="cup-label">
                            Cup ${i + 1}<br>
                            <span class="cup-prob">prob[${i}]=${clampedProb.toFixed(2)}</span>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        // ============================================================
        // ALIAS TABLE RENDERING
        // ============================================================
        function renderAliasTable(highlightRow = null) {
            const tbody = document.getElementById('aliasTableBody');
            
            let html = '';
            for (let i = 0; i < K; i++) {
                const probVal = prob[i] !== null ? prob[i].toFixed(3) : '‚Äî';
                const aliasVal = alias[i] !== null ? (alias[i] + 1) : '‚Äî';
                
                let rowClass = '';
                if (i === highlightRow) rowClass = 'processing';
                else if (cupStates[i].finalized) rowClass = 'highlight';
                
                html += `
                    <tr class="${rowClass}">
                        <td>${i + 1}</td>
                        <td>${probVal}</td>
                        <td>${aliasVal}</td>
                    </tr>
                `;
            }
            
            tbody.innerHTML = html;
        }

        // ============================================================
        // SAMPLING PHASE
        // ============================================================
        function sampleOnce(animate = true) {
            if (!setupComplete) {
                completeSetup();
                renderSamplingCups();
            }
            
            const U = rng() * K;
            const i = Math.floor(U);
            const V = U - i;
            const clampedProb = clamp01(prob[i]);
            const useNative = V < clampedProb;
            const result = useNative ? i : alias[i];
            
            if (animate) {
                animateSample(U, i, V, clampedProb, useNative, result);
            }
            
            samples.push(result);
            sampleCounts[result] = (sampleCounts[result] || 0) + 1;
            if (useNative) nativeHits++; else aliasHits++;
            
            return result;
        }

        function sampleN(n) {
            if (!setupComplete) {
                completeSetup();
                renderSamplingCups();
            }
            
            if (n === 1) {
                sampleOnce(true);
            } else {
                for (let i = 0; i < n; i++) {
                    sampleOnce(false);
                }
                updateSamplingStats();
                drawHistogram();
            }
        }

        function toggleAutoSample() {
            if (isAutoSampling) {
                stopAutoSample();
            } else {
                startAutoSample();
            }
        }

        function startAutoSample() {
            if (!setupComplete) {
                completeSetup();
                renderSamplingCups();
            }
            isAutoSampling = true;
            document.getElementById('autoSampleBtn').textContent = '‚è∏ Pause';
            autoSampleInterval = setInterval(() => {
                sampleOnce(true);
            }, 600);
        }

        function stopAutoSample() {
            isAutoSampling = false;
            document.getElementById('autoSampleBtn').textContent = '‚ñ∂ Auto Sample';
            if (autoSampleInterval) {
                clearInterval(autoSampleInterval);
                autoSampleInterval = null;
            }
        }

        function animateSample(U, i, V, clampedProb, useNative, result) {
            document.querySelectorAll('.sample-step').forEach(s => {
                s.classList.remove('active', 'complete');
            });
            document.querySelectorAll('#samplingCupsRow .cup').forEach(c => {
                c.classList.remove('selected', 'sampled');
            });
            
            const speed = 120;
            
            setTimeout(() => {
                document.getElementById('sampleStep1').classList.add('active');
                document.getElementById('step1Formula').textContent = `U = ${U.toFixed(4)}`;
            }, 0);
            
            setTimeout(() => {
                document.getElementById('sampleStep1').classList.remove('active');
                document.getElementById('sampleStep1').classList.add('complete');
                document.getElementById('sampleStep2').classList.add('active');
                document.getElementById('step2Formula').textContent = `i = ‚åä${U.toFixed(4)}‚åã = ${i} ‚Üí Cup ${i + 1}`;
                document.getElementById(`samplingCup${i}`).classList.add('selected');
            }, speed);
            
            setTimeout(() => {
                document.getElementById('sampleStep2').classList.remove('active');
                document.getElementById('sampleStep2').classList.add('complete');
                document.getElementById('sampleStep3').classList.add('active');
                document.getElementById('step3Formula').textContent = `V = ${U.toFixed(4)} ‚àí ${i} = ${V.toFixed(4)}`;
            }, speed * 2);
            
            setTimeout(() => {
                document.getElementById('sampleStep3').classList.remove('active');
                document.getElementById('sampleStep3').classList.add('complete');
                document.getElementById('sampleStep4').classList.add('active');
                const cmp = useNative ? '<' : '‚â•';
                const decision = useNative ? 'NATIVE' : 'ALIAS';
                document.getElementById('step4Formula').textContent = 
                    `${V.toFixed(3)} ${cmp} ${clampedProb.toFixed(3)} ‚Üí ${decision}`;
            }, speed * 3);
            
            setTimeout(() => {
                document.getElementById('sampleStep4').classList.remove('active');
                document.getElementById('sampleStep4').classList.add('complete');
                document.getElementById('sampleStep5').classList.add('active');
                
                if (useNative) {
                    document.getElementById('step5Formula').textContent = 
                        `Native: k = i + 1 = ${result + 1}`;
                } else {
                    document.getElementById('step5Formula').textContent = 
                        `Alias: k = alias[${i}] + 1 = ${result + 1}`;
                }
                
                document.getElementById(`samplingCup${i}`).classList.remove('selected');
                document.getElementById(`samplingCup${i}`).classList.add('sampled');
                document.getElementById('sampledValue').textContent = result + 1;
                
                updateSamplingStats();
                drawHistogram();
            }, speed * 4);
            
            setTimeout(() => {
                document.getElementById('sampleStep5').classList.remove('active');
                document.getElementById('sampleStep5').classList.add('complete');
            }, speed * 5);
        }

        function clearSamples() {
            stopAutoSample();
            samples = [];
            sampleCounts = [];
            nativeHits = 0;
            aliasHits = 0;
            document.getElementById('sampledValue').textContent = '‚Äî';
            updateSamplingStats();
            drawHistogram();
            
            document.querySelectorAll('.sample-step').forEach(s => {
                s.classList.remove('active', 'complete');
            });
            document.getElementById('step1Formula').textContent = 'U = ?';
            document.getElementById('step2Formula').textContent = 'i = ?';
            document.getElementById('step3Formula').textContent = 'V = ?';
            document.getElementById('step4Formula').textContent = 'V ? prob[i]';
            document.getElementById('step5Formula').textContent = 'Result = ?';
        }

        function updateSamplingStats() {
            const total = samples.length;
            document.getElementById('statTotalSamples').textContent = total;
            document.getElementById('statNativeHits').textContent = nativeHits;
            document.getElementById('statAliasHits').textContent = aliasHits;
            document.getElementById('sampleCount').textContent = total;
        }

        // ============================================================
        // HISTOGRAM
        // ============================================================
        function drawHistogram() {
            const canvas = document.getElementById('histogramCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const total = samples.length;
            
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const targetW = Math.floor(rect.width * dpr);
            const targetH = Math.floor(rect.height * dpr);
            
            // Only resize if needed (avoid layout thrash)
            if (canvas.width !== targetW || canvas.height !== targetH) {
                canvas.width = targetW;
                canvas.height = targetH;
            }
            
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { left: 40, right: 20, top: 10, bottom: 20 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;
            
            ctx.clearRect(0, 0, width, height);
            
            // Axes
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();
            
            const barWidth = plotWidth / K - 6;
            
            // FIXED SCALE: Always use PMF max so gold lines never move
            // Scale to ~80% height so bars can overshoot slightly during sampling variance
            const maxScale = Math.max(...pmf) * 1.25;
            
            for (let i = 0; i < K; i++) {
                const x = padding.left + (i + 0.5) * (plotWidth / K) - barWidth / 2;
                
                // True probability lines (FIXED position - draw first as background)
                const trueHeight = (pmf[i] / maxScale) * plotHeight;
                const trueY = height - padding.bottom - trueHeight;
                
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x - 2, trueY);
                ctx.lineTo(x + barWidth + 2, trueY);
                ctx.stroke();
                
                // Sample frequency bars (only if we have samples)
                if (total > 0) {
                    const freq = (sampleCounts[i] || 0) / total;
                    // Cap bar height at plot height (in case of overshoot)
                    const barHeight = Math.min((freq / maxScale) * plotHeight, plotHeight);
                    
                    ctx.fillStyle = colorHex[i];
                    ctx.globalAlpha = 0.85;
                    ctx.fillRect(x, height - padding.bottom - barHeight, barWidth, barHeight);
                    ctx.globalAlpha = 1.0;
                }
                
                // Labels
                ctx.fillStyle = '#94a3b8';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText((i + 1).toString(), x + barWidth / 2, height - padding.bottom + 12);
            }
            
            // Show "no samples yet" message
            if (total === 0) {
                ctx.fillStyle = 'rgba(148, 163, 184, 0.5)';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Gold lines show target ‚Äî sample to see bars grow!', width / 2, height / 2);
            }
        }

        function drawOriginalPmf() {
            const canvas = document.getElementById('originalPmfCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            // Set canvas size once based on container
            const targetW = Math.floor(rect.width * dpr);
            const targetH = Math.floor(rect.height * dpr);
            
            // Only resize if needed
            if (canvas.width !== targetW || canvas.height !== targetH) {
                canvas.width = targetW;
                canvas.height = targetH;
            }
            
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { left: 40, right: 20, top: 8, bottom: 18 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;
            
            ctx.clearRect(0, 0, width, height);
            
            // Axes
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();
            
            const barWidth = plotWidth / K - 6;
            const maxPmf = Math.max(...pmf) * 1.1;
            
            for (let i = 0; i < K; i++) {
                const x = padding.left + (i + 0.5) * (plotWidth / K) - barWidth / 2;
                const barHeight = (pmf[i] / maxPmf) * plotHeight;
                
                ctx.fillStyle = colorHex[i];
                ctx.fillRect(x, height - padding.bottom - barHeight, barWidth, barHeight);
                
                // Label
                ctx.fillStyle = '#94a3b8';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText((i + 1).toString(), x + barWidth / 2, height - padding.bottom + 10);
                
                // Probability value on top of bar (if space)
                if (barHeight > 12) {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 8px sans-serif';
                    ctx.fillText(pmf[i].toFixed(2), x + barWidth / 2, height - padding.bottom - barHeight + 10);
                }
            }
            
            // Y-axis label
            ctx.fillStyle = '#94a3b8';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText('p(k)', padding.left - 5, padding.top + 8);
        }

        // ============================================================
        // BENCHMARK
        // ============================================================
        async function runBenchmark() {
            const benchK = parseInt(document.getElementById('benchmarkK').value);
            const benchN = parseInt(document.getElementById('benchmarkN').value);
            const benchDist = document.getElementById('benchmarkDist').value;
            
            // Generate PMF
            let benchPmf;
            if (benchDist === 'uniform') {
                benchPmf = new Float64Array(benchK);
                for (let i = 0; i < benchK; i++) benchPmf[i] = 1 / benchK;
            } else if (benchDist === 'geometric') {
                const raw = new Float64Array(benchK);
                let sum = 0;
                for (let i = 0; i < benchK; i++) {
                    raw[i] = Math.pow(0.8, i);
                    sum += raw[i];
                }
                benchPmf = new Float64Array(benchK);
                for (let i = 0; i < benchK; i++) benchPmf[i] = raw[i] / sum;
            } else { // zipf
                const raw = new Float64Array(benchK);
                let sum = 0;
                for (let i = 0; i < benchK; i++) {
                    raw[i] = 1 / (i + 1);
                    sum += raw[i];
                }
                benchPmf = new Float64Array(benchK);
                for (let i = 0; i < benchK; i++) benchPmf[i] = raw[i] / sum;
            }
            
            // Draw distribution preview
            drawBenchmarkDistribution(benchPmf, benchK, benchDist);
            
            // Use seedable RNG for reproducible benchmarks
            const benchRng = mulberry32(12345);
            
            // Warm-up to stabilize JIT
            for (let i = 0; i < 20000; i++) {
                const x = (i * 1664525 + 1013904223) | 0;
            }
            // Yield to allow GC
            await new Promise(r => setTimeout(r, 10));
            
            // ============================================================
            // ALIAS METHOD: Setup + Sampling
            // ============================================================
            const t0AliasSetup = performance.now();
            
            const aliasProb = new Float64Array(benchK);
            const aliasTable = new Int32Array(benchK);
            buildAliasTable(benchPmf, aliasProb, aliasTable);
            
            const tAliasSetup = performance.now() - t0AliasSetup;
            
            const benchRngAlias = mulberry32(12345);
            const t0AliasSample = performance.now();
            for (let i = 0; i < benchN; i++) {
                const U = benchRngAlias() * benchK;
                const idx = Math.floor(U);
                const V = U - idx;
                const clampedP = aliasProb[idx] <= 0 ? 0 : aliasProb[idx] >= 1 ? 1 : aliasProb[idx];
                const result = V < clampedP ? idx : aliasTable[idx];
            }
            const tAliasSample = performance.now() - t0AliasSample;
            const tAliasTotal = tAliasSetup + tAliasSample;
            
            // ============================================================
            // BINARY SEARCH: Setup (CDF) + Sampling
            // ============================================================
            const t0BinarySetup = performance.now();
            
            const benchCdf = new Float64Array(benchK + 1);
            benchCdf[0] = 0;
            for (let i = 0; i < benchK; i++) {
                benchCdf[i + 1] = benchCdf[i] + benchPmf[i];
            }
            for (let i = 1; i <= benchK; i++) {
                benchCdf[i] = Math.min(benchCdf[i], 1.0);
            }
            benchCdf[benchK] = 1.0;
            
            const tBinarySetup = performance.now() - t0BinarySetup;
            
            const benchRngBinary = mulberry32(12345);
            const t0BinarySample = performance.now();
            for (let i = 0; i < benchN; i++) {
                const u = benchRngBinary();
                let lo = 1, hi = benchK;
                while (lo < hi) {
                    const mid = (lo + hi) >> 1;
                    if (u <= benchCdf[mid]) hi = mid;
                    else lo = mid + 1;
                }
            }
            const tBinarySample = performance.now() - t0BinarySample;
            const tBinaryTotal = tBinarySetup + tBinarySample;
            
            // ============================================================
            // LINEAR SEARCH: Setup (just PMF copy) + Sampling
            // ============================================================
            const t0LinearSetup = performance.now();
            
            // Linear search just needs the PMF (already have it)
            const linearPmf = new Float64Array(benchPmf);
            
            const tLinearSetup = performance.now() - t0LinearSetup;
            
            const benchRngLinear = mulberry32(12345);
            const t0LinearSample = performance.now();
            for (let i = 0; i < benchN; i++) {
                const u = benchRngLinear();
                let cumsum = 0;
                for (let k = 0; k < benchK; k++) {
                    cumsum += linearPmf[k];
                    if (u <= cumsum) break;
                }
            }
            const tLinearSample = performance.now() - t0LinearSample;
            const tLinearTotal = tLinearSetup + tLinearSample;
            
            // ============================================================
            // Display Results
            // ============================================================
            
            // Setup vs Sampling Breakdown
            const breakdownDiv = document.getElementById('benchmarkBreakdownRows');
            const minTotal = Math.min(tAliasTotal, tBinaryTotal, tLinearTotal);
            
            breakdownDiv.innerHTML = `
                <div class="benchmark-row ${tAliasTotal <= minTotal * 1.05 ? 'benchmark-winner' : ''}">
                    <span>Alias</span>
                    <span>${tAliasSetup.toFixed(2)} ms</span>
                    <span>${tAliasSample.toFixed(2)} ms</span>
                    <span>${tAliasTotal.toFixed(2)} ms</span>
                </div>
                <div class="benchmark-row ${tBinaryTotal <= minTotal * 1.05 ? 'benchmark-winner' : ''}">
                    <span>Binary</span>
                    <span>${tBinarySetup.toFixed(2)} ms</span>
                    <span>${tBinarySample.toFixed(2)} ms</span>
                    <span>${tBinaryTotal.toFixed(2)} ms</span>
                </div>
                <div class="benchmark-row ${tLinearTotal <= minTotal * 1.05 ? 'benchmark-winner' : ''}">
                    <span>Linear</span>
                    <span>${tLinearSetup.toFixed(2)} ms</span>
                    <span>${tLinearSample.toFixed(2)} ms</span>
                    <span>${tLinearTotal.toFixed(2)} ms</span>
                </div>
            `;
            
            // Per-sample cost
            document.getElementById('benchmarkPerSample').style.display = 'block';
            const perSampleDiv = document.getElementById('benchmarkPerSampleRows');
            const aliasPerSample = (tAliasTotal / benchN) * 1000; // Œºs
            const binaryPerSample = (tBinaryTotal / benchN) * 1000;
            const linearPerSample = (tLinearTotal / benchN) * 1000;
            const minPerSample = Math.min(aliasPerSample, binaryPerSample, linearPerSample);
            
            perSampleDiv.innerHTML = `
                <div class="benchmark-row ${aliasPerSample <= minPerSample * 1.05 ? 'benchmark-winner' : ''}">
                    <span>Alias</span>
                    <span>${aliasPerSample.toFixed(3)}</span>
                    <span>${(aliasPerSample / minPerSample).toFixed(2)}x</span>
                </div>
                <div class="benchmark-row ${binaryPerSample <= minPerSample * 1.05 ? 'benchmark-winner' : ''}">
                    <span>Binary</span>
                    <span>${binaryPerSample.toFixed(3)}</span>
                    <span>${(binaryPerSample / minPerSample).toFixed(2)}x</span>
                </div>
                <div class="benchmark-row ${linearPerSample <= minPerSample * 1.05 ? 'benchmark-winner' : ''}">
                    <span>Linear</span>
                    <span>${linearPerSample.toFixed(3)}</span>
                    <span>${(linearPerSample / minPerSample).toFixed(2)}x</span>
                </div>
            `;
            
            // Break-even analysis
            const insightDiv = document.getElementById('benchmarkInsight');
            const insightText = document.getElementById('benchmarkInsightText');
            insightDiv.style.display = 'block';
            
            // Calculate break-even point (when alias setup cost is amortized)
            const aliasSampleRate = tAliasSample / benchN;
            const binarySampleRate = tBinarySample / benchN;
            let breakEven = 'N/A';
            if (binarySampleRate > aliasSampleRate) {
                breakEven = Math.ceil(tAliasSetup / (binarySampleRate - aliasSampleRate));
            }
            
            if (tAliasTotal < tBinaryTotal && tAliasTotal < tLinearTotal) {
                insightText.innerHTML = `
                    <strong style="color: #4ade80;">Alias wins!</strong><br><br>
                    <strong>Setup:</strong> Alias took ${tAliasSetup.toFixed(1)}ms to build tables (O(K)).<br>
                    <strong>Sampling:</strong> ${benchN.toLocaleString()} samples in ${tAliasSample.toFixed(1)}ms ‚Äî that's O(1) per sample!<br><br>
                    <strong>Break-even vs Binary:</strong> ~${typeof breakEven === 'number' ? breakEven.toLocaleString() : breakEven} samples.<br>
                    After that, every additional sample is faster with alias.
                `;
            } else if (tAliasSetup > tAliasTotal * 0.5) {
                insightText.innerHTML = `
                    <strong style="color: #fbbf24;">Setup dominates!</strong><br><br>
                    Alias setup (${tAliasSetup.toFixed(1)}ms) is more than half the total time.<br>
                    Try increasing N to ${(benchN * 10).toLocaleString()} to see alias method's O(1) sampling win!<br><br>
                    <strong>Rule of thumb:</strong> Alias method pays off when N >> K.
                `;
            } else {
                insightText.innerHTML = `
                    <strong>Mixed results at K=${benchK.toLocaleString()}</strong><br><br>
                    Setup: Alias ${tAliasSetup.toFixed(1)}ms, Binary ${tBinarySetup.toFixed(1)}ms<br>
                    Sampling: Alias ${tAliasSample.toFixed(1)}ms, Binary ${tBinarySample.toFixed(1)}ms<br><br>
                    Try larger K or N to see clearer separation.
                `;
            }
            
            // Draw charts
            drawComplexityChart();
            drawAmortizationChart(tAliasSetup, tAliasSample, tBinarySetup, tBinarySample, tLinearSetup, tLinearSample, benchN, benchK);
        }
        
        function drawBenchmarkDistribution(pmf, K, distType) {
            const pmfCanvas = document.getElementById('benchmarkPmfCanvas');
            const cdfCanvas = document.getElementById('benchmarkCdfCanvas');
            if (!pmfCanvas || !cdfCanvas) return;
            
            // PMF
            const ctx1 = pmfCanvas.getContext('2d');
            const rect1 = pmfCanvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            pmfCanvas.width = Math.floor(rect1.width * dpr);
            pmfCanvas.height = Math.floor(rect1.height * dpr);
            ctx1.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            const w1 = rect1.width, h1 = rect1.height;
            const pad = { left: 5, right: 5, top: 5, bottom: 15 };
            const plotW = w1 - pad.left - pad.right;
            const plotH = h1 - pad.top - pad.bottom;
            
            ctx1.clearRect(0, 0, w1, h1);
            
            // Show first 50 bins or all if K <= 50
            const showK = Math.min(K, 50);
            const maxPmf = Math.max(...Array.from(pmf).slice(0, showK)) * 1.1;
            const barW = plotW / showK - 1;
            
            for (let i = 0; i < showK; i++) {
                const x = pad.left + (i + 0.5) * (plotW / showK) - barW / 2;
                const barH = (pmf[i] / maxPmf) * plotH;
                
                // Color gradient from blue to purple
                const hue = 220 + (i / showK) * 60;
                ctx1.fillStyle = `hsl(${hue}, 70%, 60%)`;
                ctx1.fillRect(x, h1 - pad.bottom - barH, barW, barH);
            }
            
            // Labels
            ctx1.fillStyle = '#64748b';
            ctx1.font = '9px sans-serif';
            ctx1.textAlign = 'center';
            ctx1.fillText('1', pad.left + plotW / showK / 2, h1 - 2);
            ctx1.fillText(showK.toString(), w1 - pad.right - plotW / showK / 2, h1 - 2);
            if (K > 50) {
                ctx1.fillStyle = '#f59e0b';
                ctx1.fillText('...', w1 - 15, h1 / 2);
            }
            
            // CDF
            const ctx2 = cdfCanvas.getContext('2d');
            const rect2 = cdfCanvas.getBoundingClientRect();
            cdfCanvas.width = Math.floor(rect2.width * dpr);
            cdfCanvas.height = Math.floor(rect2.height * dpr);
            ctx2.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            const w2 = rect2.width, h2 = rect2.height;
            const pad2 = { left: 5, right: 5, top: 5, bottom: 10 };
            const plotW2 = w2 - pad2.left - pad2.right;
            const plotH2 = h2 - pad2.top - pad2.bottom;
            
            ctx2.clearRect(0, 0, w2, h2);
            
            // Draw CDF line
            ctx2.strokeStyle = '#22c55e';
            ctx2.lineWidth = 2;
            ctx2.beginPath();
            
            let cumsum = 0;
            for (let i = 0; i < showK; i++) {
                cumsum += pmf[i];
                const x = pad2.left + ((i + 1) / showK) * plotW2;
                const y = h2 - pad2.bottom - cumsum * plotH2;
                if (i === 0) ctx2.moveTo(pad2.left, h2 - pad2.bottom);
                ctx2.lineTo(x, y);
            }
            ctx2.stroke();
            
            // Labels
            ctx2.fillStyle = '#64748b';
            ctx2.font = '9px sans-serif';
            ctx2.textAlign = 'left';
            ctx2.fillText('0', 2, h2 - pad2.bottom);
            ctx2.fillText('1', 2, pad2.top + 8);
            
            // Distribution info
            const info = document.getElementById('benchmarkDistInfo');
            const p1 = (pmf[0] * 100).toFixed(1);
            const pK = (pmf[K-1] * 100).toFixed(4);
            info.textContent = `p(1)=${p1}%, p(${K})=${pK}%`;
        }
        
        function drawAmortizationChart(aliasSetup, aliasSample, binarySetup, binarySample, linearSetup, linearSample, N, K) {
            const canvas = document.getElementById('amortizationCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.floor(rect.width * dpr);
            canvas.height = Math.floor(rect.height * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { left: 50, right: 20, top: 20, bottom: 35 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;
            
            ctx.clearRect(0, 0, width, height);
            
            // Axes
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();
            
            // Calculate costs at different N values
            const nValues = [1, 10, 100, 1000, 10000, 100000, 1000000].filter(n => n <= N * 10);
            const aliasRate = aliasSample / N;
            const binaryRate = binarySample / N;
            const linearRate = linearSample / N;
            
            // Find max for scaling
            const maxN = nValues[nValues.length - 1];
            const costs = nValues.map(n => ({
                n,
                alias: aliasSetup + aliasRate * n,
                binary: binarySetup + binaryRate * n,
                linear: linearSetup + linearRate * n
            }));
            const maxCost = Math.max(...costs.map(c => Math.max(c.alias, c.binary, Math.min(c.linear, c.alias * 5))));
            
            // X-axis (log scale)
            const logMin = 0, logMax = Math.log10(maxN);
            
            // Draw lines
            const drawLine = (color, getCost) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i <= 50; i++) {
                    const logN = logMin + (i / 50) * (logMax - logMin);
                    const n = Math.pow(10, logN);
                    const cost = getCost(n);
                    const x = padding.left + (logN / logMax) * plotWidth;
                    const y = height - padding.bottom - (Math.min(cost, maxCost) / maxCost) * plotHeight;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            };
            
            drawLine('#22c55e', n => aliasSetup + aliasRate * n);  // Alias - green
            drawLine('#3b82f6', n => binarySetup + binaryRate * n); // Binary - blue
            drawLine('#ef4444', n => linearSetup + linearRate * n); // Linear - red (may go off chart)
            
            // Mark current N
            const currentLogN = Math.log10(N);
            const currentX = padding.left + (currentLogN / logMax) * plotWidth;
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(currentX, padding.top);
            ctx.lineTo(currentX, height - padding.bottom);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#fbbf24';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`N=${N.toLocaleString()}`, currentX, padding.top - 5);
            
            // X-axis labels
            ctx.fillStyle = '#94a3b8';
            ctx.font = '9px sans-serif';
            [1, 100, 10000, 1000000].filter(n => n <= maxN).forEach(n => {
                const x = padding.left + (Math.log10(n) / logMax) * plotWidth;
                ctx.fillText(n >= 1000 ? (n/1000) + 'K' : n.toString(), x, height - padding.bottom + 12);
            });
            ctx.fillText('N (samples)', width / 2, height - 5);
            
            // Y-axis label
            ctx.save();
            ctx.translate(12, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Total time (ms)', 0, 0);
            ctx.restore();
            
            // Legend
            ctx.font = '9px sans-serif';
            ctx.fillStyle = '#22c55e';
            ctx.fillText('‚óè Alias', padding.left + 10, padding.top + 10);
            ctx.fillStyle = '#3b82f6';
            ctx.fillText('‚óè Binary', padding.left + 60, padding.top + 10);
            ctx.fillStyle = '#ef4444';
            ctx.fillText('‚óè Linear', padding.left + 115, padding.top + 10);
        }

        function buildAliasTable(pmf, prob, alias) {
            const K = pmf.length;
            const q = new Float64Array(K);
            for (let i = 0; i < K; i++) q[i] = pmf[i] * K;
            
            const small = [], large = [];
            for (let i = 0; i < K; i++) {
                (q[i] < 1 - 1e-10 ? small : large).push(i);
            }
            
            while (small.length && large.length) {
                const j = small.pop();
                const l = large.pop();
                // Clamp to [0, 1] to handle FP drift
                prob[j] = q[j] <= 0 ? 0 : q[j] >= 1 ? 1 : q[j];
                alias[j] = l;
                // Clamp to avoid tiny negatives
                q[l] = Math.max(0, q[l] - (1 - prob[j]));
                (q[l] < 1 - 1e-10 ? small : large).push(l);
            }
            
            while (small.length) {
                const i = small.pop();
                prob[i] = 1;
                alias[i] = i;
            }
            while (large.length) {
                const i = large.pop();
                prob[i] = 1;
                alias[i] = i;
            }
        }

        function drawComplexityChart() {
            const canvas = document.getElementById('complexityCanvas');
            const ctx = canvas.getContext('2d');
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { left: 60, right: 30, top: 30, bottom: 40 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;
            
            ctx.clearRect(0, 0, width, height);
            
            // Axes
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#94a3b8';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('K (categories)', width / 2, height - 5);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Comparisons per sample', 0, 0);
            ctx.restore();
            
            // X-axis ticks
            const kValues = [10, 100, 1000, 10000, 100000];
            const logMin = 1, logMax = 5;
            
            kValues.forEach(k => {
                const logK = Math.log10(k);
                const x = padding.left + ((logK - logMin) / (logMax - logMin)) * plotWidth;
                ctx.fillStyle = '#94a3b8';
                ctx.fillText(k >= 1000 ? (k/1000) + 'K' : k.toString(), x, height - padding.bottom + 15);
            });
            
            // Y-axis
            const yMax = 20;
            for (let y = 0; y <= yMax; y += 5) {
                const yPos = height - padding.bottom - (y / yMax) * plotHeight;
                ctx.fillStyle = '#94a3b8';
                ctx.textAlign = 'right';
                ctx.fillText(y.toString(), padding.left - 8, yPos + 4);
                
                ctx.strokeStyle = 'rgba(100, 116, 139, 0.3)';
                ctx.beginPath();
                ctx.moveTo(padding.left, yPos);
                ctx.lineTo(width - padding.right, yPos);
                ctx.stroke();
            }
            
            // Plot lines
            const points = 50;
            
            // Alias (constant 1)
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i <= points; i++) {
                const logK = logMin + (i / points) * (logMax - logMin);
                const x = padding.left + (i / points) * plotWidth;
                const y = height - padding.bottom - (1 / yMax) * plotHeight;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Binary (log2 K)
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i <= points; i++) {
                const logK = logMin + (i / points) * (logMax - logMin);
                const k = Math.pow(10, logK);
                const comparisons = Math.ceil(Math.log2(k));
                const x = padding.left + (i / points) * plotWidth;
                const y = height - padding.bottom - (comparisons / yMax) * plotHeight;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Linear (K/2 average for uniform, capped at yMax)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            for (let i = 0; i <= points; i++) {
                const logK = logMin + (i / points) * (logMax - logMin);
                const k = Math.pow(10, logK);
                const comparisons = Math.min(k / 2, yMax);
                const x = padding.left + (i / points) * plotWidth;
                const y = height - padding.bottom - (comparisons / yMax) * plotHeight;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Legend
            const legendX = padding.left + 20;
            const legendY = padding.top + 10;
            
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(legendX, legendY, 20, 3);
            ctx.fillStyle = '#e2e8f0';
            ctx.textAlign = 'left';
            ctx.fillText('Alias O(1)', legendX + 25, legendY + 4);
            
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(legendX + 90, legendY, 20, 3);
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('Binary O(log K)', legendX + 115, legendY + 4);
            
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(legendX + 210, legendY, 20, 3);
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('Linear O(K)', legendX + 235, legendY + 4);
        }

        // ============================================================
        // INIT
        // ============================================================
        window.addEventListener('load', init);
        window.addEventListener('resize', () => {
            if (document.getElementById('sampling').classList.contains('active')) {
                // Only redraw histogram on resize, not the static PMF
                drawHistogram();
            }
            if (document.getElementById('benchmark').classList.contains('active')) {
                drawComplexityChart();
            }
        });
    </script>
</body>
</html>
