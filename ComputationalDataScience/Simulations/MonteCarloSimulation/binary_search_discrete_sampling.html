<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search for Discrete Sampling - Interactive Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #fff;
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 5px;
            font-size: 1.8em;
            color: #4ade80;
        }

        .subtitle {
            text-align: center;
            color: #94a3b8;
            margin-bottom: 15px;
            font-size: 0.95em;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 280px 1fr 300px;
            gap: 15px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }

        .panel-title {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 12px;
            color: #60a5fa;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 8px;
        }

        /* Controls */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.85em;
            color: #94a3b8;
        }

        select, input[type="number"] {
            padding: 8px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 0.9em;
        }

        .dist-description {
            font-size: 0.8em;
            color: #fbbf24;
            padding: 6px 8px;
            background: rgba(251, 191, 36, 0.1);
            border-radius: 4px;
            border-left: 3px solid #f59e0b;
            margin-top: 5px;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #22c55e;
            color: white;
        }

        .btn-primary:hover {
            background: #16a34a;
        }

        .btn-secondary {
            background: #3b82f6;
            color: white;
        }

        .btn-secondary:hover {
            background: #2563eb;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        /* U Value Display */
        .u-display {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            margin: 10px 0;
        }

        .u-label {
            font-size: 0.85em;
            color: #94a3b8;
        }

        .u-value {
            font-size: 2em;
            font-weight: bold;
            color: #ef4444;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        /* PMF/CDF Table */
        .table-container {
            max-height: 320px;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8em;
        }

        th, td {
            padding: 6px 8px;
            text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        th {
            background: rgba(0,0,0,0.3);
            color: #60a5fa;
            position: sticky;
            top: 0;
        }

        tr.visited {
            background: rgba(239, 68, 68, 0.3);
        }

        tr.found {
            background: rgba(34, 197, 94, 0.4);
        }

        tr.in-range {
            background: rgba(251, 191, 36, 0.2);
        }

        /* Center Panel - Visualizations */
        .viz-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        canvas {
            width: 100%;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        #cdfCanvas {
            height: 200px;
        }

        #treeCanvas {
            height: 280px;
        }

        /* Right Panel - Search Trace */
        .trace-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .step-card {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            border-left: 4px solid #6b7280;
            transition: all 0.3s;
        }

        .step-card.active {
            border-left-color: #f59e0b;
            background: rgba(245, 158, 11, 0.2);
        }

        .step-card.completed {
            border-left-color: #22c55e;
        }

        .step-number {
            font-size: 0.75em;
            color: #94a3b8;
            margin-bottom: 4px;
        }

        .step-comparison {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.95em;
            margin-bottom: 4px;
        }

        .step-result {
            font-weight: bold;
            font-size: 0.9em;
        }

        .step-result.go-left {
            color: #60a5fa;
        }

        .step-result.go-right {
            color: #f97316;
        }

        .step-result.found {
            color: #22c55e;
        }

        /* Algorithm Display */
        .algorithm-box {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.8em;
            line-height: 1.6;
        }

        .algo-highlight {
            background: rgba(245, 158, 11, 0.4);
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Explanation Box */
        .explanation {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(139, 92, 246, 0.2));
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .explanation-title {
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 8px;
        }

        .explanation-text {
            font-size: 0.9em;
            line-height: 1.5;
            color: #e2e8f0;
        }

        /* Minimax insight */
        .insight-box {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(16, 185, 129, 0.15));
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
        }

        .insight-title {
            font-weight: bold;
            color: #4ade80;
            font-size: 0.9em;
            margin-bottom: 6px;
        }

        .insight-text {
            font-size: 0.85em;
            color: #a7f3d0;
        }

        /* Comparison box */
        .comparison-box {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .comparison-title {
            font-weight: bold;
            color: #a78bfa;
            font-size: 0.85em;
            margin-bottom: 8px;
        }

        .comparison-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            padding: 3px 0;
            color: #e2e8f0;
        }

        .comparison-value {
            font-weight: bold;
            font-family: monospace;
        }

        .comparison-verdict {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.8em;
            color: #4ade80;
            text-align: center;
        }

        /* Stats bar */
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-item {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #4ade80;
        }

        .stat-label {
            font-size: 0.75em;
            color: #94a3b8;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Binary Search for Discrete Sampling</h1>
        <p class="subtitle">Interactive visualization of the inverse CDF method using binary search ‚Äî guaranteed O(log K) performance</p>

        <div class="main-grid">
            <!-- Left Panel: Controls & Table -->
            <div class="panel">
                <div class="panel-title">‚öôÔ∏è Controls</div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Distribution Shape (K=16)</label>
                        <select id="distribution">
                            <optgroup label="Classic Shapes">
                                <option value="uniform">Uniform</option>
                                <option value="unimodal" selected>Unimodal (Bell-shaped)</option>
                                <option value="ushaped">U-shaped (Bathtub)</option>
                                <option value="bimodal">Bimodal</option>
                            </optgroup>
                            <optgroup label="Skewed Distributions">
                                <option value="headheavy">Head-heavy (Geometric)</option>
                                <option value="tailheavy">Tail-heavy (Reversed)</option>
                                <option value="poisson">Poisson-like (Œª=5)</option>
                                <option value="zipf">Zipf's Law (Power)</option>
                            </optgroup>
                            <optgroup label="Extreme Cases">
                                <option value="pointmass">Point Mass at k=8</option>
                                <option value="adversarial">Adversarial (99% at k=16)</option>
                            </optgroup>
                            <optgroup label="Real-World">
                                <option value="fairdie">Fair Die (K=6)</option>
                            </optgroup>
                        </select>
                        <div class="dist-description" id="distDescription">
                            Like Binomial(15, 0.5) ‚Äî single peak in the middle
                        </div>
                    </div>

                    <div class="u-display">
                        <div class="u-label">Random Uniform Value</div>
                        <div class="u-value" id="uValue" role="status" aria-live="polite">‚Äî</div>
                    </div>

                    <div class="btn-group">
                        <button class="btn-primary" id="newSearchBtn">üé≤ New Search</button>
                        <button class="btn-secondary" id="stepBtn" disabled>Step ‚Üí</button>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn-warning" id="autoBtn" disabled>‚ñ∂ Auto Play</button>
                        <button class="btn-secondary" id="resetBtn">‚Ü∫ Reset</button>
                    </div>
                </div>

                <div class="panel-title" style="margin-top: 15px;">üìä PMF Shape</div>
                <canvas id="pmfCanvas" style="height: 80px; width: 100%;"></canvas>

                <div class="panel-title" style="margin-top: 10px;">üìã PMF & CDF Table <span style="font-size: 0.7em; color: #94a3b8;">(rounded)</span></div>
                <div class="table-container" style="max-height: 200px;">
                    <table id="dataTable">
                        <thead>
                            <tr>
                                <th>k</th>
                                <th>p(k)</th>
                                <th>F(k)</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody">
                        </tbody>
                    </table>
                </div>

                <!-- Linear vs Binary comparison -->
                <div class="comparison-box" id="comparisonBox" style="display: none;">
                    <div class="comparison-title">‚öñÔ∏è Method Comparison</div>
                    <div class="comparison-row">
                        <span>Binary Search:</span>
                        <span class="comparison-value" id="binarySteps">‚Äî</span>
                    </div>
                    <div class="comparison-row">
                        <span>Linear (L‚ÜíR):</span>
                        <span class="comparison-value" id="linearLRSteps">‚Äî</span>
                    </div>
                    <div class="comparison-row">
                        <span>Linear (R‚ÜíL):</span>
                        <span class="comparison-value" id="linearRLSteps">‚Äî</span>
                    </div>
                    <div class="comparison-verdict" id="comparisonVerdict"></div>
                </div>
            </div>

            <!-- Center Panel: Visualizations -->
            <div class="panel">
                <div class="panel-title">üìà CDF Step Function</div>
                <canvas id="cdfCanvas"></canvas>

                <div class="panel-title" style="margin-top: 15px;">üå≥ Binary Search Tree</div>
                <canvas id="treeCanvas"></canvas>

                <div class="stats-bar" role="region" aria-label="Search statistics">
                    <div class="stat-item">
                        <div class="stat-value" id="statK">16</div>
                        <div class="stat-label">Categories (K)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statSteps" role="status" aria-live="polite">0</div>
                        <div class="stat-label">Steps Taken</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statMax">4</div>
                        <div class="stat-label">At Most (‚åàlog‚ÇÇK‚åâ)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statResult" role="status" aria-live="polite">‚Äî</div>
                        <div class="stat-label">Result (k)</div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Search Trace & Explanation -->
            <div class="panel">
                <div class="panel-title">üîé Search Trace</div>
                
                <div class="algorithm-box" id="algorithmBox">
                    <div style="color: #94a3b8; font-size: 0.9em; margin-bottom: 4px;">// Invariant: answer ‚àà [low, high]</div>
                    <div>low ‚Üê <span id="algoLow">1</span>, high ‚Üê <span id="algoHigh">16</span></div>
                    <div id="algoLine" class="algo-highlight" style="display:none;">
                        mid ‚Üê ‚åä(low + high)/2‚åã = <span id="algoMid">?</span>
                    </div>
                </div>

                <div class="trace-container" id="traceContainer" role="log" aria-live="polite" aria-label="Search trace steps">
                    <div style="text-align: center; color: #94a3b8; padding: 20px;">
                        Click "New Search" to begin
                    </div>
                </div>

                <div class="explanation" id="explanationBox">
                    <div class="explanation-title">üí° The Binary Search Invariant</div>
                    <div class="explanation-text">
                        <strong>Goal:</strong> Find the least k with F(k) ‚â• U ‚Äî equivalent to a <em>lower_bound</em> search on the CDF staircase.<br><br>
                        <strong>Invariant:</strong> The answer is always in [low, high]. Each step halves this interval.
                    </div>
                </div>

                <div class="insight-box">
                    <div class="insight-title">üéØ Minimax Guarantee</div>
                    <div class="insight-text">
                        Binary search <em>minimizes the maximum</em> cost. No matter where U falls, 
                        we complete in <strong>at most</strong> ‚åàlog‚ÇÇ K‚åâ steps. For K=16, that's ‚â§ 4 steps.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // DISTRIBUTION DEFINITIONS
        // ============================================================
        const K = 16;
        
        const distributions = {
            unimodal: {
                name: "Unimodal (Bell-shaped)",
                description: "Like Binomial(15, 0.5) ‚Äî single peak in the middle",
                // Binomial-like: single peak at center
                pmf: [0.002, 0.004, 0.008, 0.016, 0.031, 0.063, 0.125, 0.251, 
                      0.251, 0.125, 0.063, 0.031, 0.016, 0.008, 0.004, 0.002]
            },
            ushaped: {
                name: "U-shaped (Bathtub)",
                description: "Like Beta(0.5, 0.5) ‚Äî mass at both extremes",
                // True U-shape: high at ends, low in middle
                pmf: (() => {
                    const raw = Array.from({length: 16}, (_, i) => {
                        // Beta(0.5, 0.5) shape: high at 0 and 1
                        const x = (i + 0.5) / 16;
                        return 1 / Math.sqrt(x * (1 - x));
                    });
                    return raw; // Will be normalized below
                })()
            },
            uniform: {
                name: "Uniform",
                description: "Equal probability ‚Äî baseline comparison",
                pmf: Array(16).fill(1/16)
            },
            headheavy: {
                name: "Head-heavy (Geometric-like)",
                description: "~70% in first 4 bins ‚Äî linear scan L‚ÜíR wins here!",
                // Geometric-like: most mass at low k
                pmf: (() => {
                    return Array.from({length: 16}, (_, i) => Math.pow(0.65, i));
                })()
            },
            tailheavy: {
                name: "Tail-heavy (Reversed)",
                description: "~70% in last 4 bins ‚Äî linear scan R‚ÜíL wins here!",
                // Reversed geometric: most mass at high k
                pmf: (() => {
                    return Array.from({length: 16}, (_, i) => Math.pow(0.65, 15 - i));
                })()
            },
            bimodal: {
                name: "Bimodal",
                description: "Two peaks at k=4 and k=13 ‚Äî linear scan unpredictable",
                pmf: (() => {
                    return Array.from({length: 16}, (_, i) => {
                        // Two Gaussian-like peaks
                        const peak1 = Math.exp(-Math.pow(i - 3, 2) / 3);
                        const peak2 = Math.exp(-Math.pow(i - 12, 2) / 3);
                        return peak1 + peak2;
                    });
                })()
            },
            pointmass: {
                name: "Point Mass at k=8",
                description: "90% at middle ‚Äî adversarial for binary search intuition",
                pmf: (() => {
                    const raw = Array(16).fill(0.01);
                    raw[7] = 0.90; // k=8 (index 7)
                    return raw;
                })()
            },
            poisson: {
                name: "Poisson-like (Œª=5)",
                description: "Common in count data ‚Äî right-skewed",
                pmf: (() => {
                    const lambda = 5;
                    // Use iterative recurrence: p(k) = p(k-1) * Œª / k
                    const raw = [Math.exp(-lambda)]; // p(0)
                    for (let k = 1; k < 16; k++) {
                        raw.push(raw[k-1] * lambda / k);
                    }
                    return raw;
                })()
            },
            zipf: {
                name: "Zipf's Law (s=1)",
                description: "Power law ‚Äî common in NLP/word frequencies",
                pmf: (() => {
                    return Array.from({length: 16}, (_, i) => 1 / (i + 1));
                })()
            },
            adversarial: {
                name: "Adversarial for Linear",
                description: "99% at k=16 ‚Äî worst case for left-to-right scan",
                pmf: (() => {
                    const raw = Array(16).fill(0.001);
                    raw[15] = 0.99; // k=16 (index 15)
                    return raw;
                })()
            },
            fairdie: {
                name: "Fair Die (K=6 padded)",
                description: "Classic example ‚Äî uniform over {1,...,6}, zero elsewhere",
                pmf: (() => {
                    const raw = Array(16).fill(0);
                    for (let i = 0; i < 6; i++) raw[i] = 1/6;
                    return raw;
                })()
            }
        };

        // ============================================================
        // STATE MANAGEMENT
        // ============================================================
        let currentDist = 'unimodal';
        let pmf = [];
        let cdf = [];
        let U = null;
        let searchState = null;
        let searchHistory = [];
        let isAutoPlaying = false;
        let autoPlayInterval = null;

        // Tree node positions (precomputed for K=16)
        const treeNodes = {
            8:  { level: 0, x: 0.5 },
            4:  { level: 1, x: 0.25 },
            12: { level: 1, x: 0.75 },
            2:  { level: 2, x: 0.125 },
            6:  { level: 2, x: 0.375 },
            10: { level: 2, x: 0.625 },
            14: { level: 2, x: 0.875 },
            1:  { level: 3, x: 0.0625 },
            3:  { level: 3, x: 0.1875 },
            5:  { level: 3, x: 0.3125 },
            7:  { level: 3, x: 0.4375 },
            9:  { level: 3, x: 0.5625 },
            11: { level: 3, x: 0.6875 },
            13: { level: 3, x: 0.8125 },
            15: { level: 3, x: 0.9375 },
            16: { level: 4, x: 0.96875 }
        };

        const treeEdges = [
            [8, 4], [8, 12],
            [4, 2], [4, 6],
            [12, 10], [12, 14],
            [2, 1], [2, 3],
            [6, 5], [6, 7],
            [10, 9], [10, 11],
            [14, 13], [14, 15],
            [15, 16]
        ];

        // ============================================================
        // INITIALIZATION
        // ============================================================
        function init() {
            loadDistribution(currentDist);
            setupEventListeners();
            drawPMF();
            drawCDF();
            drawTree();
        }

        function loadDistribution(distKey) {
            currentDist = distKey;
            
            // Get raw PMF and normalize defensively
            const rawPmf = distributions[distKey].pmf.slice();
            const sum = rawPmf.reduce((a, b) => a + b, 0);
            pmf = rawPmf.map(x => x / sum);
            
            // Compute CDF with defensive capping
            cdf = [];
            let cumsum = 0;
            for (let i = 0; i < pmf.length; i++) {
                cumsum += pmf[i];
                // Cap at 1.0 to prevent floating-point drift
                cdf.push(Math.min(cumsum, 1.0));
            }
            // Force last element to exactly 1.0
            cdf[cdf.length - 1] = 1.0;
            
            // Update max steps dynamically
            const maxSteps = Math.ceil(Math.log2(K));
            document.getElementById('statMax').textContent = maxSteps;
            
            updateTable();
            drawPMF();
            drawCDF();
            drawTree();
        }

        function setupEventListeners() {
            document.getElementById('distribution').addEventListener('change', (e) => {
                loadDistribution(e.target.value);
                // Update description
                document.getElementById('distDescription').textContent = distributions[e.target.value].description;
                resetSearch();
            });

            document.getElementById('newSearchBtn').addEventListener('click', startNewSearch);
            document.getElementById('stepBtn').addEventListener('click', doStep);
            document.getElementById('autoBtn').addEventListener('click', toggleAutoPlay);
            document.getElementById('resetBtn').addEventListener('click', resetSearch);
        }

        // ============================================================
        // TABLE MANAGEMENT
        // ============================================================
        function updateTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            for (let k = 1; k <= K; k++) {
                const tr = document.createElement('tr');
                tr.id = `row-${k}`;
                tr.innerHTML = `
                    <td>${k}</td>
                    <td>${pmf[k-1].toFixed(3)}</td>
                    <td>${cdf[k-1].toFixed(3)}</td>
                `;
                tbody.appendChild(tr);
            }
        }

        function highlightTableRows() {
            // Clear all highlights
            for (let k = 1; k <= K; k++) {
                const row = document.getElementById(`row-${k}`);
                row.className = '';
            }

            if (!searchState) return;

            // Highlight range
            for (let k = searchState.low; k <= searchState.high; k++) {
                document.getElementById(`row-${k}`).classList.add('in-range');
            }

            // Highlight visited
            searchHistory.forEach(h => {
                document.getElementById(`row-${h.mid}`).classList.add('visited');
            });

            // Highlight found
            if (searchState.found !== null) {
                document.getElementById(`row-${searchState.found}`).classList.add('found');
            }
        }

        // ============================================================
        // SEARCH LOGIC
        // ============================================================
        function startNewSearch() {
            // Generate random U
            U = Math.random();
            document.getElementById('uValue').textContent = U.toFixed(6);
            
            // Initialize search state
            searchState = {
                low: 1,
                high: K,
                mid: null,
                found: null,
                step: 0
            };
            searchHistory = [];

            // Enable buttons
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;

            // Hide comparison until done
            document.getElementById('comparisonBox').style.display = 'none';

            // Update displays
            updateAlgorithmBox();
            updateTraceContainer();
            highlightTableRows();
            drawPMF();
            drawCDF();
            drawTree();
            
            document.getElementById('statSteps').textContent = '0';
            document.getElementById('statResult').textContent = '‚Äî';

            updateExplanation('start');
        }

        function doStep() {
            if (!searchState || searchState.found !== null) return;
            if (searchState.low >= searchState.high) {
                // Found!
                searchState.found = searchState.low;
                finishSearch();
                return;
            }

            // Compute mid
            const mid = Math.floor((searchState.low + searchState.high) / 2);
            searchState.mid = mid;
            searchState.step++;

            // Compare U with F(mid)
            const Fmid = cdf[mid - 1];
            let direction, newLow, newHigh;

            if (U <= Fmid) {
                direction = 'left';
                newLow = searchState.low;
                newHigh = mid;
            } else {
                direction = 'right';
                newLow = mid + 1;
                newHigh = searchState.high;
            }

            // Record history
            searchHistory.push({
                step: searchState.step,
                low: searchState.low,
                high: searchState.high,
                mid: mid,
                Fmid: Fmid,
                comparison: U <= Fmid ? '‚â§' : '>',
                direction: direction
            });

            // Update state
            searchState.low = newLow;
            searchState.high = newHigh;

            // Check if found
            if (searchState.low >= searchState.high) {
                searchState.found = searchState.low;
                finishSearch();
            }

            // Update displays
            updateAlgorithmBox();
            updateTraceContainer();
            highlightTableRows();
            drawPMF();
            drawCDF();
            drawTree();
            
            document.getElementById('statSteps').textContent = searchState.step;
            updateExplanation('step');
        }

        function finishSearch() {
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('autoBtn').disabled = true;
            stopAutoPlay();
            
            document.getElementById('statResult').textContent = searchState.found;
            updateExplanation('found');
            updateTraceContainer();
            highlightTableRows();
            drawPMF();
            drawCDF();
            drawTree();
            updateComparison();
        }

        function resetSearch() {
            stopAutoPlay();
            U = null;
            searchState = null;
            searchHistory = [];
            
            document.getElementById('uValue').textContent = '‚Äî';
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('autoBtn').disabled = true;
            document.getElementById('statSteps').textContent = '0';
            document.getElementById('statResult').textContent = '‚Äî';
            
            document.getElementById('algoLow').textContent = '1';
            document.getElementById('algoHigh').textContent = '16';
            document.getElementById('algoLine').style.display = 'none';
            
            document.getElementById('comparisonBox').style.display = 'none';
            
            updateTraceContainer();
            highlightTableRows();
            drawPMF();
            drawCDF();
            drawTree();
            updateExplanation('reset');
        }

        function toggleAutoPlay() {
            if (isAutoPlaying) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }

        function startAutoPlay() {
            isAutoPlaying = true;
            document.getElementById('autoBtn').textContent = '‚è∏ Pause';
            autoPlayInterval = setInterval(() => {
                if (searchState && searchState.found === null) {
                    doStep();
                } else {
                    stopAutoPlay();
                }
            }, 1200);
        }

        function stopAutoPlay() {
            isAutoPlaying = false;
            document.getElementById('autoBtn').textContent = '‚ñ∂ Auto Play';
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
        }

        // ============================================================
        // UI UPDATES
        // ============================================================
        function updateAlgorithmBox() {
            document.getElementById('algoLow').textContent = searchState.low;
            document.getElementById('algoHigh').textContent = searchState.high;
            
            if (searchState.mid !== null && searchState.found === null) {
                document.getElementById('algoLine').style.display = 'block';
                document.getElementById('algoMid').textContent = searchState.mid;
            } else {
                document.getElementById('algoLine').style.display = 'none';
            }
        }

        function updateTraceContainer() {
            const container = document.getElementById('traceContainer');
            
            if (searchHistory.length === 0 && !searchState) {
                container.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">Click "New Search" to begin</div>';
                return;
            }

            if (searchHistory.length === 0 && searchState) {
                container.innerHTML = '<div style="text-align: center; color: #fbbf24; padding: 20px;">Ready! Click "Step" or "Auto Play"</div>';
                return;
            }

            let html = '';
            searchHistory.forEach((h, idx) => {
                const isLast = idx === searchHistory.length - 1 && searchState.found === null;
                const dirClass = h.direction === 'left' ? 'go-left' : 'go-right';
                
                html += `
                    <div class="step-card ${isLast ? 'active' : 'completed'}">
                        <div class="step-number">Step ${h.step}</div>
                        <div class="step-comparison">
                            mid = ${h.mid}, F(${h.mid}) = ${h.Fmid.toFixed(3)}<br>
                            U = ${U.toFixed(3)} ${h.comparison} ${h.Fmid.toFixed(3)}
                        </div>
                        <div class="step-result ${dirClass}">
                            ‚Üí Go ${h.direction.toUpperCase()} (${h.direction === 'left' ? 'high ‚Üê mid' : 'low ‚Üê mid+1'})
                        </div>
                    </div>
                `;
            });

            if (searchState.found !== null) {
                html += `
                    <div class="step-card" style="border-left-color: #22c55e; background: rgba(34, 197, 94, 0.2);">
                        <div class="step-number">‚úì Complete</div>
                        <div class="step-comparison">low = high = ${searchState.found}</div>
                        <div class="step-result found">FOUND: k = ${searchState.found}</div>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        function updateExplanation(phase) {
            const box = document.getElementById('explanationBox');
            const title = box.querySelector('.explanation-title');
            const text = box.querySelector('.explanation-text');

            switch(phase) {
                case 'start':
                    title.textContent = 'üéØ Search Initialized';
                    text.innerHTML = `<strong>Goal:</strong> Find the least k with F(k) ‚â• U = ${U.toFixed(4)}.<br><br>
                        <strong>Invariant:</strong> Answer ‚àà [1, 16]. Binary search will narrow this by half each step.`;
                    break;
                case 'step':
                    const last = searchHistory[searchHistory.length - 1];
                    title.textContent = `üîç Step ${last.step}: Checked mid = ${last.mid}`;
                    if (last.direction === 'left') {
                        text.innerHTML = `F(${last.mid}) = ${last.Fmid.toFixed(3)} ‚â• U = ${U.toFixed(3)}<br><br>
                            Answer could be ${last.mid} or earlier.<br>
                            <strong>Invariant:</strong> Answer ‚àà [${searchState.low}, ${searchState.high}]`;
                    } else {
                        text.innerHTML = `F(${last.mid}) = ${last.Fmid.toFixed(3)} < U = ${U.toFixed(3)}<br><br>
                            Answer must be after ${last.mid}.<br>
                            <strong>Invariant:</strong> Answer ‚àà [${searchState.low}, ${searchState.high}]`;
                    }
                    break;
                case 'found':
                    const maxSteps = Math.ceil(Math.log2(K));
                    title.textContent = '‚úÖ Search Complete!';
                    text.innerHTML = `Found k = ${searchState.found} in ${searchState.step} step${searchState.step !== 1 ? 's' : ''}!<br><br>
                        F(${searchState.found-1 > 0 ? searchState.found-1 : '0'}) = ${searchState.found > 1 ? cdf[searchState.found-2].toFixed(3) : '0.000'} < 
                        U = ${U.toFixed(3)} ‚â§ 
                        F(${searchState.found}) = ${cdf[searchState.found-1].toFixed(3)}<br><br>
                        <strong>Guaranteed ‚â§ ${maxSteps} steps for K=${K}.</strong>`;
                    break;
                case 'reset':
                    title.textContent = 'üí° The Binary Search Invariant';
                    text.innerHTML = `<strong>Goal:</strong> Find the least k with F(k) ‚â• U ‚Äî equivalent to a <em>lower_bound</em> search on the CDF staircase.<br><br>
                        <strong>Invariant:</strong> The answer is always in [low, high]. Each step halves this interval.`;
                    break;
            }
        }

        // ============================================================
        // CANVAS DRAWING: PMF BAR CHART
        // ============================================================
        function drawPMF() {
            const canvas = document.getElementById('pmfCanvas');
            const ctx = canvas.getContext('2d');
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { left: 5, right: 5, top: 5, bottom: 15 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;

            ctx.clearRect(0, 0, width, height);

            const maxPMF = Math.max(...pmf);
            const barWidth = plotWidth / K - 2;

            // Draw bars
            for (let k = 1; k <= K; k++) {
                const barHeight = (pmf[k-1] / maxPMF) * plotHeight;
                const x = padding.left + ((k - 0.5) / K) * plotWidth - barWidth / 2;
                const y = height - padding.bottom - barHeight;

                // Color based on state
                let color = '#3b82f6';
                if (searchState && searchState.found === k) {
                    color = '#22c55e';
                } else if (searchHistory.some(h => h.mid === k)) {
                    color = '#ef4444';
                }

                ctx.fillStyle = color;
                ctx.fillRect(x, y, barWidth, barHeight);
            }

            // X-axis labels (just a few)
            ctx.fillStyle = '#94a3b8';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'center';
            [1, 8, 16].forEach(k => {
                const x = padding.left + ((k - 0.5) / K) * plotWidth;
                ctx.fillText(k.toString(), x, height - 2);
            });
        }

        // ============================================================
        // LINEAR SCAN COMPARISON
        // ============================================================
        function computeLinearSteps(targetK) {
            // Left-to-right: scan from k=1 until we find it
            const lrSteps = targetK;
            
            // Right-to-left: scan from k=K until we find it  
            const rlSteps = K - targetK + 1;
            
            return { lr: lrSteps, rl: rlSteps };
        }

        function updateComparison() {
            const box = document.getElementById('comparisonBox');
            
            if (!searchState || searchState.found === null) {
                box.style.display = 'none';
                return;
            }

            box.style.display = 'block';
            
            const binarySteps = searchState.step;
            const linear = computeLinearSteps(searchState.found);
            
            document.getElementById('binarySteps').textContent = `${binarySteps} steps`;
            document.getElementById('linearLRSteps').textContent = `${linear.lr} steps`;
            document.getElementById('linearRLSteps').textContent = `${linear.rl} steps`;

            // Color the values
            const binaryEl = document.getElementById('binarySteps');
            const lrEl = document.getElementById('linearLRSteps');
            const rlEl = document.getElementById('linearRLSteps');

            // Reset colors
            [binaryEl, lrEl, rlEl].forEach(el => el.style.color = '#e2e8f0');

            // Highlight winner
            const minSteps = Math.min(binarySteps, linear.lr, linear.rl);
            if (binarySteps === minSteps) binaryEl.style.color = '#4ade80';
            if (linear.lr === minSteps) lrEl.style.color = '#4ade80';
            if (linear.rl === minSteps) rlEl.style.color = '#4ade80';

            // Verdict
            const verdict = document.getElementById('comparisonVerdict');
            if (binarySteps <= Math.min(linear.lr, linear.rl)) {
                verdict.innerHTML = '‚úì Binary search wins (or ties)!';
                verdict.style.color = '#4ade80';
            } else {
                const winner = linear.lr < linear.rl ? 'L‚ÜíR' : 'R‚ÜíL';
                const saved = Math.min(linear.lr, linear.rl);
                verdict.innerHTML = `Linear (${winner}) faster by ${binarySteps - saved} steps`;
                verdict.style.color = '#fbbf24';
            }
        }

        // ============================================================
        // CANVAS DRAWING: CDF
        // ============================================================
        function drawCDF() {
            const canvas = document.getElementById('cdfCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set actual size
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { left: 50, right: 30, top: 20, bottom: 35 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;

            // Clear
            ctx.clearRect(0, 0, width, height);

            // Draw axes
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();

            // Y-axis labels
            ctx.fillStyle = '#94a3b8';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText('1.0', padding.left - 8, padding.top + 5);
            ctx.fillText('0.5', padding.left - 8, padding.top + plotHeight/2 + 3);
            ctx.fillText('0', padding.left - 8, height - padding.bottom + 3);

            // X-axis labels
            ctx.textAlign = 'center';
            for (let k = 1; k <= K; k += 3) {
                const x = padding.left + (k / K) * plotWidth;
                ctx.fillText(k.toString(), x, height - padding.bottom + 15);
            }
            ctx.fillText('16', padding.left + plotWidth, height - padding.bottom + 15);
            ctx.fillText('Category k', width/2, height - 5);

            // Draw CDF step function
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            
            let prevY = height - padding.bottom;
            for (let k = 1; k <= K; k++) {
                const x1 = padding.left + ((k-1) / K) * plotWidth;
                const x2 = padding.left + (k / K) * plotWidth;
                const y = padding.top + (1 - cdf[k-1]) * plotHeight;
                
                // Horizontal line at previous level
                ctx.moveTo(x1, prevY);
                ctx.lineTo(x2, prevY);
                
                // Vertical jump
                ctx.moveTo(x2, prevY);
                ctx.lineTo(x2, y);
                
                prevY = y;
            }
            // Final horizontal line to the right edge
            ctx.lineTo(width - padding.right, prevY);
            ctx.stroke();

            // Draw points at CDF values
            ctx.fillStyle = '#3b82f6';
            for (let k = 1; k <= K; k++) {
                const x = padding.left + (k / K) * plotWidth;
                const y = padding.top + (1 - cdf[k-1]) * plotHeight;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw U line if active
            if (U !== null) {
                const uY = padding.top + (1 - U) * plotHeight;
                
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(padding.left, uY);
                ctx.lineTo(width - padding.right, uY);
                ctx.stroke();
                ctx.setLineDash([]);

                // U label
                ctx.fillStyle = '#ef4444';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`U = ${U.toFixed(3)}`, width - padding.right - 70, uY - 5);
            }

            // Highlight visited midpoints
            searchHistory.forEach(h => {
                const x = padding.left + (h.mid / K) * plotWidth;
                const y = padding.top + (1 - h.Fmid) * plotHeight;
                
                ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, 7, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(h.mid, x, y + 3);
            });

            // Highlight found point
            if (searchState && searchState.found !== null) {
                const x = padding.left + (searchState.found / K) * plotWidth;
                const y = padding.top + (1 - cdf[searchState.found - 1]) * plotHeight;
                
                ctx.fillStyle = '#22c55e';
                ctx.beginPath();
                ctx.arc(x, y, 9, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(searchState.found, x, y + 4);
            }
        }

        // ============================================================
        // CANVAS DRAWING: TREE
        // ============================================================
        function drawTree() {
            const canvas = document.getElementById('treeCanvas');
            const ctx = canvas.getContext('2d');
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { left: 30, right: 30, top: 25, bottom: 20 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;

            ctx.clearRect(0, 0, width, height);

            // Helper to get node position
            const getPos = (k) => {
                const node = treeNodes[k];
                return {
                    x: padding.left + node.x * plotWidth,
                    y: padding.top + (node.level / 4.5) * plotHeight
                };
            };

            // Determine node states
            const visitedNodes = new Set(searchHistory.map(h => h.mid));
            const pathNodes = new Set();
            
            // Trace the path taken
            if (searchHistory.length > 0) {
                let current = 8; // Start at root
                pathNodes.add(current);
                
                searchHistory.forEach(h => {
                    pathNodes.add(h.mid);
                });
                
                if (searchState && searchState.found !== null) {
                    pathNodes.add(searchState.found);
                }
            }

            // Draw edges
            treeEdges.forEach(([parent, child]) => {
                const p1 = getPos(parent);
                const p2 = getPos(child);
                
                // Check if this edge is on the path
                const onPath = pathNodes.has(parent) && pathNodes.has(child);
                
                ctx.strokeStyle = onPath ? '#ef4444' : 'rgba(148, 163, 184, 0.4)';
                ctx.lineWidth = onPath ? 3 : 1.5;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            });

            // Draw nodes
            for (let k = 1; k <= K; k++) {
                const pos = getPos(k);
                const radius = k <= 8 ? 18 : (k <= 14 ? 15 : 13);
                
                // Determine color
                let fillColor = '#1e40af'; // Default blue
                let strokeColor = '#3b82f6';
                let textColor = 'white';
                
                if (searchState && searchState.found === k) {
                    fillColor = '#22c55e';
                    strokeColor = '#16a34a';
                } else if (visitedNodes.has(k)) {
                    fillColor = '#ef4444';
                    strokeColor = '#dc2626';
                } else if (pathNodes.has(k)) {
                    fillColor = '#f59e0b';
                    strokeColor = '#d97706';
                }

                // Draw circle
                ctx.fillStyle = fillColor;
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Draw label
                ctx.fillStyle = textColor;
                ctx.font = `bold ${radius * 0.8}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(k.toString(), pos.x, pos.y);
            }

            // Draw CDF values on edges for visited nodes
            searchHistory.forEach(h => {
                const pos = getPos(h.mid);
                ctx.fillStyle = '#fbbf24';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`F=${h.Fmid.toFixed(2)}`, pos.x, pos.y + 25);
            });

            // Legend
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            
            const legendY = height - 10;
            const items = [
                { color: '#1e40af', label: 'Unvisited' },
                { color: '#ef4444', label: 'Visited' },
                { color: '#22c55e', label: 'Found' }
            ];
            
            let legendX = 10;
            items.forEach(item => {
                ctx.fillStyle = item.color;
                ctx.beginPath();
                ctx.arc(legendX + 6, legendY, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#94a3b8';
                ctx.fillText(item.label, legendX + 16, legendY + 4);
                legendX += 80;
            });
        }

        // ============================================================
        // WINDOW RESIZE HANDLER
        // ============================================================
        window.addEventListener('resize', () => {
            drawPMF();
            drawCDF();
            drawTree();
        });

        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>
