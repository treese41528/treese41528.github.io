<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inverse CDF Sampling Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: #fff;
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1300px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            margin-bottom: 5px;
            font-size: 1.8em;
        }
        
        .subtitle {
            text-align: center;
            color: #a0aec0;
            margin-bottom: 20px;
            font-size: 0.95em;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        label {
            font-size: 0.85em;
            color: #a0aec0;
        }

        select, button, input[type="range"] {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.4);
            color: white;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        select:focus {
            outline: 2px solid #4299e1;
        }

        button {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            font-weight: 600;
            transition: transform 0.1s;
        }

        button:hover {
            transform: scale(1.02);
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        .btn-pause {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .computation-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
        }
        
        .computation-display h3 {
            font-size: 0.9em;
            color: #a0aec0;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .formula {
            font-size: 1.1em;
            color: #48bb78;
            margin-bottom: 12px;
            font-family: 'Courier New', monospace;
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 5px;
        }

        .calculation {
            font-size: 0.95em;
            color: #fbd38d;
            font-family: 'Courier New', monospace;
            line-height: 1.7;
        }
        
        .cdf-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            flex: 1;
        }
        
        .cdf-panel h3 {
            font-size: 0.9em;
            color: #a0aec0;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .cdf-panel canvas {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .charts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
        }

        .chart-title {
            text-align: center;
            margin-bottom: 8px;
            font-size: 1em;
            color: #e2e8f0;
        }

        .chart-container canvas {
            width: 100%;
            height: 280px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.3em;
            color: #48bb78;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .stat-label {
            font-size: 0.8em;
            color: #a0aec0;
            margin-top: 3px;
        }
        
        .dist-type-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            margin-left: 8px;
        }
        
        .badge-continuous {
            background: #4299e1;
        }
        
        .badge-discrete {
            background: #9f7aea;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .charts {
                grid-template-columns: 1fr;
            }
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Inverse CDF Sampling in Action</h1>
        <p class="subtitle">Watch uniform random numbers transform into any distribution</p>
        
        <div class="controls">
            <div class="control-group">
                <label>Distribution</label>
                <select id="distribution">
                    <optgroup label="Continuous">
                        <option value="exponential">Exponential (λ=1)</option>
                        <option value="normal">Normal (μ=0, σ=1)</option>
                        <option value="logistic">Logistic</option>
                        <option value="pareto">Pareto (α=3)</option>
                        <option value="cauchy">Cauchy (heavy tails!)</option>
                    </optgroup>
                    <optgroup label="Discrete">
                        <option value="bernoulli">Bernoulli (p=0.3)</option>
                        <option value="binomial">Binomial (n=10, p=0.4)</option>
                        <option value="geometric">Geometric (p=0.25)</option>
                        <option value="poisson">Poisson (λ=4)</option>
                    </optgroup>
                </select>
            </div>
            <div class="control-group">
                <label>Speed</label>
                <input type="range" id="speed" min="0.1" max="5" value="1" step="0.1">
            </div>
            <div class="control-group">
                <label>Samples</label>
                <select id="samples">
                    <option value="500">500</option>
                    <option value="1000" selected>1000</option>
                    <option value="2000">2000</option>
                </select>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="startBtn">▶ Start</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="pauseBtn" class="btn-pause">⏸ Pause</button>
            </div>
        </div>

        <div class="main-content">
            <div class="left-panel">
                <div class="computation-display">
                    <h3>Current Computation</h3>
                    <div class="formula" id="formula">Select distribution and click Start</div>
                    <div class="calculation" id="calculation">Transform steps will appear here...</div>
                </div>
                
                <div class="cdf-panel">
                    <h3>CDF with Current u <span id="distTypeBadge" class="dist-type-badge badge-continuous">Continuous</span></h3>
                    <canvas id="cdfChart"></canvas>
                </div>
            </div>

            <div class="right-panel">
                <div class="charts">
                    <div class="chart-container">
                        <h3 class="chart-title">Input: U ~ Uniform(0,1)</h3>
                        <canvas id="uniformChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <h3 class="chart-title" id="outputTitle">Output: Transformed X</h3>
                        <canvas id="outputChart"></canvas>
                    </div>
                </div>

                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="sampleCount">0</div>
                        <div class="stat-label">Samples</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="currentU">-</div>
                        <div class="stat-label">Current U</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="currentX">-</div>
                        <div class="stat-label">Current X</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="mean">-</div>
                        <div class="stat-label">Sample Mean</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        let uniformCanvas, outputCanvas, cdfCanvas;
        let uniformCtx, outputCtx, cdfCtx;
        
        // Data
        let uniformData = [];
        let transformedData = [];
        let currentIndex = 0;
        let isRunning = false;
        let isPaused = false;
        let animationFrame = null;
        let frameCounter = 0;

        // Distribution definitions
        const distributions = {
            // Continuous distributions
            exponential: {
                name: 'Exponential(λ=1)',
                formula: 'X = -ln(1 - U)',
                discrete: false,
                transform: (u) => -Math.log(1 - u),
                pdf: (x) => x >= 0 ? Math.exp(-x) : 0,
                cdf: (x) => x >= 0 ? 1 - Math.exp(-x) : 0,
                range: { min: 0, max: 6 },
                theoreticalMean: 1
            },
            normal: {
                name: 'Normal(0,1)',
                formula: 'X = Φ⁻¹(U)',
                discrete: false,
                transform: (u) => {
                    // Rational approximation for inverse normal CDF
                    const a = [0, -3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02, 1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00];
                    const b = [0, -5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02, 6.680131188771972e+01, -1.328068155288572e+01];
                    const c = [0, -7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00, -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00];
                    const d = [0, 7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00, 3.754408661907416e+00];
                    const pLow = 0.02425, pHigh = 1 - pLow;
                    let q, r;
                    if (u < pLow) {
                        q = Math.sqrt(-2 * Math.log(u));
                        return (((((c[1]*q+c[2])*q+c[3])*q+c[4])*q+c[5])*q+c[6]) / ((((d[1]*q+d[2])*q+d[3])*q+d[4])*q+1);
                    } else if (u <= pHigh) {
                        q = u - 0.5; r = q * q;
                        return (((((a[1]*r+a[2])*r+a[3])*r+a[4])*r+a[5])*r+a[6])*q / (((((b[1]*r+b[2])*r+b[3])*r+b[4])*r+b[5])*r+1);
                    } else {
                        q = Math.sqrt(-2 * Math.log(1 - u));
                        return -(((((c[1]*q+c[2])*q+c[3])*q+c[4])*q+c[5])*q+c[6]) / ((((d[1]*q+d[2])*q+d[3])*q+d[4])*q+1);
                    }
                },
                pdf: (x) => Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI),
                cdf: (x) => {
                    const t = 1 / (1 + 0.2316419 * Math.abs(x));
                    const d = 0.3989422804014327;
                    const p = d * Math.exp(-x * x / 2) * (t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274)))));
                    return x > 0 ? 1 - p : p;
                },
                range: { min: -4, max: 4 },
                theoreticalMean: 0
            },
            logistic: {
                name: 'Logistic(0,1)',
                formula: 'X = ln(U / (1-U))',
                discrete: false,
                transform: (u) => Math.log(u / (1 - u)),
                pdf: (x) => { const ex = Math.exp(-x); return ex / Math.pow(1 + ex, 2); },
                cdf: (x) => 1 / (1 + Math.exp(-x)),
                range: { min: -6, max: 6 },
                theoreticalMean: 0
            },
            pareto: {
                name: 'Pareto(α=3)',
                formula: 'X = (1-U)^(-1/3) - 1',
                discrete: false,
                transform: (u) => Math.pow(1 - u, -1/3) - 1,
                pdf: (x) => x >= 0 ? 3 / Math.pow(x + 1, 4) : 0,
                cdf: (x) => x >= 0 ? 1 - Math.pow(x + 1, -3) : 0,
                range: { min: 0, max: 4 },
                theoreticalMean: 0.5
            },
            cauchy: {
                name: 'Cauchy(0,1)',
                formula: 'X = tan(π(U - 0.5))',
                discrete: false,
                transform: (u) => Math.tan(Math.PI * (u - 0.5)),
                pdf: (x) => 1 / (Math.PI * (1 + x * x)),
                cdf: (x) => 0.5 + Math.atan(x) / Math.PI,
                range: { min: -10, max: 10 },
                theoreticalMean: 'undefined'
            },
            // Discrete distributions
            bernoulli: {
                name: 'Bernoulli(p=0.3)',
                formula: 'X = 1 if U ≤ 0.3, else 0',
                discrete: true,
                transform: (u) => u <= 0.3 ? 1 : 0,
                pmf: (k) => k === 0 ? 0.7 : (k === 1 ? 0.3 : 0),
                cdf: (x) => x < 0 ? 0 : (x < 1 ? 0.7 : 1),
                support: [0, 1],
                range: { min: -0.5, max: 1.5 },
                theoreticalMean: 0.3
            },
            binomial: {
                name: 'Binomial(n=10, p=0.4)',
                formula: 'X = min{k : F(k) ≥ U}',
                discrete: true,
                transform: (u) => {
                    let cumSum = 0;
                    for (let k = 0; k <= 10; k++) {
                        cumSum += distributions.binomial.pmf(k);
                        if (cumSum >= u) return k;
                    }
                    return 10;
                },
                pmf: (k) => {
                    if (k < 0 || k > 10 || !Number.isInteger(k)) return 0;
                    const n = 10, p = 0.4;
                    let coeff = 1;
                    for (let i = 0; i < k; i++) coeff *= (n - i) / (i + 1);
                    return coeff * Math.pow(p, k) * Math.pow(1 - p, n - k);
                },
                cdf: (x) => {
                    let sum = 0;
                    for (let k = 0; k <= Math.min(Math.floor(x), 10); k++) {
                        sum += distributions.binomial.pmf(k);
                    }
                    return sum;
                },
                support: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                range: { min: -0.5, max: 10.5 },
                theoreticalMean: 4
            },
            geometric: {
                name: 'Geometric(p=0.25)',
                formula: 'X = ⌈ln(1-U)/ln(0.75)⌉',
                discrete: true,
                transform: (u) => Math.ceil(Math.log(1 - u) / Math.log(0.75)),
                pmf: (k) => k >= 1 && Number.isInteger(k) ? 0.25 * Math.pow(0.75, k - 1) : 0,
                cdf: (x) => x < 1 ? 0 : 1 - Math.pow(0.75, Math.floor(x)),
                support: Array.from({length: 15}, (_, i) => i + 1),
                range: { min: 0.5, max: 15.5 },
                theoreticalMean: 4
            },
            poisson: {
                name: 'Poisson(λ=4)',
                formula: 'X = min{k : F(k) ≥ U}',
                discrete: true,
                transform: (u) => {
                    let cumSum = 0;
                    let k = 0;
                    while (cumSum < u && k < 30) {
                        cumSum += distributions.poisson.pmf(k);
                        if (cumSum >= u) return k;
                        k++;
                    }
                    return k;
                },
                pmf: (k) => {
                    if (k < 0 || !Number.isInteger(k)) return 0;
                    const lambda = 4;
                    let logP = -lambda + k * Math.log(lambda);
                    for (let i = 2; i <= k; i++) logP -= Math.log(i);
                    return Math.exp(logP);
                },
                cdf: (x) => {
                    let sum = 0;
                    for (let k = 0; k <= Math.floor(x); k++) {
                        sum += distributions.poisson.pmf(k);
                    }
                    return sum;
                },
                support: Array.from({length: 15}, (_, i) => i),
                range: { min: -0.5, max: 14.5 },
                theoreticalMean: 4
            }
        };

        // Canvas setup
        function setupCanvases() {
            uniformCanvas = document.getElementById('uniformChart');
            outputCanvas = document.getElementById('outputChart');
            cdfCanvas = document.getElementById('cdfChart');
            
            uniformCtx = uniformCanvas.getContext('2d');
            outputCtx = outputCanvas.getContext('2d');
            cdfCtx = cdfCanvas.getContext('2d');
            
            // Set actual canvas size
            const dpr = window.devicePixelRatio || 1;
            [uniformCanvas, outputCanvas].forEach(canvas => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                canvas.getContext('2d').scale(dpr, dpr);
            });
            
            const cdfRect = cdfCanvas.getBoundingClientRect();
            cdfCanvas.width = cdfRect.width * dpr;
            cdfCanvas.height = cdfRect.height * dpr;
            cdfCtx.scale(dpr, dpr);
        }

        // Generate samples
        function generateSamples() {
            const numSamples = parseInt(document.getElementById('samples').value);
            uniformData = Array.from({length: numSamples}, () => Math.random());
            
            const distName = document.getElementById('distribution').value;
            const dist = distributions[distName];
            transformedData = uniformData.map(u => dist.transform(u));
            currentIndex = 0;
        }

        // Draw CDF with current u highlighted
        function drawCDF(u, distName) {
            const dist = distributions[distName];
            const canvas = cdfCanvas;
            const ctx = cdfCtx;
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            const padding = 35;
            
            ctx.clearRect(0, 0, width, height);
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(padding, padding, width - 2*padding, height - 2*padding);
            
            const range = dist.range;
            const scaleX = (x) => padding + (x - range.min) / (range.max - range.min) * (width - 2*padding);
            const scaleY = (y) => height - padding - y * (height - 2*padding);
            
            // Grid
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = 0.25; i < 1; i += 0.25) {
                ctx.beginPath();
                ctx.moveTo(padding, scaleY(i));
                ctx.lineTo(width - padding, scaleY(i));
                ctx.stroke();
            }
            
            // Draw CDF
            if (dist.discrete) {
                ctx.strokeStyle = '#9f7aea';
                ctx.lineWidth = 2;
                
                const support = dist.support;
                let prevCDF = 0;
                
                ctx.beginPath();
                ctx.moveTo(scaleX(range.min), scaleY(0));
                
                support.forEach((k, i) => {
                    const cdfVal = dist.cdf(k);
                    const x = scaleX(k);
                    
                    // Horizontal line to this point
                    ctx.lineTo(x, scaleY(prevCDF));
                    
                    // Vertical jump
                    ctx.stroke();
                    
                    // Open circle
                    ctx.beginPath();
                    ctx.arc(x, scaleY(prevCDF), 3, 0, 2*Math.PI);
                    ctx.strokeStyle = '#9f7aea';
                    ctx.stroke();
                    
                    // Filled circle
                    ctx.fillStyle = '#9f7aea';
                    ctx.beginPath();
                    ctx.arc(x, scaleY(cdfVal), 3, 0, 2*Math.PI);
                    ctx.fill();
                    
                    // Continue
                    ctx.strokeStyle = '#9f7aea';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, scaleY(cdfVal));
                    
                    prevCDF = cdfVal;
                });
                
                ctx.lineTo(scaleX(range.max), scaleY(prevCDF));
                ctx.stroke();
            } else {
                ctx.strokeStyle = '#4299e1';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i <= 100; i++) {
                    const x = range.min + (i / 100) * (range.max - range.min);
                    const y = dist.cdf(x);
                    const px = scaleX(x);
                    const py = scaleY(Math.min(1, Math.max(0, y)));
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            }
            
            // Draw horizontal line at u
            const xResult = dist.transform(u);
            
            ctx.strokeStyle = '#f6e05e';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(padding, scaleY(u));
            ctx.lineTo(scaleX(xResult), scaleY(u));
            ctx.stroke();
            
            // Vertical line down
            ctx.beginPath();
            ctx.moveTo(scaleX(xResult), scaleY(u));
            ctx.lineTo(scaleX(xResult), height - padding);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Point at intersection
            ctx.fillStyle = '#f6e05e';
            ctx.beginPath();
            ctx.arc(scaleX(xResult), scaleY(u), 5, 0, 2*Math.PI);
            ctx.fill();
            
            // Labels
            ctx.fillStyle = '#f6e05e';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`u=${u.toFixed(3)}`, padding + 3, scaleY(u) - 5);
            
            ctx.textAlign = 'center';
            ctx.fillText(`x=${dist.discrete ? xResult : xResult.toFixed(2)}`, scaleX(xResult), height - padding + 12);
            
            // Axes
            ctx.strokeStyle = '#a0aec0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
        }

        // Draw histogram
        function drawHistogram(ctx, canvas, data, range, color, showTarget, targetFunc, isDiscrete) {
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            const padding = 35;
            
            ctx.clearRect(0, 0, width, height);
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(padding, padding, width - 2*padding, height - 2*padding);
            
            // Axes
            ctx.strokeStyle = '#a0aec0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            if (data.length === 0) return;
            
            if (isDiscrete) {
                // Count frequencies for each value
                const counts = {};
                data.forEach(val => {
                    const k = Math.round(val);
                    counts[k] = (counts[k] || 0) + 1;
                });
                
                const total = data.length;
                const support = Object.keys(counts).map(Number).sort((a, b) => a - b);
                const maxFreq = Math.max(...Object.values(counts)) / total;
                
                // Get theoretical max for scaling
                let maxPMF = 0;
                if (targetFunc) {
                    for (let k = Math.floor(range.min); k <= Math.ceil(range.max); k++) {
                        maxPMF = Math.max(maxPMF, targetFunc(k));
                    }
                }
                const yMax = Math.max(maxFreq * 1.1, maxPMF * 1.1);
                
                const barWidth = (width - 2*padding) / (range.max - range.min + 1) * 0.6;
                
                // Draw target PMF
                if (showTarget && targetFunc && data.length > 30) {
                    ctx.fillStyle = 'rgba(251, 211, 141, 0.3)';
                    ctx.strokeStyle = '#fbd38d';
                    ctx.lineWidth = 2;
                    
                    for (let k = Math.floor(range.min); k <= Math.ceil(range.max); k++) {
                        const pmf = targetFunc(k);
                        if (pmf > 0.001) {
                            const x = padding + (k - range.min) / (range.max - range.min) * (width - 2*padding);
                            const barHeight = (pmf / yMax) * (height - 2*padding);
                            ctx.strokeRect(x - barWidth/2 - 2, height - padding - barHeight, barWidth + 4, barHeight);
                        }
                    }
                }
                
                // Draw histogram bars
                Object.entries(counts).forEach(([k, count]) => {
                    const freq = count / total;
                    const x = padding + (parseInt(k) - range.min) / (range.max - range.min) * (width - 2*padding);
                    const barHeight = (freq / yMax) * (height - 2*padding);
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x - barWidth/2, height - padding - barHeight, barWidth, barHeight);
                });
                
            } else {
                // Continuous histogram
                const bins = 30;
                const binWidth = (range.max - range.min) / bins;
                const histogram = new Array(bins).fill(0);
                
                data.forEach(value => {
                    const binIndex = Math.floor((value - range.min) / binWidth);
                    if (binIndex >= 0 && binIndex < bins) {
                        histogram[binIndex]++;
                    }
                });
                
                const total = data.length;
                const normalizedHist = histogram.map(count => count / (total * binWidth));
                let maxValue = Math.max(...normalizedHist);
                
                // Draw PDF curve
                if (showTarget && targetFunc && data.length > 50) {
                    ctx.strokeStyle = '#fbd38d';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    
                    for (let i = 0; i <= 100; i++) {
                        const x = range.min + (i / 100) * (range.max - range.min);
                        const y = targetFunc(x);
                        maxValue = Math.max(maxValue, y);
                        
                        const pixelX = padding + (i / 100) * (width - 2 * padding);
                        const pixelY = height - padding - (y / maxValue) * (height - 2 * padding) * 0.9;
                        
                        if (i === 0) ctx.moveTo(pixelX, pixelY);
                        else ctx.lineTo(pixelX, pixelY);
                    }
                    ctx.stroke();
                }
                
                // Draw histogram bars
                const pixelBarWidth = (width - 2 * padding) / bins;
                ctx.fillStyle = color;
                
                normalizedHist.forEach((value, i) => {
                    const barHeight = (value / maxValue) * (height - 2 * padding) * 0.9;
                    const x = padding + i * pixelBarWidth;
                    const y = height - padding - barHeight;
                    ctx.fillRect(x, y, pixelBarWidth - 1, barHeight);
                });
            }
            
            // Labels
            ctx.fillStyle = '#a0aec0';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(range.min.toFixed(1), padding, height - padding + 15);
            ctx.fillText(range.max.toFixed(1), width - padding, height - padding + 15);
            
            // Current value indicator
            if (currentIndex > 0 && currentIndex <= data.length) {
                const currentValue = data[currentIndex - 1];
                const x = padding + ((currentValue - range.min) / (range.max - range.min)) * (width - 2 * padding);
                
                ctx.strokeStyle = '#48bb78';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, height - padding);
                ctx.lineTo(x, padding);
                ctx.stroke();
            }
        }

        // Show computation steps
        function showComputation(u, x, distName) {
            const calc = document.getElementById('calculation');
            const dist = distributions[distName];
            
            if (dist.discrete) {
                if (distName === 'bernoulli') {
                    calc.innerHTML = `U = ${u.toFixed(4)}<br>` +
                        `U ${u <= 0.3 ? '≤' : '>'} 0.3<br>` +
                        `X = ${x}`;
                } else if (distName === 'geometric') {
                    calc.innerHTML = `U = ${u.toFixed(4)}<br>` +
                        `X = ⌈ln(1-U)/ln(0.75)⌉<br>` +
                        `X = ⌈ln(${(1-u).toFixed(4)})/ln(0.75)⌉<br>` +
                        `X = ⌈${(Math.log(1-u)/Math.log(0.75)).toFixed(3)}⌉<br>` +
                        `X = ${x}`;
                } else {
                    // Binomial or Poisson - show search
                    let cumSum = 0;
                    let steps = [];
                    for (let k = 0; k <= x; k++) {
                        cumSum += dist.pmf(k);
                        steps.push(`F(${k})=${cumSum.toFixed(3)}`);
                    }
                    calc.innerHTML = `U = ${u.toFixed(4)}<br>` +
                        `Search: ${steps.slice(-3).join(' → ')}<br>` +
                        `F(${x}) = ${cumSum.toFixed(3)} ≥ ${u.toFixed(3)}<br>` +
                        `X = ${x}`;
                }
            } else {
                switch(distName) {
                    case 'exponential':
                        calc.innerHTML = `U = ${u.toFixed(4)}<br>` +
                            `X = -ln(1 - ${u.toFixed(4)})<br>` +
                            `X = -ln(${(1-u).toFixed(4)})<br>` +
                            `X = ${x.toFixed(4)}`;
                        break;
                    case 'normal':
                        calc.innerHTML = `U = ${u.toFixed(4)}<br>` +
                            `X = Φ⁻¹(${u.toFixed(4)})<br>` +
                            `(rational approximation)<br>` +
                            `X = ${x.toFixed(4)}`;
                        break;
                    case 'logistic':
                        calc.innerHTML = `U = ${u.toFixed(4)}<br>` +
                            `X = ln(${u.toFixed(4)}/(1-${u.toFixed(4)}))<br>` +
                            `X = ln(${(u/(1-u)).toFixed(4)})<br>` +
                            `X = ${x.toFixed(4)}`;
                        break;
                    case 'pareto':
                        calc.innerHTML = `U = ${u.toFixed(4)}<br>` +
                            `X = (1-U)^(-1/3) - 1<br>` +
                            `X = ${(1-u).toFixed(4)}^(-0.333) - 1<br>` +
                            `X = ${x.toFixed(4)}`;
                        break;
                    case 'cauchy':
                        calc.innerHTML = `U = ${u.toFixed(4)}<br>` +
                            `X = tan(π(U - 0.5))<br>` +
                            `X = tan(${(Math.PI*(u-0.5)).toFixed(4)})<br>` +
                            `X = ${x.toFixed(4)}`;
                        break;
                }
            }
        }

        // Animation loop
        let animationSpeed = 1;
        
        function animate() {
            if (!isRunning || isPaused) return;
            
            animationSpeed = parseFloat(document.getElementById('speed').value);
            frameCounter += animationSpeed;
            
            if (frameCounter >= 1) {
                frameCounter = 0;
                currentIndex = Math.min(currentIndex + 1, uniformData.length);
                
                if (currentIndex >= uniformData.length) {
                    isRunning = false;
                    return;
                }
                
                const distName = document.getElementById('distribution').value;
                const dist = distributions[distName];
                
                const visibleUniform = uniformData.slice(0, currentIndex);
                const visibleTransformed = transformedData.slice(0, currentIndex);
                
                // Draw histograms
                drawHistogram(uniformCtx, uniformCanvas, visibleUniform, {min: 0, max: 1}, 
                    'rgba(66, 153, 225, 0.7)', true, x => 1, false);
                drawHistogram(outputCtx, outputCanvas, visibleTransformed, dist.range, 
                    'rgba(237, 100, 166, 0.7)', true, dist.discrete ? dist.pmf : dist.pdf, dist.discrete);
                
                // Update CDF
                if (currentIndex > 0) {
                    const u = uniformData[currentIndex - 1];
                    const x = transformedData[currentIndex - 1];
                    drawCDF(u, distName);
                    
                    document.getElementById('sampleCount').textContent = currentIndex;
                    document.getElementById('currentU').textContent = u.toFixed(4);
                    document.getElementById('currentX').textContent = dist.discrete ? x : x.toFixed(4);
                    
                    const mean = visibleTransformed.reduce((a, b) => a + b, 0) / visibleTransformed.length;
                    document.getElementById('mean').textContent = mean.toFixed(4);
                    
                    showComputation(u, x, distName);
                }
            }
            
            animationFrame = requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            if (animationFrame) cancelAnimationFrame(animationFrame);
            
            const distName = document.getElementById('distribution').value;
            const dist = distributions[distName];
            
            document.getElementById('formula').textContent = dist.formula;
            document.getElementById('outputTitle').textContent = `Output: ${dist.name}`;
            
            // Update badge
            const badge = document.getElementById('distTypeBadge');
            badge.textContent = dist.discrete ? 'Discrete' : 'Continuous';
            badge.className = `dist-type-badge ${dist.discrete ? 'badge-discrete' : 'badge-continuous'}`;
            
            generateSamples();
            isRunning = true;
            isPaused = false;
            frameCounter = 0;
            animate();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? '▶ Resume' : '⏸ Pause';
            if (!isPaused && isRunning) animate();
        });

        // Initialize
        window.addEventListener('load', setupCanvases);
        window.addEventListener('resize', setupCanvases);
    </script>
</body>
</html>
