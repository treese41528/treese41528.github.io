<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interpolation Search for Discrete Sampling - Interactive Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #fff;
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 5px;
            font-size: 1.8em;
            color: #f472b6;
        }

        .subtitle {
            text-align: center;
            color: #94a3b8;
            margin-bottom: 15px;
            font-size: 0.95em;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            gap: 15px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }

        .panel-title {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 12px;
            color: #f472b6;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 8px;
        }

        /* Controls */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.85em;
            color: #94a3b8;
        }

        select, input[type="number"] {
            padding: 8px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 0.9em;
        }

        .dist-description {
            font-size: 0.8em;
            color: #fbbf24;
            padding: 6px 8px;
            background: rgba(251, 191, 36, 0.1);
            border-radius: 4px;
            border-left: 3px solid #f59e0b;
            margin-top: 5px;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #ec4899;
            color: white;
        }

        .btn-primary:hover {
            background: #db2777;
        }

        .btn-secondary {
            background: #8b5cf6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7c3aed;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        /* U Value Display */
        .u-display {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            margin: 10px 0;
        }

        .u-label {
            font-size: 0.85em;
            color: #94a3b8;
        }

        .u-value {
            font-size: 2em;
            font-weight: bold;
            color: #ef4444;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        /* PMF/CDF Table */
        .table-container {
            max-height: 200px;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8em;
        }

        th, td {
            padding: 6px 8px;
            text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        th {
            background: rgba(0,0,0,0.3);
            color: #f472b6;
            position: sticky;
            top: 0;
        }

        tr.visited {
            background: rgba(244, 114, 182, 0.3);
        }

        tr.found {
            background: rgba(34, 197, 94, 0.4);
        }

        tr.in-range {
            background: rgba(251, 191, 36, 0.2);
        }

        /* Center Panel - Visualizations */
        .viz-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        canvas {
            width: 100%;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        #cdfCanvas {
            height: 280px;
        }

        #guessCanvas {
            height: 180px;
        }

        /* Right Panel - Search Trace */
        .trace-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .step-card {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            border-left: 4px solid #6b7280;
            transition: all 0.3s;
        }

        .step-card.active {
            border-left-color: #f59e0b;
            background: rgba(245, 158, 11, 0.2);
        }

        .step-card.completed {
            border-left-color: #ec4899;
        }

        .step-number {
            font-size: 0.75em;
            color: #94a3b8;
            margin-bottom: 4px;
        }

        .step-formula {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.85em;
            margin-bottom: 4px;
            color: #fbbf24;
        }

        .step-comparison {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9em;
            margin-bottom: 4px;
        }

        .step-result {
            font-weight: bold;
            font-size: 0.9em;
        }

        .step-result.go-left {
            color: #60a5fa;
        }

        .step-result.go-right {
            color: #f97316;
        }

        .step-result.found {
            color: #22c55e;
        }

        /* Algorithm Display */
        .algorithm-box {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.75em;
            line-height: 1.5;
        }

        .algo-highlight {
            background: rgba(244, 114, 182, 0.4);
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Explanation Box */
        .explanation {
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.2), rgba(139, 92, 246, 0.2));
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            border: 1px solid rgba(236, 72, 153, 0.3);
        }

        .explanation-title {
            font-weight: bold;
            color: #f472b6;
            margin-bottom: 8px;
        }

        .explanation-text {
            font-size: 0.9em;
            line-height: 1.5;
            color: #e2e8f0;
        }

        /* Key insight box */
        .insight-box {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(16, 185, 129, 0.15));
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
        }

        .insight-title {
            font-weight: bold;
            color: #4ade80;
            font-size: 0.9em;
            margin-bottom: 6px;
        }

        .insight-text {
            font-size: 0.85em;
            color: #a7f3d0;
        }

        /* Warning box */
        .warning-box {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.15));
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
        }

        .warning-title {
            font-weight: bold;
            color: #f87171;
            font-size: 0.9em;
            margin-bottom: 6px;
        }

        .warning-text {
            font-size: 0.85em;
            color: #fecaca;
        }

        /* Comparison box */
        .comparison-box {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .comparison-title {
            font-weight: bold;
            color: #a78bfa;
            font-size: 0.85em;
            margin-bottom: 8px;
        }

        .comparison-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            padding: 3px 0;
            color: #e2e8f0;
        }

        .comparison-value {
            font-weight: bold;
            font-family: monospace;
        }

        .comparison-verdict {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.8em;
            text-align: center;
        }

        /* Stats bar */
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-item {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #f472b6;
        }

        .stat-label {
            font-size: 0.75em;
            color: #94a3b8;
        }

        /* Legend items */
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìê Interpolation Search for Discrete Sampling</h1>
        <p class="subtitle">Exploiting CDF structure ‚Äî O(log log K) for uniform distributions, but beware of skewed ones!</p>

        <div class="main-grid">
            <!-- Left Panel: Controls & Table -->
            <div class="panel">
                <div class="panel-title">‚öôÔ∏è Controls</div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Distribution Shape (K=16)</label>
                        <select id="distribution">
                            <optgroup label="Interpolation Excels">
                                <option value="uniform" selected>Uniform (Best Case)</option>
                                <option value="nearuniform">Near-Uniform (Slight Noise)</option>
                            </optgroup>
                            <optgroup label="Moderate Performance">
                                <option value="unimodal">Unimodal (Bell-shaped)</option>
                                <option value="linear">Linear Increasing</option>
                            </optgroup>
                            <optgroup label="Interpolation Struggles">
                                <option value="geometric">Geometric (Head-heavy)</option>
                                <option value="zipf">Zipf's Law (Power)</option>
                                <option value="adversarial">Adversarial (99% at k=16)</option>
                            </optgroup>
                            <optgroup label="Pathological">
                                <option value="pointmass">Point Mass at k=8</option>
                                <option value="bimodal">Bimodal</option>
                            </optgroup>
                        </select>
                        <div class="dist-description" id="distDescription">
                            CDF is perfectly linear ‚Äî interpolation finds answer in 1-2 steps!
                        </div>
                    </div>

                    <div class="u-display">
                        <div class="u-label">Random Uniform Value</div>
                        <div class="u-value" id="uValue" role="status" aria-live="polite">‚Äî</div>
                    </div>

                    <div class="btn-group">
                        <button class="btn-primary" id="newSearchBtn">üé≤ New Search</button>
                        <button class="btn-secondary" id="stepBtn" disabled>Step ‚Üí</button>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn-warning" id="autoBtn" disabled>‚ñ∂ Auto Play</button>
                        <button class="btn-secondary" id="resetBtn">‚Ü∫ Reset</button>
                    </div>
                </div>

                <div class="panel-title" style="margin-top: 15px;">üìä PMF Shape</div>
                <canvas id="pmfCanvas" style="height: 80px; width: 100%;"></canvas>

                <div class="panel-title" style="margin-top: 10px;">üìã CDF Table <span style="font-size: 0.7em; color: #94a3b8;">(rounded)</span></div>
                <div class="table-container">
                    <table id="dataTable">
                        <thead>
                            <tr>
                                <th>k</th>
                                <th>p(k)</th>
                                <th>F(k)</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody">
                        </tbody>
                    </table>
                </div>

                <!-- Method comparison -->
                <div class="comparison-box" id="comparisonBox" style="display: none;">
                    <div class="comparison-title">‚öñÔ∏è Method Comparison</div>
                    <div class="comparison-row">
                        <span>Interpolation:</span>
                        <span class="comparison-value" id="interpSteps">‚Äî</span>
                    </div>
                    <div class="comparison-row">
                        <span>Binary Search:</span>
                        <span class="comparison-value" id="binarySteps">‚Äî</span>
                    </div>
                    <div class="comparison-row">
                        <span>Linear Scan:</span>
                        <span class="comparison-value" id="linearSteps">‚Äî</span>
                    </div>
                    <div class="comparison-verdict" id="comparisonVerdict"></div>
                </div>
            </div>

            <!-- Center Panel: Visualizations -->
            <div class="panel">
                <div class="panel-title">üìà CDF with Interpolation Guess</div>
                <canvas id="cdfCanvas"></canvas>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f472b6;"></div>
                        <span>Interpolation guess</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #60a5fa;"></div>
                        <span>Binary search (midpoint)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #22c55e;"></div>
                        <span>Found</span>
                    </div>
                </div>

                <div class="stats-bar" role="region" aria-label="Search statistics">
                    <div class="stat-item">
                        <div class="stat-value" id="statK">16</div>
                        <div class="stat-label">Categories (K)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statSteps" role="status" aria-live="polite">0</div>
                        <div class="stat-label">Steps Taken</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statBinaryMax">4</div>
                        <div class="stat-label">Binary Max</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statResult" role="status" aria-live="polite">‚Äî</div>
                        <div class="stat-label">Result (k)</div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Search Trace & Explanation -->
            <div class="panel">
                <div class="panel-title">üîé Search Trace</div>
                
                <div class="algorithm-box" id="algorithmBox">
                    <div style="color: #94a3b8; margin-bottom: 4px;">// Interpolation formula:</div>
                    <div>guess = low + ‚åä<span style="color: #fbbf24;">(U - F[low-1]) / (F[high] - F[low-1])</span> √ó (high - low)‚åã</div>
                    <div style="margin-top: 8px;">low = <span id="algoLow">1</span>, high = <span id="algoHigh">16</span></div>
                    <div id="algoLine" class="algo-highlight" style="display:none; margin-top: 4px;">
                        guess = <span id="algoGuess">?</span> <span style="color: #94a3b8;">(binary would pick <span id="algoBinaryMid">?</span>)</span>
                    </div>
                </div>

                <div class="trace-container" id="traceContainer" role="log" aria-live="polite" aria-label="Search trace steps">
                    <div style="text-align: center; color: #94a3b8; padding: 20px;">
                        Click "New Search" to begin
                    </div>
                </div>

                <div class="explanation" id="explanationBox">
                    <div class="explanation-title">üí° The Interpolation Idea</div>
                    <div class="explanation-text">
                        Instead of always checking the middle (binary search), interpolation search <em>estimates</em> where U should be based on linear interpolation of CDF values. If the CDF is nearly linear, this guess is very accurate!
                    </div>
                </div>

                <div class="insight-box" id="insightBox">
                    <div class="insight-title">üéØ Best Case: O(log log K)</div>
                    <div class="insight-text">
                        For uniform distributions, the CDF is perfectly linear. Each guess lands very close to the answer, giving O(log log K) comparisons. For K=16, that's ~2 steps!
                    </div>
                </div>

                <div class="warning-box" id="warningBox" style="display: none;">
                    <div class="warning-title">‚ö†Ô∏è Worst Case: O(K)</div>
                    <div class="warning-text">
                        For highly skewed distributions, the linear assumption fails badly. Guesses can overshoot or undershoot dramatically, potentially degrading to linear scan performance.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // DISTRIBUTION DEFINITIONS
        // ============================================================
        const K = 16;
        
        const distributions = {
            uniform: {
                name: "Uniform",
                description: "CDF is perfectly linear ‚Äî interpolation finds answer in 1-2 steps!",
                category: "best",
                pmf: () => Array(16).fill(1/16)
            },
            nearuniform: {
                name: "Near-Uniform",
                description: "Small random perturbations ‚Äî interpolation still very effective",
                category: "best",
                pmf: () => {
                    const raw = Array.from({length: 16}, () => 1 + 0.3 * (Math.random() - 0.5));
                    const sum = raw.reduce((a, b) => a + b, 0);
                    return raw.map(x => x / sum);
                }
            },
            unimodal: {
                name: "Unimodal (Bell-shaped)",
                description: "CDF is S-shaped ‚Äî interpolation reasonably effective",
                category: "moderate",
                pmf: () => {
                    const raw = [0.002, 0.004, 0.008, 0.016, 0.031, 0.063, 0.125, 0.251, 
                                 0.251, 0.125, 0.063, 0.031, 0.016, 0.008, 0.004, 0.002];
                    return raw;
                }
            },
            linear: {
                name: "Linear Increasing",
                description: "PMF increases linearly ‚Äî CDF is quadratic, moderate curvature",
                category: "moderate",
                pmf: () => {
                    const raw = Array.from({length: 16}, (_, i) => i + 1);
                    const sum = raw.reduce((a, b) => a + b, 0);
                    return raw.map(x => x / sum);
                }
            },
            geometric: {
                name: "Geometric (Head-heavy)",
                description: "CDF jumps quickly then flattens ‚Äî interpolation overshoots badly!",
                category: "poor",
                pmf: () => {
                    const raw = Array.from({length: 16}, (_, i) => Math.pow(0.6, i));
                    const sum = raw.reduce((a, b) => a + b, 0);
                    return raw.map(x => x / sum);
                }
            },
            zipf: {
                name: "Zipf's Law",
                description: "Power law ‚Äî CDF has strong curvature, interpolation struggles",
                category: "poor",
                pmf: () => {
                    const raw = Array.from({length: 16}, (_, i) => 1 / (i + 1));
                    const sum = raw.reduce((a, b) => a + b, 0);
                    return raw.map(x => x / sum);
                }
            },
            adversarial: {
                name: "Adversarial",
                description: "99% at k=16 ‚Äî CDF nearly flat then jumps, worst case for interpolation!",
                category: "worst",
                pmf: () => {
                    const raw = Array(16).fill(0.001);
                    raw[15] = 0.99;
                    const sum = raw.reduce((a, b) => a + b, 0);
                    return raw.map(x => x / sum);
                }
            },
            pointmass: {
                name: "Point Mass at k=8",
                description: "90% at middle ‚Äî CDF has huge jump, interpolation very confused",
                category: "worst",
                pmf: () => {
                    const raw = Array(16).fill(0.01);
                    raw[7] = 0.90;
                    const sum = raw.reduce((a, b) => a + b, 0);
                    return raw.map(x => x / sum);
                }
            },
            bimodal: {
                name: "Bimodal",
                description: "Two peaks ‚Äî CDF has two steep regions, unpredictable for interpolation",
                category: "worst",
                pmf: () => {
                    const raw = Array.from({length: 16}, (_, i) => {
                        const peak1 = Math.exp(-Math.pow(i - 3, 2) / 3);
                        const peak2 = Math.exp(-Math.pow(i - 12, 2) / 3);
                        return peak1 + peak2;
                    });
                    const sum = raw.reduce((a, b) => a + b, 0);
                    return raw.map(x => x / sum);
                }
            }
        };

        // ============================================================
        // STATE MANAGEMENT
        // ============================================================
        let currentDist = 'uniform';
        let pmf = [];
        let cdf = [];
        let U = null;
        let searchState = null;
        let searchHistory = [];
        let isAutoPlaying = false;
        let autoPlayInterval = null;

        // ============================================================
        // INITIALIZATION
        // ============================================================
        function init() {
            loadDistribution(currentDist);
            setupEventListeners();
            drawPMF();
            drawCDF();
        }

        function loadDistribution(distKey) {
            currentDist = distKey;
            
            // Get raw PMF and normalize defensively
            const rawPmf = distributions[distKey].pmf();
            const sum = rawPmf.reduce((a, b) => a + b, 0);
            pmf = rawPmf.map(x => x / sum);
            
            // Compute CDF with defensive capping
            // Prepend 0 for F[0] convention (1-indexed)
            cdf = [0];
            let cumsum = 0;
            for (let i = 0; i < pmf.length; i++) {
                cumsum += pmf[i];
                cdf.push(Math.min(cumsum, 1.0));
            }
            cdf[cdf.length - 1] = 1.0;
            
            // Update description
            document.getElementById('distDescription').textContent = distributions[distKey].description;
            
            // Update insight/warning boxes based on category
            const category = distributions[distKey].category;
            const insightBox = document.getElementById('insightBox');
            const warningBox = document.getElementById('warningBox');
            
            if (category === 'best') {
                insightBox.style.display = 'block';
                warningBox.style.display = 'none';
            } else if (category === 'worst' || category === 'poor') {
                insightBox.style.display = 'none';
                warningBox.style.display = 'block';
            } else {
                insightBox.style.display = 'block';
                warningBox.style.display = 'none';
            }
            
            // Update max steps dynamically
            const maxSteps = Math.ceil(Math.log2(K));
            document.getElementById('statBinaryMax').textContent = maxSteps;
            
            updateTable();
            drawPMF();
            drawCDF();
        }

        function setupEventListeners() {
            document.getElementById('distribution').addEventListener('change', (e) => {
                loadDistribution(e.target.value);
                resetSearch();
            });

            document.getElementById('newSearchBtn').addEventListener('click', startNewSearch);
            document.getElementById('stepBtn').addEventListener('click', doStep);
            document.getElementById('autoBtn').addEventListener('click', toggleAutoPlay);
            document.getElementById('resetBtn').addEventListener('click', resetSearch);
        }

        // ============================================================
        // TABLE MANAGEMENT
        // ============================================================
        function updateTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            for (let k = 1; k <= K; k++) {
                const tr = document.createElement('tr');
                tr.id = `row-${k}`;
                tr.innerHTML = `
                    <td>${k}</td>
                    <td>${pmf[k-1].toFixed(3)}</td>
                    <td>${cdf[k].toFixed(3)}</td>
                `;
                tbody.appendChild(tr);
            }
        }

        function highlightTableRows() {
            for (let k = 1; k <= K; k++) {
                const row = document.getElementById(`row-${k}`);
                row.className = '';
            }

            if (!searchState) return;

            for (let k = searchState.low; k <= searchState.high; k++) {
                document.getElementById(`row-${k}`).classList.add('in-range');
            }

            searchHistory.forEach(h => {
                document.getElementById(`row-${h.guess}`).classList.add('visited');
            });

            if (searchState.found !== null) {
                document.getElementById(`row-${searchState.found}`).classList.add('found');
            }
        }

        // ============================================================
        // INTERPOLATION SEARCH LOGIC
        // ============================================================
        function computeInterpolationGuess(low, high, u) {
            // F[low-1] to F[high] defines the probability range
            const F_low = cdf[low - 1];  // F[low-1]
            const F_high = cdf[high];     // F[high]
            
            // Avoid division by zero
            if (F_high <= F_low) return low;
            
            // Linear interpolation
            const ratio = (u - F_low) / (F_high - F_low);
            let guess = low + Math.floor(ratio * (high - low));
            
            // Clamp to valid range
            guess = Math.max(low, Math.min(guess, high));
            
            return guess;
        }

        function computeBinaryMid(low, high) {
            return Math.floor((low + high) / 2);
        }

        function startNewSearch() {
            U = Math.random();
            document.getElementById('uValue').textContent = U.toFixed(6);
            
            searchState = {
                low: 1,
                high: K,
                guess: null,
                found: null,
                step: 0
            };
            searchHistory = [];

            document.getElementById('stepBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
            document.getElementById('comparisonBox').style.display = 'none';

            updateAlgorithmBox();
            updateTraceContainer();
            highlightTableRows();
            drawPMF();
            drawCDF();
            
            document.getElementById('statSteps').textContent = '0';
            document.getElementById('statResult').textContent = '‚Äî';

            updateExplanation('start');
        }

        function doStep() {
            if (!searchState || searchState.found !== null) return;
            if (searchState.low >= searchState.high) {
                searchState.found = searchState.low;
                finishSearch();
                return;
            }

            // Compute interpolation guess
            const guess = computeInterpolationGuess(searchState.low, searchState.high, U);
            const binaryMid = computeBinaryMid(searchState.low, searchState.high);
            searchState.guess = guess;
            searchState.step++;

            // Compare U with F[guess]
            const F_guess = cdf[guess];
            let direction, newLow, newHigh;

            if (U <= F_guess) {
                direction = 'left';
                newLow = searchState.low;
                newHigh = guess;
            } else {
                direction = 'right';
                newLow = guess + 1;
                newHigh = searchState.high;
            }

            // Record history
            const F_low = cdf[searchState.low - 1];
            const F_high = cdf[searchState.high];
            searchHistory.push({
                step: searchState.step,
                low: searchState.low,
                high: searchState.high,
                guess: guess,
                binaryMid: binaryMid,
                F_guess: F_guess,
                F_low: F_low,
                F_high: F_high,
                ratio: (U - F_low) / (F_high - F_low),
                comparison: U <= F_guess ? '‚â§' : '>',
                direction: direction
            });

            // Update state
            searchState.low = newLow;
            searchState.high = newHigh;

            if (searchState.low >= searchState.high) {
                searchState.found = searchState.low;
                finishSearch();
            }

            updateAlgorithmBox();
            updateTraceContainer();
            highlightTableRows();
            drawPMF();
            drawCDF();
            
            document.getElementById('statSteps').textContent = searchState.step;
            updateExplanation('step');
        }

        function finishSearch() {
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('autoBtn').disabled = true;
            stopAutoPlay();
            
            document.getElementById('statResult').textContent = searchState.found;
            updateExplanation('found');
            updateTraceContainer();
            highlightTableRows();
            drawPMF();
            drawCDF();
            updateComparison();
        }

        function resetSearch() {
            stopAutoPlay();
            U = null;
            searchState = null;
            searchHistory = [];
            
            document.getElementById('uValue').textContent = '‚Äî';
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('autoBtn').disabled = true;
            document.getElementById('statSteps').textContent = '0';
            document.getElementById('statResult').textContent = '‚Äî';
            
            document.getElementById('algoLow').textContent = '1';
            document.getElementById('algoHigh').textContent = '16';
            document.getElementById('algoLine').style.display = 'none';
            document.getElementById('comparisonBox').style.display = 'none';
            
            updateTraceContainer();
            highlightTableRows();
            drawPMF();
            drawCDF();
            updateExplanation('reset');
        }

        function toggleAutoPlay() {
            if (isAutoPlaying) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }

        function startAutoPlay() {
            isAutoPlaying = true;
            document.getElementById('autoBtn').textContent = '‚è∏ Pause';
            autoPlayInterval = setInterval(() => {
                if (searchState && searchState.found === null) {
                    doStep();
                } else {
                    stopAutoPlay();
                }
            }, 1500);
        }

        function stopAutoPlay() {
            isAutoPlaying = false;
            document.getElementById('autoBtn').textContent = '‚ñ∂ Auto Play';
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
        }

        // ============================================================
        // COMPARISON CALCULATIONS
        // ============================================================
        function computeBinarySearchSteps(targetK) {
            let lo = 1, hi = K, steps = 0;
            while (lo < hi) {
                steps++;
                const mid = Math.floor((lo + hi) / 2);
                if (U <= cdf[mid]) {
                    hi = mid;
                } else {
                    lo = mid + 1;
                }
            }
            return steps;
        }

        function updateComparison() {
            const box = document.getElementById('comparisonBox');
            
            if (!searchState || searchState.found === null) {
                box.style.display = 'none';
                return;
            }

            box.style.display = 'block';
            
            const interpSteps = searchState.step;
            const binarySteps = computeBinarySearchSteps(searchState.found);
            const linearSteps = searchState.found;
            
            document.getElementById('interpSteps').textContent = `${interpSteps} steps`;
            document.getElementById('binarySteps').textContent = `${binarySteps} steps`;
            document.getElementById('linearSteps').textContent = `${linearSteps} steps`;

            // Color the values
            const interpEl = document.getElementById('interpSteps');
            const binaryEl = document.getElementById('binarySteps');
            const linearEl = document.getElementById('linearSteps');

            [interpEl, binaryEl, linearEl].forEach(el => el.style.color = '#e2e8f0');

            const minSteps = Math.min(interpSteps, binarySteps, linearSteps);
            if (interpSteps === minSteps) interpEl.style.color = '#4ade80';
            if (binarySteps === minSteps) binaryEl.style.color = '#4ade80';
            if (linearSteps === minSteps) linearEl.style.color = '#4ade80';

            const verdict = document.getElementById('comparisonVerdict');
            if (interpSteps < binarySteps) {
                verdict.innerHTML = `‚úì Interpolation wins by ${binarySteps - interpSteps} step${binarySteps - interpSteps > 1 ? 's' : ''}!`;
                verdict.style.color = '#4ade80';
            } else if (interpSteps > binarySteps) {
                verdict.innerHTML = `‚úó Binary search faster by ${interpSteps - binarySteps} step${interpSteps - binarySteps > 1 ? 's' : ''}`;
                verdict.style.color = '#f87171';
            } else {
                verdict.innerHTML = `= Tied with binary search`;
                verdict.style.color = '#fbbf24';
            }
        }

        // ============================================================
        // UI UPDATES
        // ============================================================
        function updateAlgorithmBox() {
            document.getElementById('algoLow').textContent = searchState.low;
            document.getElementById('algoHigh').textContent = searchState.high;
            
            if (searchState.guess !== null && searchState.found === null) {
                document.getElementById('algoLine').style.display = 'block';
                document.getElementById('algoGuess').textContent = searchState.guess;
                document.getElementById('algoBinaryMid').textContent = computeBinaryMid(searchState.low, searchState.high);
            } else if (searchHistory.length > 0) {
                const last = searchHistory[searchHistory.length - 1];
                document.getElementById('algoLine').style.display = 'block';
                document.getElementById('algoGuess').textContent = last.guess;
                document.getElementById('algoBinaryMid').textContent = last.binaryMid;
            } else {
                document.getElementById('algoLine').style.display = 'none';
            }
        }

        function updateTraceContainer() {
            const container = document.getElementById('traceContainer');
            
            if (searchHistory.length === 0 && !searchState) {
                container.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">Click "New Search" to begin</div>';
                return;
            }

            if (searchHistory.length === 0 && searchState) {
                container.innerHTML = '<div style="text-align: center; color: #fbbf24; padding: 20px;">Ready! Click "Step" or "Auto Play"</div>';
                return;
            }

            let html = '';
            searchHistory.forEach((h, idx) => {
                const isLast = idx === searchHistory.length - 1 && searchState.found === null;
                const dirClass = h.direction === 'left' ? 'go-left' : 'go-right';
                const guessDiff = h.guess - h.binaryMid;
                const guessComment = guessDiff === 0 ? '(= binary)' : 
                                     guessDiff > 0 ? `(+${guessDiff} vs binary)` : 
                                     `(${guessDiff} vs binary)`;
                
                html += `
                    <div class="step-card ${isLast ? 'active' : 'completed'}">
                        <div class="step-number">Step ${h.step}</div>
                        <div class="step-formula">
                            ratio = (${U.toFixed(3)} - ${h.F_low.toFixed(3)}) / (${h.F_high.toFixed(3)} - ${h.F_low.toFixed(3)}) = ${h.ratio.toFixed(2)}
                        </div>
                        <div class="step-comparison">
                            guess = ${h.guess} ${guessComment}, F(${h.guess}) = ${h.F_guess.toFixed(3)}<br>
                            U = ${U.toFixed(3)} ${h.comparison} ${h.F_guess.toFixed(3)}
                        </div>
                        <div class="step-result ${dirClass}">
                            ‚Üí Go ${h.direction.toUpperCase()}
                        </div>
                    </div>
                `;
            });

            if (searchState.found !== null) {
                html += `
                    <div class="step-card" style="border-left-color: #22c55e; background: rgba(34, 197, 94, 0.2);">
                        <div class="step-number">‚úì Complete</div>
                        <div class="step-comparison">low = high = ${searchState.found}</div>
                        <div class="step-result found">FOUND: k = ${searchState.found}</div>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        function updateExplanation(phase) {
            const box = document.getElementById('explanationBox');
            const title = box.querySelector('.explanation-title');
            const text = box.querySelector('.explanation-text');

            switch(phase) {
                case 'start':
                    title.textContent = 'üéØ Search Initialized';
                    text.innerHTML = `<strong>Goal:</strong> Find the least k with F(k) ‚â• U = ${U.toFixed(4)}.<br><br>
                        Interpolation will estimate where U falls based on linear interpolation of the CDF.`;
                    break;
                case 'step':
                    const last = searchHistory[searchHistory.length - 1];
                    const guessDiff = last.guess - last.binaryMid;
                    title.textContent = `üîç Step ${last.step}: Guessed k = ${last.guess}`;
                    
                    let analysis = '';
                    if (Math.abs(guessDiff) <= 1) {
                        analysis = 'Guess close to binary midpoint ‚Äî CDF is fairly linear here.';
                    } else if (guessDiff > 1) {
                        analysis = `Guess ${guessDiff} positions higher than binary ‚Äî interpolation thinks target is in upper portion.`;
                    } else {
                        analysis = `Guess ${Math.abs(guessDiff)} positions lower than binary ‚Äî interpolation thinks target is in lower portion.`;
                    }
                    
                    text.innerHTML = `Ratio = ${last.ratio.toFixed(2)} ‚Üí guess = ${last.guess}<br>
                        (Binary would pick ${last.binaryMid})<br><br>${analysis}`;
                    break;
                case 'found':
                    const binarySteps = computeBinarySearchSteps(searchState.found);
                    title.textContent = '‚úÖ Search Complete!';
                    
                    let verdict = '';
                    if (searchState.step < binarySteps) {
                        verdict = `<span style="color: #4ade80;">Interpolation won!</span> ${searchState.step} vs ${binarySteps} steps.`;
                    } else if (searchState.step > binarySteps) {
                        verdict = `<span style="color: #f87171;">Binary search would have been faster.</span> ${binarySteps} vs ${searchState.step} steps.`;
                    } else {
                        verdict = `Tied with binary search at ${searchState.step} steps.`;
                    }
                    
                    text.innerHTML = `Found k = ${searchState.found} in ${searchState.step} step${searchState.step !== 1 ? 's' : ''}.<br><br>${verdict}`;
                    break;
                case 'reset':
                    title.textContent = 'üí° The Interpolation Idea';
                    text.innerHTML = `Instead of always checking the middle (binary search), interpolation search <em>estimates</em> where U should be based on linear interpolation of CDF values. If the CDF is nearly linear, this guess is very accurate!`;
                    break;
            }
        }

        // ============================================================
        // CANVAS DRAWING: PMF
        // ============================================================
        function drawPMF() {
            const canvas = document.getElementById('pmfCanvas');
            const ctx = canvas.getContext('2d');
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { left: 5, right: 5, top: 5, bottom: 15 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;

            ctx.clearRect(0, 0, width, height);

            const maxPMF = Math.max(...pmf);
            const barWidth = plotWidth / K - 2;

            for (let k = 1; k <= K; k++) {
                const barHeight = (pmf[k-1] / maxPMF) * plotHeight;
                const x = padding.left + ((k - 0.5) / K) * plotWidth - barWidth / 2;
                const y = height - padding.bottom - barHeight;

                let color = '#8b5cf6';
                if (searchState && searchState.found === k) {
                    color = '#22c55e';
                } else if (searchHistory.some(h => h.guess === k)) {
                    color = '#f472b6';
                }

                ctx.fillStyle = color;
                ctx.fillRect(x, y, barWidth, barHeight);
            }

            ctx.fillStyle = '#94a3b8';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'center';
            [1, 8, 16].forEach(k => {
                const x = padding.left + ((k - 0.5) / K) * plotWidth;
                ctx.fillText(k.toString(), x, height - 2);
            });
        }

        // ============================================================
        // CANVAS DRAWING: CDF with interpolation visualization
        // ============================================================
        function drawCDF() {
            const canvas = document.getElementById('cdfCanvas');
            const ctx = canvas.getContext('2d');
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { left: 50, right: 30, top: 20, bottom: 40 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;

            ctx.clearRect(0, 0, width, height);

            // Draw axes
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();

            // Y-axis labels
            ctx.fillStyle = '#94a3b8';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText('1.0', padding.left - 8, padding.top + 5);
            ctx.fillText('0.5', padding.left - 8, padding.top + plotHeight/2 + 3);
            ctx.fillText('0', padding.left - 8, height - padding.bottom + 3);

            // X-axis labels
            ctx.textAlign = 'center';
            for (let k = 0; k <= K; k += 4) {
                const x = padding.left + (k / K) * plotWidth;
                ctx.fillText(k.toString(), x, height - padding.bottom + 15);
            }
            ctx.fillText('Category k', width/2, height - 5);

            // Helper function to convert k to x coordinate
            const kToX = (k) => padding.left + (k / K) * plotWidth;
            const fToY = (f) => padding.top + (1 - f) * plotHeight;

            // Draw search range shading if active
            if (searchState && searchState.found === null && searchHistory.length > 0) {
                const lo = searchState.low;
                const hi = searchState.high;
                ctx.fillStyle = 'rgba(251, 191, 36, 0.15)';
                ctx.fillRect(kToX(lo - 1), padding.top, kToX(hi) - kToX(lo - 1), plotHeight);
            }

            // Draw CDF step function
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            
            let prevY = height - padding.bottom;
            for (let k = 1; k <= K; k++) {
                const x1 = kToX(k - 1);
                const x2 = kToX(k);
                const y = fToY(cdf[k]);
                
                ctx.moveTo(x1, prevY);
                ctx.lineTo(x2, prevY);
                ctx.moveTo(x2, prevY);
                ctx.lineTo(x2, y);
                
                prevY = y;
            }
            ctx.lineTo(width - padding.right, prevY);
            ctx.stroke();

            // Draw points at CDF values
            ctx.fillStyle = '#8b5cf6';
            for (let k = 1; k <= K; k++) {
                const x = kToX(k);
                const y = fToY(cdf[k]);
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw U line if active
            if (U !== null) {
                const uY = fToY(U);
                
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(padding.left, uY);
                ctx.lineTo(width - padding.right, uY);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#ef4444';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`U = ${U.toFixed(3)}`, width - padding.right - 80, uY - 8);
            }

            // Draw interpolation line for current step
            if (searchState && searchHistory.length > 0 && searchState.found === null) {
                const last = searchHistory[searchHistory.length - 1];
                const lo = last.low;
                const hi = last.high;
                
                // Draw the interpolation line (from F[lo-1] to F[hi])
                ctx.strokeStyle = 'rgba(244, 114, 182, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(kToX(lo - 1), fToY(cdf[lo - 1]));
                ctx.lineTo(kToX(hi), fToY(cdf[hi]));
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Highlight visited guesses
            searchHistory.forEach((h, idx) => {
                const x = kToX(h.guess);
                const y = fToY(h.F_guess);
                
                // Interpolation guess (pink)
                ctx.fillStyle = 'rgba(244, 114, 182, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(h.guess, x, y + 3);
                
                // Binary midpoint indicator (blue, smaller)
                if (h.guess !== h.binaryMid) {
                    const bx = kToX(h.binaryMid);
                    const by = fToY(cdf[h.binaryMid]);
                    
                    ctx.strokeStyle = '#60a5fa';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(bx, by, 6, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Highlight found point
            if (searchState && searchState.found !== null) {
                const x = kToX(searchState.found);
                const y = fToY(cdf[searchState.found]);
                
                ctx.fillStyle = '#22c55e';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(searchState.found, x, y + 4);
            }
        }

        // ============================================================
        // WINDOW RESIZE HANDLER
        // ============================================================
        window.addEventListener('resize', () => {
            drawPMF();
            drawCDF();
        });

        window.addEventListener('load', init);
    </script>
</body>
</html>
