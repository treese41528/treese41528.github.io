<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generalized Inverse CDF Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f4f8;
        }
        
        .container {
            background-color: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #1a365d;
            text-align: center;
            margin-bottom: 8px;
            font-size: 1.8em;
        }
        
        .subtitle {
            text-align: center;
            color: #4a5568;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            background: #edf2f7;
            padding: 8px;
            border-radius: 6px;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-weight: 600;
            color: #2d3748;
            font-size: 13px;
        }
        
        select, input[type="range"] {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }
        
        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: #4299e1;
        }
        
        input[type="range"] {
            width: 220px;
            cursor: pointer;
        }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        canvas {
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            width: 100%;
            cursor: crosshair;
            background: white;
        }
        
        .canvas-container {
            text-align: center;
        }
        
        .canvas-title {
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        
        .canvas-subtitle {
            font-size: 0.85em;
            color: #718096;
            margin-bottom: 8px;
        }
        
        .value-display {
            font-size: 1.2em;
            color: #1a365d;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .value-display span {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .key-insight {
            background: linear-gradient(135deg, #f6e05e 0%, #ecc94b 100%);
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 20px;
        }
        
        .key-insight h3 {
            color: #744210;
            margin-bottom: 8px;
            font-size: 1em;
        }
        
        .key-insight p {
            color: #975a16;
            font-size: 0.95em;
            line-height: 1.5;
        }
        
        .explanation {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
        }
        
        .explain-box {
            background: #f7fafc;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid;
        }
        
        .explain-box.pdf { border-color: #48bb78; }
        .explain-box.cdf { border-color: #4299e1; }
        .explain-box.inv { border-color: #ed8936; }
        
        .explain-box h4 {
            color: #2d3748;
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        
        .explain-box ul {
            color: #4a5568;
            font-size: 0.85em;
            margin-left: 15px;
            line-height: 1.6;
        }
        
        .animate-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        
        .animate-checkbox input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        @media (max-width: 1000px) {
            .visualization {
                grid-template-columns: 1fr;
            }
            .explanation {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Inverse CDF Method Visualized</h1>
        <p class="subtitle">F<sup>-</sup>(u) = inf{x : F(x) &ge; u} &nbsp;&mdash;&nbsp; Works for ALL distributions!</p>
        
        <div class="controls">
            <div class="control-group">
                <label for="distType">Distribution Type:</label>
                <select id="distType">
                    <option value="continuous">Continuous (Normal)</option>
                    <option value="exponential">Continuous (Exponential)</option>
                    <option value="discrete">Discrete (Poisson &lambda;=4)</option>
                    <option value="geometric">Discrete (Geometric p=0.3)</option>
                    <option value="mixed">Mixed (Zero-inflated)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="uValue">u value: <span id="uDisplay" style="color:#e53e3e; font-weight:bold;">0.50</span></label>
                <input type="range" id="uValue" min="0.0001" max="0.9999" step="0.0001" value="0.50">
            </div>
            
            <div class="control-group">
                <label class="animate-checkbox">
                    <input type="checkbox" id="animateToggle">
                    Animate u from 0 to 1
                </label>
            </div>
        </div>
        
        <div class="value-display">
            <strong>Transform:</strong> &nbsp; 
            u = <span id="uCurrent">0.50</span> &nbsp;&rarr;&nbsp; 
            F<sup>-</sup>(u) = <span id="xCurrent" style="color:#fbd38d;">0.00</span>
        </div>
        
        <div id="keyInsight" class="key-insight">
            <h3>&#128161; Key Insight</h3>
            <p id="insightText">For continuous distributions, the CDF is strictly increasing, so there's a unique x where F(x) = u. The steeper the CDF, the higher the density at that point.</p>
        </div>
        
        <div class="visualization">
            <div class="canvas-container">
                <div class="canvas-title">PDF / PMF: f(x)</div>
                <div class="canvas-subtitle">Probability density or mass</div>
                <canvas id="pdfCanvas" width="400" height="320"></canvas>
            </div>
            
            <div class="canvas-container">
                <div class="canvas-title">CDF: F(x)</div>
                <div class="canvas-subtitle">Cumulative probability</div>
                <canvas id="cdfCanvas" width="400" height="320"></canvas>
            </div>
            
            <div class="canvas-container">
                <div class="canvas-title">Inverse CDF: F<sup>-</sup>(u)</div>
                <div class="canvas-subtitle">Quantile function</div>
                <canvas id="invCanvas" width="400" height="320"></canvas>
            </div>
        </div>
        
        <div class="explanation">
            <div class="explain-box pdf">
                <h4>&#128200; PDF/PMF Panel</h4>
                <ul>
                    <li>Shows where probability mass lives</li>
                    <li>Shaded area = P(X &le; F<sup>-</sup>(u)) = u</li>
                    <li>Discrete: bars show P(X = k)</li>
                </ul>
            </div>
            <div class="explain-box cdf">
                <h4>&#128202; CDF Panel</h4>
                <ul>
                    <li>Draw horizontal line at height u</li>
                    <li>Find where it hits the CDF</li>
                    <li>Discrete: jumps create "flat regions"</li>
                </ul>
            </div>
            <div class="explain-box inv">
                <h4>&#128203; Inverse CDF Panel</h4>
                <ul>
                    <li>Direct view of u &rarr; x mapping</li>
                    <li>Discrete: plateaus (many u &rarr; same x)</li>
                    <li>This is what we compute!</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const pdfCanvas = document.getElementById('pdfCanvas');
        const cdfCanvas = document.getElementById('cdfCanvas');
        const invCanvas = document.getElementById('invCanvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const cdfCtx = cdfCanvas.getContext('2d');
        const invCtx = invCanvas.getContext('2d');
        
        // Controls
        const distTypeSelect = document.getElementById('distType');
        const uSlider = document.getElementById('uValue');
        const uDisplay = document.getElementById('uDisplay');
        const animateToggle = document.getElementById('animateToggle');
        const uCurrent = document.getElementById('uCurrent');
        const xCurrent = document.getElementById('xCurrent');
        const insightText = document.getElementById('insightText');
        
        let animationId = null;
        let animationU = 0.01;
        
        // Distribution functions
        function normalPDF(x, mu = 0, sigma = 1) {
            return Math.exp(-0.5 * Math.pow((x - mu) / sigma, 2)) / (sigma * Math.sqrt(2 * Math.PI));
        }
        
        function normalCDF(x, mu = 0, sigma = 1) {
            const z = (x - mu) / sigma;
            const t = 1 / (1 + 0.2316419 * Math.abs(z));
            const d = 0.3989422804014327;
            const p = d * Math.exp(-z * z / 2) * (t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274)))));
            return z > 0 ? 1 - p : p;
        }
        
        function normalInvCDF(u) {
            // Rational approximation
            if (u <= 0) return -Infinity;
            if (u >= 1) return Infinity;
            
            const a = [0, -3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02, 1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00];
            const b = [0, -5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02, 6.680131188771972e+01, -1.328068155288572e+01];
            const c = [0, -7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00, -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00];
            const d = [0, 7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00, 3.754408661907416e+00];
            
            const pLow = 0.02425;
            const pHigh = 1 - pLow;
            let q, r;
            
            if (u < pLow) {
                q = Math.sqrt(-2 * Math.log(u));
                return (((((c[1]*q+c[2])*q+c[3])*q+c[4])*q+c[5])*q+c[6]) / ((((d[1]*q+d[2])*q+d[3])*q+d[4])*q+1);
            } else if (u <= pHigh) {
                q = u - 0.5;
                r = q * q;
                return (((((a[1]*r+a[2])*r+a[3])*r+a[4])*r+a[5])*r+a[6])*q / (((((b[1]*r+b[2])*r+b[3])*r+b[4])*r+b[5])*r+1);
            } else {
                q = Math.sqrt(-2 * Math.log(1 - u));
                return -(((((c[1]*q+c[2])*q+c[3])*q+c[4])*q+c[5])*q+c[6]) / ((((d[1]*q+d[2])*q+d[3])*q+d[4])*q+1);
            }
        }
        
        function expPDF(x, lambda = 1) {
            return x >= 0 ? lambda * Math.exp(-lambda * x) : 0;
        }
        
        function expCDF(x, lambda = 1) {
            return x >= 0 ? 1 - Math.exp(-lambda * x) : 0;
        }
        
        function expInvCDF(u, lambda = 1) {
            return -Math.log(1 - u) / lambda;
        }
        
        // Poisson PMF and CDF
        function poissonPMF(k, lambda = 4) {
            if (k < 0 || !Number.isInteger(k)) return 0;
            let logP = -lambda + k * Math.log(lambda);
            for (let i = 2; i <= k; i++) logP -= Math.log(i);
            return Math.exp(logP);
        }
        
        function poissonCDF(x, lambda = 4) {
            let sum = 0;
            for (let k = 0; k <= Math.floor(x); k++) {
                sum += poissonPMF(k, lambda);
            }
            return sum;
        }
        
        function poissonInvCDF(u, lambda = 4) {
            let k = 0;
            let cumSum = poissonPMF(0, lambda);
            while (cumSum < u && k < 50) {
                k++;
                cumSum += poissonPMF(k, lambda);
            }
            return k;
        }
        
        // Geometric PMF and CDF
        function geometricPMF(k, p = 0.3) {
            if (k < 1 || !Number.isInteger(k)) return 0;
            return p * Math.pow(1 - p, k - 1);
        }
        
        function geometricCDF(x, p = 0.3) {
            if (x < 1) return 0;
            return 1 - Math.pow(1 - p, Math.floor(x));
        }
        
        function geometricInvCDF(u, p = 0.3) {
            return Math.ceil(Math.log(1 - u) / Math.log(1 - p));
        }
        
        // Mixed distribution (zero-inflated exponential)
        const mixedP0 = 0.3; // P(X = 0)
        
        function mixedPDF(x) {
            if (x === 0) return mixedP0;
            return (1 - mixedP0) * expPDF(x);
        }
        
        function mixedCDF(x) {
            if (x < 0) return 0;
            return mixedP0 + (1 - mixedP0) * expCDF(x);
        }
        
        function mixedInvCDF(u) {
            if (u <= mixedP0) return 0;
            return expInvCDF((u - mixedP0) / (1 - mixedP0));
        }
        
        // Get functions for current distribution type
        function getDistFunctions(type) {
            switch(type) {
                case 'continuous':
                    return { 
                        pdf: normalPDF, cdf: normalCDF, inv: normalInvCDF,
                        xRange: [-4, 4], yMaxPDF: 0.5, discrete: false
                    };
                case 'exponential':
                    return { 
                        pdf: expPDF, cdf: expCDF, inv: expInvCDF,
                        xRange: [0, 6], yMaxPDF: 1.1, discrete: false
                    };
                case 'discrete':
                    return { 
                        pmf: poissonPMF, cdf: poissonCDF, inv: poissonInvCDF,
                        xRange: [0, 12], yMaxPMF: 0.22, discrete: true, maxK: 12
                    };
                case 'geometric':
                    return { 
                        pmf: geometricPMF, cdf: geometricCDF, inv: geometricInvCDF,
                        xRange: [1, 15], yMaxPMF: 0.35, discrete: true, maxK: 15, startK: 1
                    };
                case 'mixed':
                    return { 
                        pdf: mixedPDF, cdf: mixedCDF, inv: mixedInvCDF,
                        xRange: [-0.5, 5], yMaxPDF: 0.8, discrete: false, hasPointMass: true
                    };
            }
        }
        
        // Update key insight text
        function updateInsight(type, u) {
            const dist = getDistFunctions(type);
            const x = dist.inv(u);
            
            if (type === 'discrete' || type === 'geometric') {
                const cdfAtX = dist.cdf(x);
                const cdfBelow = dist.cdf(x - 1);
                insightText.innerHTML = `<strong>Discrete case:</strong> u = ${u.toFixed(4)} falls in the "flat region" between F(${x-1}) = ${cdfBelow.toFixed(4)} and F(${x}) = ${cdfAtX.toFixed(4)}. The generalized inverse finds the smallest integer k where F(k) &ge; u, which is <strong>k = ${x}</strong>.`;
            } else if (type === 'mixed') {
                if (u <= mixedP0) {
                    insightText.innerHTML = `<strong>Mixed case (point mass):</strong> Since u = ${u.toFixed(4)} &le; ${mixedP0} = P(X=0), the inverse maps to the point mass at <strong>x = 0</strong>. All u in [0, ${mixedP0}] collapse to x = 0.`;
                } else {
                    insightText.innerHTML = `<strong>Mixed case (continuous part):</strong> Since u = ${u.toFixed(4)} > ${mixedP0}, we're in the exponential tail. F<sup>-</sup>(u) = ${x.toFixed(4)}.`;
                }
            } else {
                insightText.innerHTML = `<strong>Continuous case:</strong> The CDF is strictly increasing, so there's a unique x where F(x) = u = ${u.toFixed(4)}. Here, F<sup>-</sup>(${u.toFixed(4)}) = <strong>${x.toFixed(4)}</strong>. Notice how steep CDF regions map to high PDF values!`;
            }
        }
        
        // Draw PDF/PMF
        function drawPDF(u) {
            const width = pdfCanvas.width;
            const height = pdfCanvas.height;
            const margin = 45;
            const type = distTypeSelect.value;
            const dist = getDistFunctions(type);
            
            pdfCtx.clearRect(0, 0, width, height);
            
            // Background
            pdfCtx.fillStyle = '#fafafa';
            pdfCtx.fillRect(margin, margin, width - 2*margin, height - 2*margin);
            
            const [xMin, xMax] = dist.xRange;
            const xInv = dist.inv(u);
            
            // Scale functions
            const scaleX = (x) => margin + (x - xMin) / (xMax - xMin) * (width - 2*margin);
            const scaleY = (y, yMax) => height - margin - (y / yMax) * (height - 2*margin);
            
            if (dist.discrete) {
                // Draw PMF bars
                const yMax = dist.yMaxPMF;
                const startK = dist.startK || 0;
                const barWidth = (width - 2*margin) / (dist.maxK - startK + 2) * 0.7;
                
                for (let k = startK; k <= dist.maxK; k++) {
                    const pmf = dist.pmf(k);
                    const x = scaleX(k);
                    const barHeight = (pmf / yMax) * (height - 2*margin);
                    
                    // Shade bars up to xInv
                    if (k <= xInv) {
                        pdfCtx.fillStyle = 'rgba(72, 187, 120, 0.6)';
                    } else {
                        pdfCtx.fillStyle = 'rgba(66, 153, 225, 0.4)';
                    }
                    pdfCtx.fillRect(x - barWidth/2, height - margin - barHeight, barWidth, barHeight);
                    
                    // Bar outline
                    pdfCtx.strokeStyle = k <= xInv ? '#276749' : '#2b6cb0';
                    pdfCtx.lineWidth = 2;
                    pdfCtx.strokeRect(x - barWidth/2, height - margin - barHeight, barWidth, barHeight);
                    
                    // Labels
                    pdfCtx.fillStyle = '#4a5568';
                    pdfCtx.font = '11px Arial';
                    pdfCtx.textAlign = 'center';
                    pdfCtx.fillText(k.toString(), x, height - margin + 15);
                }
                
                // Highlight current k
                const xCurr = scaleX(xInv);
                pdfCtx.fillStyle = '#e53e3e';
                pdfCtx.beginPath();
                pdfCtx.arc(xCurr, height - margin - (dist.pmf(xInv) / yMax) * (height - 2*margin) - 10, 6, 0, 2*Math.PI);
                pdfCtx.fill();
                
            } else {
                // Draw continuous PDF
                const yMax = dist.yMaxPDF;
                
                // Shaded area (CDF visualization)
                pdfCtx.fillStyle = 'rgba(72, 187, 120, 0.4)';
                pdfCtx.beginPath();
                pdfCtx.moveTo(scaleX(xMin), height - margin);
                
                for (let i = 0; i <= 200; i++) {
                    const x = xMin + (Math.min(xInv, xMax) - xMin) * (i / 200);
                    const y = dist.pdf(x);
                    pdfCtx.lineTo(scaleX(x), scaleY(y, yMax));
                }
                pdfCtx.lineTo(scaleX(Math.min(xInv, xMax)), height - margin);
                pdfCtx.closePath();
                pdfCtx.fill();
                
                // PDF curve
                pdfCtx.strokeStyle = '#4299e1';
                pdfCtx.lineWidth = 3;
                pdfCtx.beginPath();
                for (let i = 0; i <= 200; i++) {
                    const x = xMin + (xMax - xMin) * (i / 200);
                    const y = dist.pdf(x);
                    const px = scaleX(x);
                    const py = scaleY(y, yMax);
                    if (i === 0) pdfCtx.moveTo(px, py);
                    else pdfCtx.lineTo(px, py);
                }
                pdfCtx.stroke();
                
                // Point mass for mixed
                if (dist.hasPointMass) {
                    pdfCtx.fillStyle = '#e53e3e';
                    pdfCtx.beginPath();
                    pdfCtx.arc(scaleX(0), scaleY(mixedP0, yMax), 8, 0, 2*Math.PI);
                    pdfCtx.fill();
                    pdfCtx.fillStyle = '#742a2a';
                    pdfCtx.font = '11px Arial';
                    pdfCtx.fillText(`P(X=0)=${mixedP0}`, scaleX(0) + 15, scaleY(mixedP0, yMax) - 5);
                }
                
                // Vertical line at x
                pdfCtx.strokeStyle = '#e53e3e';
                pdfCtx.lineWidth = 2;
                pdfCtx.setLineDash([5, 5]);
                pdfCtx.beginPath();
                pdfCtx.moveTo(scaleX(xInv), height - margin);
                pdfCtx.lineTo(scaleX(xInv), scaleY(dist.pdf(xInv), yMax));
                pdfCtx.stroke();
                pdfCtx.setLineDash([]);
            }
            
            // Axes
            pdfCtx.strokeStyle = '#2d3748';
            pdfCtx.lineWidth = 2;
            pdfCtx.beginPath();
            pdfCtx.moveTo(margin, margin);
            pdfCtx.lineTo(margin, height - margin);
            pdfCtx.lineTo(width - margin, height - margin);
            pdfCtx.stroke();
            
            // X-axis label showing Fâ»(u) value
            pdfCtx.fillStyle = '#e53e3e';
            pdfCtx.font = 'bold 11px Arial';
            pdfCtx.textAlign = 'center';
            const xLabelPos = scaleX(Math.max(xMin, Math.min(xMax, xInv)));
            pdfCtx.fillText(`x = ${dist.discrete ? xInv : xInv.toFixed(3)}`, xLabelPos, height - margin + 25);
            
            // Labels
            pdfCtx.fillStyle = '#48bb78';
            pdfCtx.font = 'bold 12px Arial';
            pdfCtx.textAlign = 'center';
            pdfCtx.fillText(`Shaded area = u = ${u.toFixed(4)}`, width/2, margin - 10);
            
            // Y-axis label
            pdfCtx.save();
            pdfCtx.translate(15, height/2);
            pdfCtx.rotate(-Math.PI/2);
            pdfCtx.fillStyle = '#4a5568';
            pdfCtx.fillText(dist.discrete ? 'P(X = k)' : 'f(x)', 0, 0);
            pdfCtx.restore();
        }
        
        // Draw CDF
        function drawCDF(u) {
            const width = cdfCanvas.width;
            const height = cdfCanvas.height;
            const margin = 45;
            const type = distTypeSelect.value;
            const dist = getDistFunctions(type);
            
            cdfCtx.clearRect(0, 0, width, height);
            
            // Background
            cdfCtx.fillStyle = '#fafafa';
            cdfCtx.fillRect(margin, margin, width - 2*margin, height - 2*margin);
            
            const [xMin, xMax] = dist.xRange;
            const xInv = dist.inv(u);
            
            const scaleX = (x) => margin + (x - xMin) / (xMax - xMin) * (width - 2*margin);
            const scaleY = (y) => height - margin - y * (height - 2*margin);
            
            // Grid
            cdfCtx.strokeStyle = '#e2e8f0';
            cdfCtx.lineWidth = 1;
            for (let i = 0.2; i < 1; i += 0.2) {
                cdfCtx.beginPath();
                cdfCtx.moveTo(margin, scaleY(i));
                cdfCtx.lineTo(width - margin, scaleY(i));
                cdfCtx.stroke();
                
                cdfCtx.fillStyle = '#a0aec0';
                cdfCtx.font = '10px Arial';
                cdfCtx.textAlign = 'right';
                cdfCtx.fillText(i.toFixed(1), margin - 5, scaleY(i) + 4);
            }
            
            // Draw CDF curve
            if (dist.discrete) {
                const startK = dist.startK || 0;
                cdfCtx.strokeStyle = '#4299e1';
                cdfCtx.lineWidth = 3;
                
                // Start from 0
                let prevCDF = startK > 0 ? dist.cdf(startK - 1) : 0;
                cdfCtx.beginPath();
                cdfCtx.moveTo(scaleX(xMin), scaleY(prevCDF));
                
                for (let k = startK; k <= dist.maxK; k++) {
                    const cdfVal = dist.cdf(k);
                    const x = scaleX(k);
                    
                    // Horizontal line (flat region)
                    cdfCtx.lineTo(x, scaleY(prevCDF));
                    
                    // Vertical jump
                    cdfCtx.stroke();
                    cdfCtx.beginPath();
                    cdfCtx.moveTo(x, scaleY(prevCDF));
                    cdfCtx.lineTo(x, scaleY(cdfVal));
                    
                    // Open circle at bottom of jump
                    cdfCtx.stroke();
                    cdfCtx.beginPath();
                    cdfCtx.arc(x, scaleY(prevCDF), 4, 0, 2*Math.PI);
                    cdfCtx.strokeStyle = '#4299e1';
                    cdfCtx.stroke();
                    
                    // Filled circle at top of jump
                    cdfCtx.fillStyle = '#4299e1';
                    cdfCtx.beginPath();
                    cdfCtx.arc(x, scaleY(cdfVal), 4, 0, 2*Math.PI);
                    cdfCtx.fill();
                    
                    // Continue horizontal
                    cdfCtx.strokeStyle = '#4299e1';
                    cdfCtx.lineWidth = 3;
                    cdfCtx.beginPath();
                    cdfCtx.moveTo(x, scaleY(cdfVal));
                    
                    prevCDF = cdfVal;
                }
                cdfCtx.lineTo(scaleX(xMax), scaleY(prevCDF));
                cdfCtx.stroke();
                
            } else {
                // Continuous CDF
                cdfCtx.strokeStyle = '#4299e1';
                cdfCtx.lineWidth = 3;
                cdfCtx.beginPath();
                for (let i = 0; i <= 200; i++) {
                    const x = xMin + (xMax - xMin) * (i / 200);
                    const y = dist.cdf(x);
                    const px = scaleX(x);
                    const py = scaleY(y);
                    if (i === 0) cdfCtx.moveTo(px, py);
                    else cdfCtx.lineTo(px, py);
                }
                cdfCtx.stroke();
                
                // Point mass jump for mixed
                if (dist.hasPointMass) {
                    cdfCtx.fillStyle = '#e53e3e';
                    cdfCtx.beginPath();
                    cdfCtx.arc(scaleX(0), scaleY(0), 4, 0, 2*Math.PI);
                    cdfCtx.stroke();
                    cdfCtx.beginPath();
                    cdfCtx.arc(scaleX(0), scaleY(mixedP0), 5, 0, 2*Math.PI);
                    cdfCtx.fill();
                }
            }
            
            // Horizontal line at u
            cdfCtx.strokeStyle = '#e53e3e';
            cdfCtx.lineWidth = 2;
            cdfCtx.setLineDash([8, 4]);
            cdfCtx.beginPath();
            cdfCtx.moveTo(margin, scaleY(u));
            cdfCtx.lineTo(scaleX(xInv), scaleY(u));
            cdfCtx.stroke();
            
            // Vertical line down to x
            cdfCtx.beginPath();
            cdfCtx.moveTo(scaleX(xInv), scaleY(u));
            cdfCtx.lineTo(scaleX(xInv), height - margin);
            cdfCtx.stroke();
            cdfCtx.setLineDash([]);
            
            // Intersection point
            cdfCtx.fillStyle = '#e53e3e';
            cdfCtx.beginPath();
            cdfCtx.arc(scaleX(xInv), scaleY(u), 7, 0, 2*Math.PI);
            cdfCtx.fill();
            
            // Labels
            cdfCtx.fillStyle = '#e53e3e';
            cdfCtx.font = 'bold 12px Arial';
            cdfCtx.textAlign = 'left';
            cdfCtx.fillText(`u = ${u.toFixed(4)}`, margin + 5, scaleY(u) - 8);
            
            cdfCtx.textAlign = 'center';
            cdfCtx.fillText(`x = ${dist.discrete ? xInv : xInv.toFixed(3)}`, scaleX(xInv), height - margin + 25);
            
            // Axes
            cdfCtx.strokeStyle = '#2d3748';
            cdfCtx.lineWidth = 2;
            cdfCtx.beginPath();
            cdfCtx.moveTo(margin, margin);
            cdfCtx.lineTo(margin, height - margin);
            cdfCtx.lineTo(width - margin, height - margin);
            cdfCtx.stroke();
            
            // Y-axis label
            cdfCtx.save();
            cdfCtx.translate(15, height/2);
            cdfCtx.rotate(-Math.PI/2);
            cdfCtx.fillStyle = '#4a5568';
            cdfCtx.fillText('F(x)', 0, 0);
            cdfCtx.restore();
        }
        
        // Draw Inverse CDF
        function drawInverseCDF(u) {
            const width = invCanvas.width;
            const height = invCanvas.height;
            const margin = 45;
            const type = distTypeSelect.value;
            const dist = getDistFunctions(type);
            
            invCtx.clearRect(0, 0, width, height);
            
            // Background
            invCtx.fillStyle = '#fafafa';
            invCtx.fillRect(margin, margin, width - 2*margin, height - 2*margin);
            
            const [xMin, xMax] = dist.xRange;
            const xInv = dist.inv(u);
            
            const scaleU = (uVal) => margin + uVal * (width - 2*margin);
            const scaleY = (y) => height - margin - (y - xMin) / (xMax - xMin) * (height - 2*margin);
            
            // Grid
            invCtx.strokeStyle = '#e2e8f0';
            invCtx.lineWidth = 1;
            for (let i = 0.2; i < 1; i += 0.2) {
                invCtx.beginPath();
                invCtx.moveTo(scaleU(i), margin);
                invCtx.lineTo(scaleU(i), height - margin);
                invCtx.stroke();
            }
            
            // Draw inverse CDF curve
            if (dist.discrete) {
                const startK = dist.startK || 0;
                invCtx.strokeStyle = '#ed8936';
                invCtx.lineWidth = 3;
                
                // For each integer k, draw horizontal line
                for (let k = startK; k <= dist.maxK; k++) {
                    const uLow = k === startK ? 0 : dist.cdf(k - 1);
                    const uHigh = dist.cdf(k);
                    
                    if (uHigh > 0.001 && uLow < 0.999) {
                        invCtx.beginPath();
                        invCtx.moveTo(scaleU(Math.max(0.01, uLow)), scaleY(k));
                        invCtx.lineTo(scaleU(Math.min(0.99, uHigh)), scaleY(k));
                        invCtx.stroke();
                        
                        // Open circle at left end (except first)
                        if (k > startK) {
                            invCtx.beginPath();
                            invCtx.arc(scaleU(uLow), scaleY(k), 4, 0, 2*Math.PI);
                            invCtx.strokeStyle = '#ed8936';
                            invCtx.stroke();
                        }
                        
                        // Filled circle at right end
                        invCtx.fillStyle = '#ed8936';
                        invCtx.beginPath();
                        invCtx.arc(scaleU(uHigh), scaleY(k), 4, 0, 2*Math.PI);
                        invCtx.fill();
                        
                        invCtx.strokeStyle = '#ed8936';
                        invCtx.lineWidth = 3;
                    }
                }
                
            } else {
                // Continuous inverse CDF
                invCtx.strokeStyle = '#ed8936';
                invCtx.lineWidth = 3;
                invCtx.beginPath();
                
                for (let i = 1; i <= 200; i++) {
                    const uVal = 0.0001 + (i / 200) * 0.9998;
                    const y = dist.inv(uVal);
                    const px = scaleU(uVal);
                    const py = scaleY(y);
                    
                    if (py >= margin && py <= height - margin) {
                        if (i === 1) invCtx.moveTo(px, py);
                        else invCtx.lineTo(px, py);
                    }
                }
                invCtx.stroke();
                
                // Flat region for mixed
                if (dist.hasPointMass) {
                    invCtx.lineWidth = 4;
                    invCtx.beginPath();
                    invCtx.moveTo(scaleU(0), scaleY(0));
                    invCtx.lineTo(scaleU(mixedP0), scaleY(0));
                    invCtx.stroke();
                    
                    invCtx.fillStyle = '#e53e3e';
                    invCtx.beginPath();
                    invCtx.arc(scaleU(mixedP0), scaleY(0), 5, 0, 2*Math.PI);
                    invCtx.fill();
                }
            }
            
            // Vertical line at u
            invCtx.strokeStyle = '#e53e3e';
            invCtx.lineWidth = 2;
            invCtx.setLineDash([8, 4]);
            invCtx.beginPath();
            invCtx.moveTo(scaleU(u), height - margin);
            invCtx.lineTo(scaleU(u), scaleY(xInv));
            invCtx.stroke();
            
            // Horizontal to y-axis
            invCtx.beginPath();
            invCtx.moveTo(scaleU(u), scaleY(xInv));
            invCtx.lineTo(margin, scaleY(xInv));
            invCtx.stroke();
            invCtx.setLineDash([]);
            
            // Point
            invCtx.fillStyle = '#e53e3e';
            invCtx.beginPath();
            invCtx.arc(scaleU(u), scaleY(xInv), 7, 0, 2*Math.PI);
            invCtx.fill();
            
            // Labels
            invCtx.fillStyle = '#e53e3e';
            invCtx.font = 'bold 12px Arial';
            invCtx.textAlign = 'center';
            invCtx.fillText(`u = ${u.toFixed(4)}`, scaleU(u), height - margin + 25);
            
            invCtx.textAlign = 'right';
            invCtx.fillText(`${dist.discrete ? xInv : xInv.toFixed(3)}`, margin - 8, scaleY(xInv) + 4);
            
            // Axes
            invCtx.strokeStyle = '#2d3748';
            invCtx.lineWidth = 2;
            invCtx.beginPath();
            invCtx.moveTo(margin, margin);
            invCtx.lineTo(margin, height - margin);
            invCtx.lineTo(width - margin, height - margin);
            invCtx.stroke();
            
            // Axis labels
            invCtx.fillStyle = '#4a5568';
            invCtx.font = '11px Arial';
            invCtx.textAlign = 'center';
            invCtx.fillText('0', margin, height - margin + 15);
            invCtx.fillText('1', width - margin, height - margin + 15);
            invCtx.fillText('u', width/2, height - 10);
            
            // Y-axis label
            invCtx.save();
            invCtx.translate(15, height/2);
            invCtx.rotate(-Math.PI/2);
            invCtx.fillText('F\u207B(u)', 0, 0);
            invCtx.restore();
        }
        
        function updateVisualization(u) {
            const type = distTypeSelect.value;
            const dist = getDistFunctions(type);
            const xInv = dist.inv(u);
            
            drawPDF(u);
            drawCDF(u);
            drawInverseCDF(u);
            
            uCurrent.textContent = u.toFixed(4);
            xCurrent.textContent = dist.discrete ? xInv.toString() : xInv.toFixed(4);
            
            updateInsight(type, u);
        }
        
        function animate() {
            if (animateToggle.checked) {
                animationU += 0.002;
                if (animationU > 0.9999) {
                    animationU = 0.0001;
                }
                uSlider.value = animationU;
                uDisplay.textContent = animationU.toFixed(4);
                updateVisualization(animationU);
                animationId = requestAnimationFrame(animate);
            }
        }
        
        // Event listeners
        uSlider.addEventListener('input', (e) => {
            const u = parseFloat(e.target.value);
            uDisplay.textContent = u.toFixed(4);
            updateVisualization(u);
        });
        
        distTypeSelect.addEventListener('change', () => {
            updateVisualization(parseFloat(uSlider.value));
        });
        
        animateToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
                animate();
            } else {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }
        });
        
        // Canvas interaction
        function handleCanvasHover(e, canvas) {
            if (animateToggle.checked) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const margin = 45 / canvas.width;
            
            // Map to u range (0.0001 to 0.9999)
            const u = Math.max(0.0001, Math.min(0.9999, (x - margin) / (1 - 2*margin)));
            
            uSlider.value = u;
            uDisplay.textContent = u.toFixed(4);
            updateVisualization(u);
        }
        
        cdfCanvas.addEventListener('mousemove', (e) => handleCanvasHover(e, cdfCanvas));
        invCanvas.addEventListener('mousemove', (e) => handleCanvasHover(e, invCanvas));
        
        // Initial draw
        updateVisualization(0.5);
    </script>
</body>
</html>
