<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Central Limit Theorem Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            display: flex;
            min-height: 600px;
        }

        .sidebar {
            width: 350px;
            background: #f8f9fa;
            padding: 30px;
            border-right: 1px solid #e0e0e0;
        }

        .main-panel {
            flex: 1;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        select, input[type="number"] {
            width: 100%;
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: white;
        }

        select:focus, input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 30px;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
        }

        .chart-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
            height: 350px;
        }

        .chart-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .dynamic-inputs {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e0e0e0;
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .info-box h3 {
            color: #1976D2;
            margin-bottom: 8px;
        }

        .info-box p {
            color: #555;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Central Limit Theorem Simulation</h1>
            <p>Explore how sample means converge to a normal distribution</p>
            <p style="font-size: 0.9em; opacity: 0.8; margin-top: 10px;">CLT requires finite mean and variance - try the Cauchy distribution to see what happens when these don't exist!</p>
        </div>
        
        <div class="content">
            <div class="sidebar">
                <div class="info-box">
                    <h3>How it works</h3>
                    <p>Select a population distribution, set parameters, choose sample size, and watch the magic of CLT!</p>
                </div>
                
                <div class="form-group">
                    <label for="distribution">Population Distribution</label>
                    <select id="distribution">
                        <option value="normal">Normal</option>
                        <option value="uniform">Uniform</option>
                        <option value="exponential">Exponential</option>
                        <option value="beta">Left-Skewed Beta</option>
                        <option value="bimodal">Bimodal</option>
                        <option value="binomial">Binomial</option>
                        <option value="poisson">Poisson</option>
                        <option value="cauchy">Cauchy (CLT Failure!)</option>
                    </select>
                </div>
                
                <div id="dynamicInputs" class="dynamic-inputs"></div>
                
                <div class="form-group">
                    <label for="sampleSize">Sample Size (n)</label>
                    <input type="number" id="sampleSize" value="30" min="1" step="5">
                </div>
                
                <div class="form-group">
                    <label for="numSamples">Number of Samples</label>
                    <input type="number" id="numSamples" value="1000" min="100" step="100">
                </div>
                
                <div class="button-group">
                    <button class="btn-primary" onclick="simulate()">Simulate</button>
                    <button class="btn-secondary" onclick="reset()">Reset</button>
                </div>
            </div>
            
            <div class="main-panel">
                <div class="chart-container">
                    <div class="chart-title">Population Distribution</div>
                    <canvas id="populationChart"></canvas>
                </div>
                
                <div class="chart-container">
                    <div class="chart-title">Distribution of Sample Means</div>
                    <canvas id="sampleMeansChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global chart instances
        let populationChart = null;
        let sampleMeansChart = null;

        // Initialize charts
        function initCharts() {
            const popCtx = document.getElementById('populationChart').getContext('2d');
            const sampleCtx = document.getElementById('sampleMeansChart').getContext('2d');
            
            // Plugin to draw vertical mean line
            const verticalLinePlugin = {
                id: 'verticalLine',
                afterDraw: (chart, args, options) => {
                    if (options.mean !== undefined) {
                        const ctx = chart.ctx;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;
                        
                        // Find the closest label to the mean
                        const labels = chart.data.labels.map(l => parseFloat(l));
                        let closestIndex = 0;
                        let minDiff = Math.abs(labels[0] - options.mean);
                        
                        for (let i = 1; i < labels.length; i++) {
                            const diff = Math.abs(labels[i] - options.mean);
                            if (diff < minDiff) {
                                minDiff = diff;
                                closestIndex = i;
                            }
                        }
                        
                        const x = xAxis.getPixelForValue(closestIndex);
                        
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(x, yAxis.top);
                        ctx.lineTo(x, yAxis.bottom);
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = options.color || '#ff0000';
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        
                        // Add label
                        ctx.fillStyle = options.color || '#ff0000';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        const label = options.isCauchy ? `x₀ = ${options.mean.toFixed(2)}` : `μ = ${options.mean.toFixed(2)}`;
                        ctx.fillText(label, x, yAxis.top - 10);
                        
                        ctx.restore();
                    }
                }
            };
            
            populationChart = new Chart(popCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Population Distribution',
                        data: [],
                        borderColor: '#764ba2',
                        backgroundColor: 'rgba(118, 75, 162, 0.2)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        verticalLine: {}
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Density',
                                font: { size: 14, weight: 'bold' }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Value',
                                font: { size: 14, weight: 'bold' }
                            }
                        }
                    }
                },
                plugins: [verticalLinePlugin]
            });
            
            sampleMeansChart = new Chart(sampleCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Sample Means Histogram',
                        data: [],
                        backgroundColor: 'rgba(102, 126, 234, 0.5)',
                        borderColor: '#667eea',
                        borderWidth: 1,
                        barPercentage: 0.9,
                        categoryPercentage: 1.0,
                        order: 3
                    }, {
                        label: 'Kernel Density',
                        data: [],
                        type: 'line',
                        borderColor: '#e74c3c',
                        backgroundColor: 'transparent',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0,
                        order: 1
                    }, {
                        label: 'Theoretical Normal',
                        data: [],
                        type: 'line',
                        borderColor: '#2ecc71',
                        backgroundColor: 'transparent',
                        borderWidth: 3,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0,
                        order: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        verticalLine: {}
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Density',
                                font: { size: 14, weight: 'bold' }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Sample Mean',
                                font: { size: 14, weight: 'bold' }
                            }
                        }
                    }
                },
                plugins: [verticalLinePlugin]
            });
        }

        // Update dynamic inputs based on distribution
        function updateDynamicInputs() {
            const dist = document.getElementById('distribution').value;
            const container = document.getElementById('dynamicInputs');
            
            let html = '';
            
            switch(dist) {
                case 'normal':
                    html = `
                        <div class="form-group">
                            <label for="mean">Population Mean (μ)</label>
                            <input type="number" id="mean" value="50" step="1">
                        </div>
                        <div class="form-group">
                            <label for="sd">Population SD (σ)</label>
                            <input type="number" id="sd" value="10" step="1">
                        </div>
                    `;
                    break;
                case 'uniform':
                    html = `
                        <div class="form-group">
                            <label for="min">Minimum (a)</label>
                            <input type="number" id="min" value="0" step="1">
                        </div>
                        <div class="form-group">
                            <label for="max">Maximum (b)</label>
                            <input type="number" id="max" value="100" step="1">
                        </div>
                    `;
                    break;
                case 'exponential':
                    html = `
                        <div class="form-group">
                            <label for="rate">Rate (λ)</label>
                            <input type="number" id="rate" value="1" step="0.1">
                        </div>
                    `;
                    break;
                case 'beta':
                    html = `
                        <div class="form-group">
                            <label for="alpha">Alpha Parameter (α)</label>
                            <input type="number" id="alpha" value="15" step="1">
                        </div>
                        <div class="form-group">
                            <label for="beta">Beta Parameter (β)</label>
                            <input type="number" id="beta" value="2" step="1">
                        </div>
                    `;
                    break;
                case 'bimodal':
                    html = `
                        <div class="form-group">
                            <label for="mean1">First Mean (μ₁)</label>
                            <input type="number" id="mean1" value="20" step="1">
                        </div>
                        <div class="form-group">
                            <label for="mean2">Second Mean (μ₂)</label>
                            <input type="number" id="mean2" value="80" step="1">
                        </div>
                        <div class="form-group">
                            <label for="sd1">First SD (σ₁)</label>
                            <input type="number" id="sd1" value="10" step="1">
                        </div>
                        <div class="form-group">
                            <label for="sd2">Second SD (σ₂)</label>
                            <input type="number" id="sd2" value="15" step="1">
                        </div>
                        <div class="form-group">
                            <label for="prop1">Proportion of First</label>
                            <input type="number" id="prop1" value="0.5" min="0" max="1" step="0.1">
                        </div>
                    `;
                    break;
                case 'binomial':
                    html = `
                        <div class="form-group">
                            <label for="n">Number of Trials (n)</label>
                            <input type="number" id="n" value="15" min="1" step="1">
                        </div>
                        <div class="form-group">
                            <label for="p">Probability of Success (p)</label>
                            <input type="number" id="p" value="0.5" min="0" max="1" step="0.1">
                        </div>
                    `;
                    break;
                case 'poisson':
                    html = `
                        <div class="form-group">
                            <label for="lambda">Lambda (λ)</label>
                            <input type="number" id="lambda" value="3" min="0.1" step="0.5">
                        </div>
                    `;
                    break;
                case 'cauchy':
                    html = `
                        <div class="form-group">
                            <label for="location">Location (x₀)</label>
                            <input type="number" id="location" value="0" step="1">
                        </div>
                        <div class="form-group">
                            <label for="scale">Scale (γ)</label>
                            <input type="number" id="scale" value="1" min="0.1" step="0.1">
                        </div>
                        <div class="info-box" style="background: #fff3cd; border-left-color: #ffc107;">
                            <h3 style="color: #856404;">⚠️ CLT Failure Case!</h3>
                            <p style="color: #856404;">The Cauchy distribution has undefined mean and variance. Sample means will NOT converge to a normal distribution!</p>
                        </div>
                    `;
                    break;
            }
            
            container.innerHTML = html;
        }

        // Statistical functions
        function normalPDF(x, mean, sd) {
            return (1 / (sd * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - mean) / sd, 2));
        }

        function uniformPDF(x, min, max) {
            return (x >= min && x <= max) ? 1 / (max - min) : 0;
        }

        function exponentialPDF(x, rate) {
            return x >= 0 ? rate * Math.exp(-rate * x) : 0;
        }

        function betaPDF(x, alpha, beta) {
            if (x <= 0 || x >= 1) return 0;
            const B = (gamma(alpha) * gamma(beta)) / gamma(alpha + beta);
            return Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1) / B;
        }

        function gamma(n) {
            const g = 7;
            const C = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
            
            if (n < 0.5) return Math.PI / (Math.sin(Math.PI * n) * gamma(1 - n));
            
            n--;
            let x = C[0];
            for (let i = 1; i < g + 2; i++) x += C[i] / (n + i);
            const t = n + g + 0.5;
            return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
        }

        function binomialPMF(k, n, p) {
            if (k < 0 || k > n) return 0;
            return combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
        }

        function poissonPMF(k, lambda) {
            if (k < 0) return 0;
            return Math.pow(lambda, k) * Math.exp(-lambda) / factorial(k);
        }

        function cauchyPDF(x, location, scale) {
            return 1 / (Math.PI * scale * (1 + Math.pow((x - location) / scale, 2)));
        }

        function combination(n, k) {
            if (k > n) return 0;
            if (k === 0 || k === n) return 1;
            return factorial(n) / (factorial(k) * factorial(n - k));
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }

        // Calculate population mean
        function getPopulationMean(dist, params) {
            switch(dist) {
                case 'normal':
                    return params.mean;
                case 'uniform':
                    return (params.min + params.max) / 2;
                case 'exponential':
                    return 1 / params.rate;
                case 'beta':
                    return params.alpha / (params.alpha + params.beta);
                case 'bimodal':
                    return params.prop1 * params.mean1 + (1 - params.prop1) * params.mean2;
                case 'binomial':
                    return params.n * params.p;
                case 'poisson':
                    return params.lambda;
                case 'cauchy':
                    return params.location; // Technically undefined, but we'll use location for visualization
            }
        }

        // Calculate population standard deviation
        function getPopulationSD(dist, params) {
            switch(dist) {
                case 'normal':
                    return params.sd;
                case 'uniform':
                    return Math.sqrt(Math.pow(params.max - params.min, 2) / 12);
                case 'exponential':
                    return 1 / params.rate;
                case 'beta':
                    const a = params.alpha;
                    const b = params.beta;
                    return Math.sqrt((a * b) / ((a + b) * (a + b) * (a + b + 1)));
                case 'bimodal':
                    const mean = getPopulationMean(dist, params);
                    const var1 = params.sd1 * params.sd1 + params.mean1 * params.mean1;
                    const var2 = params.sd2 * params.sd2 + params.mean2 * params.mean2;
                    const variance = params.prop1 * var1 + (1 - params.prop1) * var2 - mean * mean;
                    return Math.sqrt(variance);
                case 'binomial':
                    return Math.sqrt(params.n * params.p * (1 - params.p));
                case 'poisson':
                    return Math.sqrt(params.lambda);
                case 'cauchy':
                    return Infinity; // Undefined variance
            }
        }

        // Gaussian kernel for KDE
        function gaussianKernel(u) {
            return (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-0.5 * u * u);
        }

        // Kernel Density Estimation
        function kernelDensityEstimation(data, bandwidth) {
            return function(x) {
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += gaussianKernel((x - data[i]) / bandwidth);
                }
                return sum / (data.length * bandwidth);
            };
        }

        // Random number generators
        function randomNormal(mean, sd) {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return mean + sd * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        function randomExponential(rate) {
            return -Math.log(1 - Math.random()) / rate;
        }

        function randomBeta(alpha, beta) {
            const x = randomGamma(alpha);
            const y = randomGamma(beta);
            return x / (x + y);
        }

        function randomGamma(alpha) {
            if (alpha < 1) {
                const u = Math.random();
                return randomGamma(1 + alpha) * Math.pow(u, 1 / alpha);
            }
            
            const d = alpha - 1 / 3;
            const c = 1 / Math.sqrt(9 * d);
            
            while (true) {
                let x, v;
                do {
                    x = randomNormal(0, 1);
                    v = 1 + c * x;
                } while (v <= 0);
                
                v = v * v * v;
                const u = Math.random();
                if (u < 1 - 0.0331 * x * x * x * x) return d * v;
                if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) return d * v;
            }
        }

        function randomBinomial(n, p) {
            let successes = 0;
            for (let i = 0; i < n; i++) {
                if (Math.random() < p) successes++;
            }
            return successes;
        }

        function randomPoisson(lambda) {
            const L = Math.exp(-lambda);
            let k = 0;
            let p = 1;
            
            do {
                k++;
                p *= Math.random();
            } while (p > L);
            
            return k - 1;
        }

        function randomCauchy(location, scale) {
            const u = Math.random();
            return location + scale * Math.tan(Math.PI * (u - 0.5));
        }

        // Generate population data
        function generatePopulationData(dist, params) {
            const data = { x: [], y: [] };
            const isDiscrete = ['binomial', 'poisson'].includes(dist);
            
            if (isDiscrete) {
                let range;
                if (dist === 'binomial') {
                    const { n, p } = params;
                    const mean = n * p;
                    const sd = Math.sqrt(n * p * (1 - p));
                    const lower = Math.max(0, Math.floor(mean - 4 * sd));
                    const upper = Math.min(n, Math.ceil(mean + 4 * sd));
                    range = Array.from({ length: upper - lower + 1 }, (_, i) => lower + i);
                } else if (dist === 'poisson') {
                    const { lambda } = params;
                    const upper = Math.max(20, Math.ceil(lambda + 4 * Math.sqrt(lambda)));
                    range = Array.from({ length: upper + 1 }, (_, i) => i);
                }
                
                for (let x of range) {
                    data.x.push(x);
                    if (dist === 'binomial') {
                        data.y.push(binomialPMF(x, params.n, params.p));
                    } else {
                        data.y.push(poissonPMF(x, params.lambda));
                    }
                }
            } else {
                const numPoints = 200;
                let xMin, xMax;
                
                switch(dist) {
                    case 'normal':
                        xMin = params.mean - 4 * params.sd;
                        xMax = params.mean + 4 * params.sd;
                        break;
                    case 'uniform':
                        xMin = params.min;
                        xMax = params.max;
                        break;
                    case 'exponential':
                        xMin = 0;
                        xMax = 5 / params.rate;
                        break;
                    case 'beta':
                        xMin = 0;
                        xMax = 1;
                        break;
                    case 'bimodal':
                        xMin = Math.min(params.mean1 - 4 * params.sd1, params.mean2 - 4 * params.sd2);
                        xMax = Math.max(params.mean1 + 4 * params.sd1, params.mean2 + 4 * params.sd2);
                        break;
                    case 'cauchy':
                        xMin = params.location - 10 * params.scale;
                        xMax = params.location + 10 * params.scale;
                        break;
                }
                
                for (let i = 0; i <= numPoints; i++) {
                    const x = xMin + (xMax - xMin) * i / numPoints;
                    data.x.push(x);
                    
                    let y;
                    switch(dist) {
                        case 'normal':
                            y = normalPDF(x, params.mean, params.sd);
                            break;
                        case 'uniform':
                            y = uniformPDF(x, params.min, params.max);
                            break;
                        case 'exponential':
                            y = exponentialPDF(x, params.rate);
                            break;
                        case 'beta':
                            y = betaPDF(x, params.alpha, params.beta);
                            break;
                        case 'bimodal':
                            y = params.prop1 * normalPDF(x, params.mean1, params.sd1) + 
                                (1 - params.prop1) * normalPDF(x, params.mean2, params.sd2);
                            break;
                        case 'cauchy':
                            y = cauchyPDF(x, params.location, params.scale);
                            break;
                    }
                    data.y.push(y);
                }
            }
            
            return data;
        }

        // Sample from distribution
        function sampleFromDistribution(dist, params) {
            switch(dist) {
                case 'normal':
                    return randomNormal(params.mean, params.sd);
                case 'uniform':
                    return params.min + Math.random() * (params.max - params.min);
                case 'exponential':
                    return randomExponential(params.rate);
                case 'beta':
                    return randomBeta(params.alpha, params.beta);
                case 'bimodal':
                    if (Math.random() < params.prop1) {
                        return randomNormal(params.mean1, params.sd1);
                    } else {
                        return randomNormal(params.mean2, params.sd2);
                    }
                case 'binomial':
                    return randomBinomial(params.n, params.p);
                case 'poisson':
                    return randomPoisson(params.lambda);
                case 'cauchy':
                    return randomCauchy(params.location, params.scale);
            }
        }

        // Main simulation function
        function simulate() {
            const dist = document.getElementById('distribution').value;
            const sampleSize = parseInt(document.getElementById('sampleSize').value);
            const numSamples = parseInt(document.getElementById('numSamples').value);
            
            // Get parameters
            const params = {};
            switch(dist) {
                case 'normal':
                    params.mean = parseFloat(document.getElementById('mean').value);
                    params.sd = parseFloat(document.getElementById('sd').value);
                    break;
                case 'uniform':
                    params.min = parseFloat(document.getElementById('min').value);
                    params.max = parseFloat(document.getElementById('max').value);
                    break;
                case 'exponential':
                    params.rate = parseFloat(document.getElementById('rate').value);
                    break;
                case 'beta':
                    params.alpha = parseFloat(document.getElementById('alpha').value);
                    params.beta = parseFloat(document.getElementById('beta').value);
                    break;
                case 'bimodal':
                    params.mean1 = parseFloat(document.getElementById('mean1').value);
                    params.mean2 = parseFloat(document.getElementById('mean2').value);
                    params.sd1 = parseFloat(document.getElementById('sd1').value);
                    params.sd2 = parseFloat(document.getElementById('sd2').value);
                    params.prop1 = parseFloat(document.getElementById('prop1').value);
                    break;
                case 'binomial':
                    params.n = parseInt(document.getElementById('n').value);
                    params.p = parseFloat(document.getElementById('p').value);
                    break;
                case 'poisson':
                    params.lambda = parseFloat(document.getElementById('lambda').value);
                    break;
                case 'cauchy':
                    params.location = parseFloat(document.getElementById('location').value);
                    params.scale = parseFloat(document.getElementById('scale').value);
                    break;
            }
            
            // Calculate population mean and SD
            const popMean = getPopulationMean(dist, params);
            const popSD = getPopulationSD(dist, params);
            const sampleMeanSD = popSD / Math.sqrt(sampleSize);
            
            // Update population chart
            const popData = generatePopulationData(dist, params);
            const isDiscrete = ['binomial', 'poisson'].includes(dist);
            
            populationChart.config.type = isDiscrete ? 'bar' : 'line';
            populationChart.data.labels = popData.x.map(x => x.toFixed(2));
            populationChart.data.datasets[0].data = popData.y;
            populationChart.data.datasets[0].backgroundColor = isDiscrete ? 'rgba(118, 75, 162, 0.8)' : 'rgba(118, 75, 162, 0.2)';
            populationChart.options.plugins.verticalLine = {
                mean: popMean,
                color: '#e74c3c',
                isCauchy: dist === 'cauchy'
            };
            populationChart.update();
            
            // Generate sample means
            const sampleMeans = [];
            for (let i = 0; i < numSamples; i++) {
                let sum = 0;
                for (let j = 0; j < sampleSize; j++) {
                    sum += sampleFromDistribution(dist, params);
                }
                sampleMeans.push(sum / sampleSize);
            }
            
            // Create histogram
            const numBins = 30;
            const minMean = Math.min(...sampleMeans);
            const maxMean = Math.max(...sampleMeans);
            const range = maxMean - minMean;
            const binWidth = range / numBins;
            
            const bins = Array(numBins).fill(0);
            const binCenters = [];
            const binLabels = [];
            
            for (let i = 0; i < numBins; i++) {
                const binStart = minMean + i * binWidth;
                const binEnd = binStart + binWidth;
                const binCenter = (binStart + binEnd) / 2;
                binCenters.push(binCenter);
                binLabels.push(binCenter.toFixed(2));
                
                for (let mean of sampleMeans) {
                    if (mean >= binStart && mean < binEnd) {
                        bins[i]++;
                    }
                }
            }
            
            // Normalize histogram to density
            const normalizedBins = bins.map(count => count / (numSamples * binWidth));
            
            // Calculate KDE
            const sampleSD = Math.sqrt(sampleMeans.reduce((sum, x) => sum + Math.pow(x - sampleMeans.reduce((a, b) => a + b, 0) / sampleMeans.length, 2), 0) / (sampleMeans.length - 1));
            const bandwidth = 1.06 * sampleSD * Math.pow(numSamples, -0.2);
            const kde = kernelDensityEstimation(sampleMeans, bandwidth);
            
            // Generate smooth KDE curve
            const kdePoints = 100;
            const kdeX = [];
            const kdeY = [];
            const expandedMin = minMean - range * 0.1;
            const expandedMax = maxMean + range * 0.1;
            
            for (let i = 0; i <= kdePoints; i++) {
                const x = expandedMin + (expandedMax - expandedMin) * i / kdePoints;
                kdeX.push(x.toFixed(2));
                kdeY.push(kde(x));
            }
            
            // Generate theoretical normal curve (or Cauchy for Cauchy distribution)
            let theoreticalY;
            if (dist === 'cauchy') {
                // For Cauchy, the sample mean also follows a Cauchy distribution with same parameters
                theoreticalY = kdeX.map(x => cauchyPDF(parseFloat(x), params.location, params.scale));
            } else if (popSD === Infinity) {
                // If variance is infinite, don't show theoretical normal
                theoreticalY = kdeX.map(() => 0);
            } else {
                // Normal CLT case
                theoreticalY = kdeX.map(x => normalPDF(parseFloat(x), popMean, sampleMeanSD));
            }
            
            // Update sample means chart
            sampleMeansChart.data.labels = kdeX;
            
            // Create histogram data aligned with KDE x-values
            const alignedHistogram = kdeX.map(x => {
                const xVal = parseFloat(x);
                // Find which bin this x value belongs to
                for (let i = 0; i < binCenters.length; i++) {
                    if (Math.abs(xVal - binCenters[i]) < binWidth / 2) {
                        return normalizedBins[i];
                    }
                }
                return 0;
            });
            
            sampleMeansChart.data.datasets[0].data = alignedHistogram;
            sampleMeansChart.data.datasets[1].data = kdeY;
            sampleMeansChart.data.datasets[2].data = theoreticalY;
            
            // Update the legend label for theoretical curve based on distribution
            if (dist === 'cauchy') {
                sampleMeansChart.data.datasets[2].label = 'Theoretical Cauchy (No CLT!)';
            } else {
                sampleMeansChart.data.datasets[2].label = 'Theoretical Normal';
            }
            
            // Set vertical line for mean
            sampleMeansChart.options.plugins.verticalLine = {
                mean: popMean,
                color: '#e74c3c',
                isCauchy: dist === 'cauchy'
            };
            
            sampleMeansChart.update();
        }

        // Reset function
        function reset() {
            populationChart.data.labels = [];
            populationChart.data.datasets[0].data = [];
            populationChart.options.plugins.verticalLine = {};
            populationChart.update();
            
            sampleMeansChart.data.labels = [];
            sampleMeansChart.data.datasets[0].data = [];
            sampleMeansChart.data.datasets[1].data = [];
            sampleMeansChart.data.datasets[2].data = [];
            sampleMeansChart.data.datasets[2].label = 'Theoretical Normal';
            sampleMeansChart.options.plugins.verticalLine = {};
            sampleMeansChart.update();
        }

        // Initialize on load
        window.onload = function() {
            initCharts();
            updateDynamicInputs();
            document.getElementById('distribution').addEventListener('change', updateDynamicInputs);
            
            // Run simulation with default values
            setTimeout(() => simulate(), 100);
        };
    </script>
</body>
</html>