<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QQ-Plot Construction Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.6/jstat.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 25px;
            padding: 40px;
            backdrop-filter: blur(10px);
            box-shadow: 0 25px 45px rgba(0, 0, 0, 0.2);
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #fff, #e0f7ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .description {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.1em;
            opacity: 0.95;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 20px;
            justify-content: center;
            align-items: flex-end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.9;
        }

        select, input[type="number"], input[type="range"] {
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
        }

        input[type="range"] {
            width: 200px;
        }

        select:hover, input[type="number"]:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.5);
        }

        select option {
            background: #2a5298;
            color: white;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: white;
        }

        #generateBtn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        #generateBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }

        #animateBtn {
            background: linear-gradient(45deg, #FF6B6B, #ee5a6f);
            box-shadow: 0 4px 15px rgba(238, 90, 111, 0.4);
        }

        #animateBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(238, 90, 111, 0.6);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .viz-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 15px;
        }

        .viz-section.full-width {
            grid-column: 1 / -1;
        }

        .viz-title {
            font-size: 1em;
            margin-bottom: 10px;
            text-align: center;
            color: #ffd700;
        }

        .transformation-container {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .curve-panel {
            flex: 1;
            min-width: 280px;
            max-width: 450px;
        }

        .curve-panel h4 {
            text-align: center;
            margin-bottom: 10px;
            color: #e0f7ff;
        }

        .arrow-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 100px;
            padding: 10px;
        }

        .transform-formula {
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            color: #ffd700;
        }

        .arrow-svg {
            width: 80px;
            height: 60px;
        }

        canvas {
            width: 100%;
            background: white;
            border-radius: 10px;
            margin-bottom: 8px;
            display: block;
            max-height: 300px;
        }

        .step-indicator {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            text-align: center;
        }

        .step-text {
            font-size: 1.1em;
            color: #ffd700;
            margin-bottom: 10px;
        }

        .step-description {
            opacity: 0.9;
            line-height: 1.6;
        }

        .data-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin-top: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
            max-height: 80px;
            overflow-y: auto;
        }

        .stats-row {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.7;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 1.3em;
            color: #ffd700;
            font-weight: bold;
        }

        .animation-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            justify-content: center;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @media (max-width: 1200px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 1.8em;
            }

            .description {
                font-size: 1em;
            }

            .control-row {
                gap: 15px;
            }

            .visualization-grid {
                grid-template-columns: 1fr;
            }

            .viz-section.full-width {
                grid-column: 1;
            }

            .curve-panel {
                max-width: 100%;
            }

            .arrow-panel {
                width: 100%;
                flex-direction: row;
            }

            .arrow-svg {
                transform: rotate(90deg);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.5em;
            }

            .control-row {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                width: 100%;
            }

            select, input[type="number"] {
                width: 100%;
            }

            button {
                width: 100%;
            }

            .stats-row {
                gap: 20px;
            }

            .transformation-container {
                flex-direction: column;
            }
        }

        .highlight {
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>QQ-Plot Construction Visualizer</h1>
        
        <p class="description">
            Watch step-by-step how a normal QQ-plot is constructed. Generate samples from various distributions, 
            see how they're standardized, and observe how theoretical normal quantiles are compared with sample quantiles.
        </p>

        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label>Distribution</label>
                    <select id="distribution">
                        <optgroup label="Continuous">
                            <option value="normal">Normal (Gaussian)</option>
                            <option value="uniform">Uniform</option>
                            <option value="exponential">Exponential</option>
                            <option value="gamma">Gamma</option>
                            <option value="beta">Beta</option>
                            <option value="cauchy">Cauchy</option>
                            <option value="t">t-distribution</option>
                            <option value="lognormal">Log-Normal</option>
                            <option value="weibull">Weibull</option>
                            <option value="chi2">Chi-squared</option>
                        </optgroup>
                        <optgroup label="Discrete">
                            <option value="binomial">Binomial</option>
                            <option value="poisson">Poisson</option>
                            <option value="geometric">Geometric</option>
                        </optgroup>
                    </select>
                </div>

                <div class="control-group">
                    <label>Sample Size (n)</label>
                    <input type="number" id="sampleSize" value="30" min="10" max="200" step="5">
                </div>

                <div class="control-group" id="param1Group">
                    <label id="param1Label">Parameter 1</label>
                    <input type="number" id="param1" value="0" step="0.1">
                </div>

                <div class="control-group" id="param2Group">
                    <label id="param2Label">Parameter 2</label>
                    <input type="number" id="param2" value="1" step="0.1">
                </div>

                <button id="generateBtn">Generate New Sample</button>
                <button id="animateBtn">Animate Construction</button>
            </div>

            <div class="animation-controls">
                <div class="speed-control">
                    <label style="text-transform: none;">Animation Speed:</label>
                    <input type="range" id="speedSlider" min="1" max="10" value="5" step="1">
                    <span id="speedValue">●●●●●○○○○○</span>
                </div>
            </div>
        </div>

        <div class="step-indicator">
            <div class="step-text" id="stepText">Ready to generate sample</div>
            <div class="step-description" id="stepDescription">Click "Generate New Sample" to begin</div>
        </div>

        <div class="visualization-grid">
            <div class="viz-section">
                <div class="viz-title">Step 1: Sample & Standardization</div>
                <canvas id="sampleCanvas" width="600" height="300"></canvas>
                <div class="stats-row">
                    <div class="stat-item">
                        <div class="stat-label">x̄ (mean)</div>
                        <div class="stat-value" id="meanValue">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">s (std dev)</div>
                        <div class="stat-value" id="stdValue">-</div>
                    </div>
                </div>
                <div class="data-display" id="sampleDisplay"></div>
            </div>

            <div class="viz-section">
                <div class="viz-title">Step 4: QQ-Plot</div>
                <canvas id="qqCanvas" width="600" height="300"></canvas>
                <div class="data-display" id="qqDisplay"></div>
            </div>

            <div class="viz-section full-width">
                <div class="viz-title">Step 2 & 3: Transformation Process</div>
                <div class="transformation-container">
                    <div class="curve-panel">
                        <h4>Standard Normal</h4>
                        <canvas id="quantileCanvas" width="600" height="300"></canvas>
                        <div class="data-display" id="quantileDisplay"></div>
                    </div>
                    
                    <div class="arrow-panel">
                        <svg class="arrow-svg" viewBox="0 0 80 60" xmlns="http://www.w3.org/2000/svg">
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                    <polygon points="0 0, 10 3, 0 6" fill="#ffd700" />
                                </marker>
                            </defs>
                            <line x1="10" y1="30" x2="65" y2="30" stroke="#ffd700" stroke-width="3" marker-end="url(#arrowhead)" />
                        </svg>
                        <div class="transform-formula" id="formulaDisplay">
                            x̃ = z·s + x̄
                        </div>
                    </div>
                    
                    <div class="curve-panel">
                        <h4>Sample Distribution</h4>
                        <canvas id="transformCanvas" width="600" height="300"></canvas>
                        <div class="data-display" id="transformDisplay"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas contexts
        const sampleCanvas = document.getElementById('sampleCanvas');
        const sampleCtx = sampleCanvas.getContext('2d');
        const quantileCanvas = document.getElementById('quantileCanvas');
        const quantileCtx = quantileCanvas.getContext('2d');
        const transformCanvas = document.getElementById('transformCanvas');
        const transformCtx = transformCanvas.getContext('2d');
        const qqCanvas = document.getElementById('qqCanvas');
        const qqCtx = qqCanvas.getContext('2d');

        // State
        let currentSamples = [];
        let sortedSamples = [];
        let standardizedSamples = [];
        let normalQuantiles = [];
        let animationInProgress = false;
        let speedSetting = 5; // 1-10 scale

        // Generate samples from various distributions
        function generateSamples(dist, n, param1, param2) {
            const samples = [];
            
            for (let i = 0; i < n; i++) {
                switch(dist) {
                    case 'normal':
                        samples.push(jStat.normal.sample(param1, param2));
                        break;
                    case 'uniform':
                        samples.push(jStat.uniform.sample(param1, param2));
                        break;
                    case 'exponential':
                        samples.push(-Math.log(Math.random()) / param1);
                        break;
                    case 'gamma':
                        samples.push(jStat.gamma.sample(param1, param2));
                        break;
                    case 'beta':
                        samples.push(jStat.beta.sample(param1, param2));
                        break;
                    case 'cauchy':
                        samples.push(param1 + param2 * Math.tan(Math.PI * (Math.random() - 0.5)));
                        break;
                    case 't':
                        samples.push(jStat.studentt.sample(param1));
                        break;
                    case 'lognormal':
                        samples.push(jStat.lognormal.sample(param1, param2));
                        break;
                    case 'weibull':
                        samples.push(jStat.weibull.sample(param1, param2));
                        break;
                    case 'chi2':
                        samples.push(jStat.chisquare.sample(param1));
                        break;
                    case 'binomial':
                        let successes = 0;
                        const trials = Math.round(param1);
                        for (let j = 0; j < trials; j++) {
                            if (Math.random() < param2) successes++;
                        }
                        samples.push(successes);
                        break;
                    case 'poisson':
                        samples.push(jStat.poisson.sample(param1));
                        break;
                    case 'geometric':
                        const u = Math.random();
                        if (u === 0) {
                            samples.push(1);
                        } else {
                            samples.push(Math.floor(Math.log(u) / Math.log(1 - param1)) + 1);
                        }
                        break;
                }
            }
            
            return samples;
        }

        // Draw histogram with optional highlighting
        function drawHistogram(ctx, canvas, data, highlightIndex = -1, title = '') {
            const padding = 40;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (data.length === 0) return;

            // Calculate bins
            const min = Math.min(...data);
            const max = Math.max(...data);
            const range = max - min;
            const numBins = Math.ceil(Math.sqrt(data.length));
            const binWidth = range / numBins;

            const bins = new Array(numBins).fill(0);
            data.forEach(value => {
                const binIndex = Math.min(Math.floor((value - min) / binWidth), numBins - 1);
                bins[binIndex]++;
            });

            const maxBinHeight = Math.max(...bins);

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + height);
            ctx.lineTo(padding + width, padding + height);
            ctx.stroke();

            // Draw bins
            bins.forEach((count, i) => {
                const x = padding + (i / numBins) * width;
                const barWidth = width / numBins;
                const barHeight = (count / maxBinHeight) * height;
                
                ctx.fillStyle = 'rgba(70, 130, 180, 0.6)';
                ctx.fillRect(x, padding + height - barHeight, barWidth - 1, barHeight);
                ctx.strokeStyle = 'rgba(70, 130, 180, 1)';
                ctx.strokeRect(x, padding + height - barHeight, barWidth - 1, barHeight);
            });

            // Highlight specific points if index is provided
            if (highlightIndex >= 0 && highlightIndex < data.length) {
                const sortedData = [...data].sort((a, b) => a - b);
                const value = sortedData[highlightIndex];
                const x = padding + ((value - min) / range) * width;
                
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(x, padding + height - 10, 5, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Title
            if (title) {
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(title, canvas.width / 2, 20);
            }
        }

        // Draw normal distribution curve with quantiles
        function drawNormalCurve(ctx, canvas, mean, std, quantiles = [], currentIndex = -1) {
            const padding = 40;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + height);
            ctx.lineTo(padding + width, padding + height);
            ctx.stroke();

            // Draw normal curve
            const minX = mean - 4 * std;
            const maxX = mean + 4 * std;
            const range = maxX - minX;

            // Calculate max height for proper scaling
            const maxHeight = (1 / Math.sqrt(2 * Math.PI * std * std));
            const scaleY = height * 0.85 / maxHeight;

            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 3;
            ctx.beginPath();

            for (let i = 0; i <= 200; i++) {
                const x = minX + (range * i / 200);
                const z = (x - mean) / std;
                const y = (1 / Math.sqrt(2 * Math.PI * std * std)) * Math.exp(-0.5 * z * z);
                const px = padding + (i / 200) * width;
                const py = padding + height - (y * scaleY);

                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            ctx.stroke();

            // Fill area under curve up to current quantile
            if (currentIndex >= 0 && currentIndex < quantiles.length) {
                ctx.fillStyle = 'rgba(37, 99, 235, 0.2)';
                ctx.beginPath();
                ctx.moveTo(padding, padding + height);

                const targetX = quantiles[currentIndex];
                for (let i = 0; i <= 100; i++) {
                    const x = minX + ((targetX - minX) * i / 100);
                    const z = (x - mean) / std;
                    const y = (1 / Math.sqrt(2 * Math.PI * std * std)) * Math.exp(-0.5 * z * z);
                    const px = padding + ((x - minX) / range) * width;
                    const py = padding + height - (y * scaleY);
                    ctx.lineTo(px, py);
                }
                ctx.lineTo(padding + ((targetX - minX) / range) * width, padding + height);
                ctx.closePath();
                ctx.fill();

                // Mark the quantile point
                const qx = padding + ((targetX - minX) / range) * width;
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(qx, padding + height - 5, 5, 0, 2 * Math.PI);
                ctx.fill();

                // Label - use appropriate notation based on distribution
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                const label = mean === 0 && std === 1 ? `z${currentIndex + 1}` : `x̃${currentIndex + 1}`;
                ctx.fillText(label, qx, padding + height + 20);
            }

            // Draw all quantile marks
            quantiles.forEach((q, i) => {
                if (i <= currentIndex) {
                    const qx = padding + ((q - minX) / range) * width;
                    ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(qx, padding);
                    ctx.lineTo(qx, padding + height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
        }

        // Draw QQ plot
        function drawQQPlot(ctx, canvas, theoreticalQuantiles, sampleQuantiles, currentIndex = -1) {
            const padding = 60;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (theoreticalQuantiles.length === 0) return;

            // Get mean and std for the transformation line
            const mean = parseFloat(document.getElementById('meanValue').textContent);
            const std = parseFloat(document.getElementById('stdValue').textContent);

            // Find range for both theoretical (z-scores) and sample values
            const allZValues = theoreticalQuantiles;
            const allXValues = sampleQuantiles;
            
            const minZ = Math.min(...allZValues);
            const maxZ = Math.max(...allZValues);
            const minX = Math.min(...allXValues);
            const maxX = Math.max(...allXValues);
            
            const rangeZ = maxZ - minZ;
            const rangeX = maxX - minX;
            const bufferZ = rangeZ * 0.1;
            const bufferX = rangeX * 0.1;
            
            const plotMinZ = minZ - bufferZ;
            const plotMaxZ = maxZ + bufferZ;
            const plotMinX = minX - bufferX;
            const plotMaxX = maxX + bufferX;
            
            const plotRangeZ = plotMaxZ - plotMinZ;
            const plotRangeX = plotMaxX - plotMinX;

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + height);
            ctx.lineTo(padding + width, padding + height);
            ctx.stroke();

            // Draw reference line: x̃ = z·s + x̄
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            
            // Calculate where the line should go
            const z1 = plotMinZ;
            const x1 = z1 * std + mean;
            const z2 = plotMaxZ;
            const x2 = z2 * std + mean;
            
            const px1 = padding + ((z1 - plotMinZ) / plotRangeZ) * width;
            const py1 = padding + height - ((x1 - plotMinX) / plotRangeX) * height;
            const px2 = padding + ((z2 - plotMinZ) / plotRangeZ) * width;
            const py2 = padding + height - ((x2 - plotMinX) / plotRangeX) * height;
            
            ctx.moveTo(px1, py1);
            ctx.lineTo(px2, py2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw points
            const numPoints = currentIndex >= 0 ? currentIndex + 1 : theoreticalQuantiles.length;
            
            for (let i = 0; i < numPoints; i++) {
                const x = padding + ((theoreticalQuantiles[i] - plotMinZ) / plotRangeZ) * width;
                const y = padding + height - ((sampleQuantiles[i] - plotMinX) / plotRangeX) * height;

                ctx.fillStyle = i === currentIndex ? '#ff6b6b' : '#2563eb';
                ctx.beginPath();
                ctx.arc(x, y, i === currentIndex ? 6 : 4, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Theoretical Quantiles (z)', padding + width / 2, canvas.height - 5);
            
            ctx.save();
            ctx.translate(15, padding + height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Sample Quantiles (x)', 0, 0);
            ctx.restore();

            // Axis ticks and labels
            ctx.font = '10px Arial';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const value = plotMinX + (plotRangeX * i / 5);
                const y = padding + height - (height * i / 5);
                ctx.fillText(value.toFixed(1), padding - 10, y + 3);
            }

            ctx.textAlign = 'center';
            for (let i = 0; i <= 5; i++) {
                const value = plotMinZ + (plotRangeZ * i / 5);
                const x = padding + (width * i / 5);
                ctx.fillText(value.toFixed(1), x, padding + height + 20);
            }
        }

        // Update displays
        function updateDataDisplays(step) {
            const sampleDisplay = document.getElementById('sampleDisplay');
            const quantileDisplay = document.getElementById('quantileDisplay');
            const transformDisplay = document.getElementById('transformDisplay');
            const qqDisplay = document.getElementById('qqDisplay');

            if (sortedSamples.length === 0) {
                sampleDisplay.textContent = 'No data generated yet';
                quantileDisplay.textContent = '';
                transformDisplay.textContent = '';
                qqDisplay.textContent = '';
                return;
            }

            // Sample display
            if (step >= 1) {
                sampleDisplay.innerHTML = `<strong>Sorted samples:</strong><br>` +
                    sortedSamples.slice(0, 10).map(v => v.toFixed(3)).join(', ') +
                    (sortedSamples.length > 10 ? '...' : '');
            }

            // Quantile display
            if (step >= 2 && normalQuantiles.length > 0) {
                quantileDisplay.innerHTML = `<strong>Normal quantiles (z-scores):</strong><br>` +
                    normalQuantiles.slice(0, 10).map(v => v.toFixed(3)).join(', ') +
                    (normalQuantiles.length > 10 ? '...' : '');
            }

            // Transform display
            if (step >= 3 && standardizedSamples.length > 0) {
                transformDisplay.innerHTML = `<strong>Transformed quantiles:</strong><br>` +
                    normalQuantiles.slice(0, 10).map((z, i) => {
                        const mean = parseFloat(document.getElementById('meanValue').textContent);
                        const std = parseFloat(document.getElementById('stdValue').textContent);
                        return (z * std + mean).toFixed(3);
                    }).join(', ') +
                    (normalQuantiles.length > 10 ? '...' : '');
            }

            // QQ display
            if (step >= 4 && normalQuantiles.length > 0) {
                const pairs = normalQuantiles.slice(0, 5).map((q, i) => 
                    `(${q.toFixed(2)}, ${sortedSamples[i].toFixed(2)})`
                ).join(', ');
                qqDisplay.innerHTML = `<strong>QQ pairs (z, x):</strong><br>${pairs}` +
                    (normalQuantiles.length > 5 ? '...' : '');
            }
        }

        // Generate and display new sample
        function generateNewSample() {
            const dist = document.getElementById('distribution').value;
            const n = parseInt(document.getElementById('sampleSize').value);
            const param1 = parseFloat(document.getElementById('param1').value);
            const param2 = parseFloat(document.getElementById('param2').value);

            currentSamples = generateSamples(dist, n, param1, param2);
            sortedSamples = [...currentSamples].sort((a, b) => a - b);

            // Calculate statistics
            const mean = jStat.mean(sortedSamples);
            const std = jStat.stdev(sortedSamples, true);

            // Standardize samples
            standardizedSamples = sortedSamples.map(x => (x - mean) / std);

            // Calculate normal quantiles
            normalQuantiles = [];
            for (let i = 0; i < n; i++) {
                const p = (i + 0.5) / n;
                normalQuantiles.push(jStat.normal.inv(p, 0, 1));
            }

            // Update displays
            document.getElementById('meanValue').textContent = mean.toFixed(3);
            document.getElementById('stdValue').textContent = std.toFixed(3);
            
            // Update formula with actual values
            document.getElementById('formulaDisplay').innerHTML = 
                `x̃ = z·${std.toFixed(2)} + ${mean.toFixed(2)}`;

            // Draw initial state
            drawHistogram(sampleCtx, sampleCanvas, sortedSamples);
            drawNormalCurve(quantileCtx, quantileCanvas, 0, 1);
            drawNormalCurve(transformCtx, transformCanvas, mean, std);
            
            // Clear QQ plot initially
            qqCtx.clearRect(0, 0, qqCanvas.width, qqCanvas.height);
            const qqPadding = 60;
            qqCtx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            qqCtx.fillRect(qqPadding, qqPadding, qqCanvas.width - 2 * qqPadding, qqCanvas.height - 2 * qqPadding);
            qqCtx.fillStyle = '#666';
            qqCtx.font = '16px Arial';
            qqCtx.textAlign = 'center';
            qqCtx.fillText('QQ-Plot will appear after animation', qqCanvas.width / 2, qqCanvas.height / 2);

            updateDataDisplays(1);
            updateStepIndicator(1, 'Sample generated and sorted');

            // Enable animate button
            document.getElementById('animateBtn').disabled = false;
        }

        // Update step indicator
        function updateStepIndicator(step, description) {
            const stepText = document.getElementById('stepText');
            const stepDesc = document.getElementById('stepDescription');

            switch(step) {
                case 1:
                    stepText.textContent = 'Step 1: Generate and Sort Sample';
                    stepDesc.textContent = 'Generated n samples, calculated x̄ and s, sorted values';
                    break;
                case 2:
                    stepText.textContent = 'Step 2: Calculate Standard Normal Quantiles';
                    stepDesc.textContent = 'For each i, calculate probability pᵢ = (i+0.5)/n and find corresponding z-score from N(0,1)';
                    break;
                case 3:
                    stepText.textContent = 'Step 3: Transform to Sample Distribution';
                    stepDesc.textContent = 'Transform standard normal quantiles using sample statistics: x = z·s + x̄';
                    break;
                case 4:
                    stepText.textContent = 'Step 4: Create QQ-Plot';
                    stepDesc.textContent = 'Plot pairs (z, x) - if data is normal, points follow line x̃ = z·s + x̄';
                    break;
                default:
                    stepText.textContent = description;
                    stepDesc.textContent = '';
            }
        }

        // Animate the construction process
        async function animateConstruction() {
            if (sortedSamples.length === 0) {
                generateNewSample();
                await sleep(500);
            }

            animationInProgress = true;
            document.getElementById('animateBtn').disabled = true;
            document.getElementById('generateBtn').disabled = true;

            const n = sortedSamples.length;
            const mean = parseFloat(document.getElementById('meanValue').textContent);
            const std = parseFloat(document.getElementById('stdValue').textContent);

            // Calculate delay: fixed total time divided by number of points
            // More points = faster per point, higher speed setting = faster overall
            const totalTime = 6000 / speedSetting; // Total animation time in ms
            const delayPerPoint = totalTime / n; // Divide by n so more points = faster per point

            // Step 1: Show sorted samples
            updateStepIndicator(1);
            drawHistogram(sampleCtx, sampleCanvas, sortedSamples, -1, 'Sorted Sample Distribution');
            await sleep(500);

            // Step 2: Build normal quantiles progressively
            updateStepIndicator(2);
            updateDataDisplays(2);
            
            for (let i = 0; i < n; i++) {
                drawNormalCurve(quantileCtx, quantileCanvas, 0, 1, normalQuantiles.slice(0, i + 1), i);
                await sleep(delayPerPoint);
            }

            // Step 3: Show transformation
            updateStepIndicator(3);
            updateDataDisplays(3);
            
            const transformedQuantiles = normalQuantiles.map(z => z * std + mean);
            for (let i = 0; i < n; i++) {
                drawNormalCurve(transformCtx, transformCanvas, mean, std, transformedQuantiles.slice(0, i + 1), i);
                await sleep(delayPerPoint * 0.7);
            }

            // Step 4: Build QQ plot
            updateStepIndicator(4);
            updateDataDisplays(4);
            
            for (let i = 0; i < n; i++) {
                drawQQPlot(qqCtx, qqCanvas, normalQuantiles, sortedSamples, i);
                await sleep(delayPerPoint * 0.5);
            }
            
            // Show complete QQ plot
            drawQQPlot(qqCtx, qqCanvas, normalQuantiles, sortedSamples, -1);

            animationInProgress = false;
            document.getElementById('animateBtn').disabled = false;
            document.getElementById('generateBtn').disabled = false;
        }

        // Utility function for animation delays
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Update parameter labels based on distribution
        function updateParameterLabels() {
            const dist = document.getElementById('distribution').value;
            const param1Label = document.getElementById('param1Label');
            const param2Label = document.getElementById('param2Label');
            const param1Input = document.getElementById('param1');
            const param2Input = document.getElementById('param2');
            const param1Group = document.getElementById('param1Group');
            const param2Group = document.getElementById('param2Group');
            
            param1Input.removeAttribute('max');
            param2Input.removeAttribute('max');
            param1Input.min = '';
            param2Input.min = '';
            param1Input.step = '0.1';
            param2Input.step = '0.1';
            
            switch(dist) {
                case 'normal':
                    param1Label.textContent = 'Mean (μ)';
                    param2Label.textContent = 'Std Dev (σ)';
                    param1Input.value = 0;
                    param2Input.value = 1;
                    param2Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'uniform':
                    param1Label.textContent = 'Min (a)';
                    param2Label.textContent = 'Max (b)';
                    param1Input.value = 0;
                    param2Input.value = 1;
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'exponential':
                    param1Label.textContent = 'Rate (λ)';
                    param1Input.value = 1;
                    param1Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'none';
                    break;
                    
                case 'gamma':
                    param1Label.textContent = 'Shape (α)';
                    param2Label.textContent = 'Scale (β)';
                    param1Input.value = 2;
                    param2Input.value = 1;
                    param1Input.min = '0.01';
                    param2Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'beta':
                    param1Label.textContent = 'Alpha (α)';
                    param2Label.textContent = 'Beta (β)';
                    param1Input.value = 2;
                    param2Input.value = 5;
                    param1Input.min = '0.1';
                    param2Input.min = '0.1';
                    param1Input.step = '0.5';
                    param2Input.step = '0.5';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'cauchy':
                    param1Label.textContent = 'Location (x₀)';
                    param2Label.textContent = 'Scale (γ)';
                    param1Input.value = 0;
                    param2Input.value = 1;
                    param2Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 't':
                    param1Label.textContent = 'Degrees of Freedom';
                    param1Input.value = 3;
                    param1Input.step = '1';
                    param1Input.min = '1';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'none';
                    break;
                    
                case 'lognormal':
                    param1Label.textContent = 'Log Mean (μ)';
                    param2Label.textContent = 'Log Std (σ)';
                    param1Input.value = 0;
                    param2Input.value = 0.5;
                    param2Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'weibull':
                    param1Label.textContent = 'Scale (λ)';
                    param2Label.textContent = 'Shape (k)';
                    param1Input.value = 1;
                    param2Input.value = 2;
                    param1Input.min = '0.01';
                    param2Input.min = '0.01';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'chi2':
                    param1Label.textContent = 'Degrees of Freedom';
                    param1Input.value = 3;
                    param1Input.step = '1';
                    param1Input.min = '1';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'none';
                    break;
                    
                case 'binomial':
                    param1Label.textContent = 'Trials (n)';
                    param2Label.textContent = 'Probability (p)';
                    param1Input.value = 20;
                    param2Input.value = 0.3;
                    param1Input.step = '1';
                    param2Input.step = '0.05';
                    param1Input.min = '1';
                    param2Input.min = '0';
                    param2Input.max = '1';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'flex';
                    break;
                    
                case 'poisson':
                    param1Label.textContent = 'Rate (λ)';
                    param1Input.value = 3;
                    param1Input.step = '0.5';
                    param1Input.min = '0.1';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'none';
                    break;
                    
                case 'geometric':
                    param1Label.textContent = 'Probability (p)';
                    param1Input.value = 0.3;
                    param1Input.step = '0.05';
                    param1Input.min = '0.01';
                    param1Input.max = '1';
                    param1Group.style.display = 'flex';
                    param2Group.style.display = 'none';
                    break;
            }
        }

        // Event listeners
        document.getElementById('generateBtn').addEventListener('click', generateNewSample);
        document.getElementById('animateBtn').addEventListener('click', animateConstruction);
        
        document.getElementById('distribution').addEventListener('change', () => {
            updateParameterLabels();
            currentSamples = [];
        });
        
        document.getElementById('param1').addEventListener('change', () => {
            currentSamples = [];
        });
        
        document.getElementById('param2').addEventListener('change', () => {
            currentSamples = [];
        });
        
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            speedSetting = parseInt(e.target.value);
            const dots = '●'.repeat(speedSetting) + '○'.repeat(10 - speedSetting);
            document.getElementById('speedValue').textContent = dots;
        });

        // Initial state
        updateParameterLabels();
        updateStepIndicator(0, 'Ready to generate sample');
    </script>
</body>
</html>